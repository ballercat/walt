// Generated automatically by nearley, version 2.15.1
// http://github.com/Hardmath123/nearley
(function () {
function id(x) { return x[0]; }

  const moo = require('moo');
  const Syntax = require('walt-syntax');
  const { drop, nth, nuller, nonEmpty, add, flatten, compose } = require('./helpers');

  const mooLexer = moo.compile(Syntax.tokens);
  // Additional utility on top of the default moo lexer.
  const lexer = {
    current: null,
    lines: [],
    get line() {
      return mooLexer.line;
    },
    get col() {
      return mooLexer.col;
    },
    save() {
      return mooLexer.save();
    },
    reset(chunk, info){
      this.lines = chunk.split('\n');
      return mooLexer.reset(chunk, info);
    },
    next() {
      // It's a cruel and unusual punishment to implement comments with nearly
      let token = mooLexer.next();
      while(token && token.type === 'comment')
        token = mooLexer.next();
      this.current = token;
      return this.current;
    },
    formatError(token) {
      return mooLexer.formatError(token);
    },
    has(name) {
      return mooLexer.has(name);
    }
  };

  const {
    node,
    binary,
    constant,
    identifier,
    statement,
    unary,
    ternary,
    subscript,
    fun,
    declaration,
    call,
    struct,
    result,
    string,
    typedef,
    comment,
    voidFun,
    type,
    boolean,
    assignment,
    forLoop,
    whileLoop,
    typeGeneric,
    spread,
    builtinDecl,
  } = require('./nodes')(lexer);
var grammar = {
    Lexer: lexer,
    ParserRules: [
    {"name": "_$ebnf$1", "symbols": []},
    {"name": "_$ebnf$1", "symbols": ["_$ebnf$1", "wschar"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "_", "symbols": ["_$ebnf$1"], "postprocess": function(d) {return null;}},
    {"name": "__$ebnf$1", "symbols": ["wschar"]},
    {"name": "__$ebnf$1", "symbols": ["__$ebnf$1", "wschar"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "__", "symbols": ["__$ebnf$1"], "postprocess": function(d) {return null;}},
    {"name": "wschar", "symbols": [/[ \t\n\v\f]/], "postprocess": id},
    {"name": "StaticObjectLiteral", "symbols": ["LCB", "_", "RCB"], "postprocess": compose(node(Syntax.ObjectLiteral))},
    {"name": "StaticObjectLiteral", "symbols": ["LCB", "_", "StaticPropertyList", "_", "RCB"], "postprocess": compose(node(Syntax.ObjectLiteral), flatten)},
    {"name": "StaticPropertyValue", "symbols": ["Number"], "postprocess": id},
    {"name": "StaticPropertyValue", "symbols": ["Boolean"], "postprocess": id},
    {"name": "StaticPropertyValue", "symbols": ["StringLiteral"], "postprocess": id},
    {"name": "StaticProperty", "symbols": ["Identifier", "_", "COLON", "_", "StaticPropertyValue"], "postprocess": node(Syntax.Pair)},
    {"name": "StaticPropertyList", "symbols": ["StaticProperty"], "postprocess": id},
    {"name": "StaticPropertyList", "symbols": ["StaticProperty", "_", "COMMA", "_", "StaticPropertyList"], "postprocess": id},
    {"name": "ObjectLiteral", "symbols": ["LCB", "_", "RCB"], "postprocess": node(Syntax.ObjectLiteral)},
    {"name": "ObjectLiteral", "symbols": ["LCB", "_", "PropertyList", "_", "RCB"], "postprocess": compose(node(Syntax.ObjectLiteral), flatten)},
    {"name": "PropertyList", "symbols": ["Property"], "postprocess": id},
    {"name": "PropertyList", "symbols": ["Property", "_", "COMMA", "_", "PropertyList"], "postprocess": flatten},
    {"name": "Property", "symbols": ["Identifier", "_", "COLON", "_", "Ternary"], "postprocess": node(Syntax.Pair)},
    {"name": "Property", "symbols": ["SPREAD", "Identifier"], "postprocess": spread},
    {"name": "Property", "symbols": ["Identifier"], "postprocess": id},
    {"name": "StructDefinition", "symbols": ["LCB", "_", "PropertyNameAndTypeList", "_", "RCB"], "postprocess": compose(node(Syntax.ObjectLiteral), flatten)},
    {"name": "PropertyNameAndTypeList", "symbols": ["PropertyNameAndType"], "postprocess": id},
    {"name": "PropertyNameAndTypeList", "symbols": ["PropertyNameAndType", "_", "COMMA", "_", "PropertyNameAndTypeList"], "postprocess": flatten},
    {"name": "PropertyNameAndType", "symbols": ["PropertyName", "_", "COLON", "_", "Type"], "postprocess": node(Syntax.Pair)},
    {"name": "TypeDefinition", "symbols": ["LB", "_", "TypeList", "_", "RB"], "postprocess": flatten},
    {"name": "TypeDefinition", "symbols": ["LB", "_", "RB"], "postprocess": flatten},
    {"name": "TypeList", "symbols": ["Type"], "postprocess": id},
    {"name": "TypeList", "symbols": ["Type", "_", "COMMA", "_", "TypeList"], "postprocess": flatten},
    {"name": "PropertyName", "symbols": ["Identifier"], "postprocess": id},
    {"name": "Import", "symbols": ["IMPORT", "_", "ImportDefinition", "__", "FROM", "__", "StringLiteral", "_", "SEPARATOR"], "postprocess": node(Syntax.Import)},
    {"name": "ImportDefinition", "symbols": ["LCB", "_", "ImportAndTypeList", "_", "RCB"], "postprocess": compose(node(Syntax.ObjectLiteral), flatten)},
    {"name": "ImportAndTypeList", "symbols": ["ImportName"], "postprocess": id},
    {"name": "ImportAndTypeList", "symbols": ["ImportAndType"], "postprocess": id},
    {"name": "ImportAndTypeList", "symbols": ["ImportName", "_", "COMMA", "_", "ImportAndTypeList"], "postprocess": flatten},
    {"name": "ImportAndTypeList", "symbols": ["ImportAndType", "_", "COMMA", "_", "ImportAndTypeList"], "postprocess": flatten},
    {"name": "ImportAndType", "symbols": ["ImportName", "_", "COLON", "_", "Type"], "postprocess": node(Syntax.Pair)},
    {"name": "ImportAndType", "symbols": ["ImportName", "_", "AS", "_", "Identifier"], "postprocess": node(Syntax.BinaryExpression)},
    {"name": "ImportAndType", "symbols": ["ImportAndType", "_", "AS", "_", "Identifier"], "postprocess": node(Syntax.BinaryExpression)},
    {"name": "ImportName", "symbols": ["Identifier"], "postprocess": id},
    {"name": "If", "symbols": ["IF", "_", "LB", "_", "Expression", "_", "RB", "_", "BranchBody"], "postprocess": node(Syntax.IfThenElse)},
    {"name": "If", "symbols": ["IF", "_", "LB", "_", "Expression", "_", "RB", "_", "BranchBody", "_", "Else"], "postprocess": node(Syntax.IfThenElse)},
    {"name": "Else", "symbols": ["ELSE", "_", "BranchBody"], "postprocess": node(Syntax.Else)},
    {"name": "BranchBody", "symbols": ["Statement"], "postprocess": id},
    {"name": "BranchBody", "symbols": ["Block"], "postprocess": id},
    {"name": "For", "symbols": ["FOR", "_", "LB", "_", "Expression", "_", "SEPARATOR", "_", "Expression", "_", "SEPARATOR", "_", "Expression", "_", "RB", "_", "BranchBody"], "postprocess": forLoop},
    {"name": "While", "symbols": ["WHILE", "_", "LB", "_", "Expression", "_", "RB", "_", "BranchBody"], "postprocess": whileLoop},
    {"name": "Break", "symbols": ["BREAK", "_", "SEPARATOR"], "postprocess": node(Syntax.Break)},
    {"name": "Program", "symbols": ["_"], "postprocess": compose(node('Program', {  value: 'ROOT_NODE' }), flatten)},
    {"name": "Program", "symbols": ["_", "SourceElementList", "_"], "postprocess": compose(node('Program', {  value: 'ROOT_NODE' }), flatten)},
    {"name": "SourceElementList", "symbols": ["SourceElement"], "postprocess": flatten},
    {"name": "SourceElementList", "symbols": ["SourceElement", "_", "SourceElementList"], "postprocess": compose(drop, flatten, flatten)},
    {"name": "SourceElement", "symbols": ["Function"], "postprocess": id},
    {"name": "SourceElement", "symbols": ["Declaration"], "postprocess": id},
    {"name": "SourceElement", "symbols": ["ImmutableDeclaration"], "postprocess": id},
    {"name": "SourceElement", "symbols": ["Struct"], "postprocess": id},
    {"name": "SourceElement", "symbols": ["TypeDef"], "postprocess": id},
    {"name": "SourceElement", "symbols": ["Export"], "postprocess": id},
    {"name": "SourceElement", "symbols": ["Import"], "postprocess": id},
    {"name": "Statement", "symbols": ["ExpressionStatement"], "postprocess": id},
    {"name": "Statement", "symbols": ["Declaration"], "postprocess": id},
    {"name": "Statement", "symbols": ["ImmutableDeclaration"], "postprocess": id},
    {"name": "Statement", "symbols": ["If"], "postprocess": id},
    {"name": "Statement", "symbols": ["For"], "postprocess": id},
    {"name": "Statement", "symbols": ["While"], "postprocess": id},
    {"name": "Statement", "symbols": ["Break"], "postprocess": id},
    {"name": "Statement", "symbols": ["ReturnStatement"], "postprocess": id},
    {"name": "Block", "symbols": ["LCB", "_", "RCB"], "postprocess": node(Syntax.Block)},
    {"name": "Block", "symbols": ["LCB", "_", "StatementList", "_", "RCB"], "postprocess": compose(node(Syntax.Block), flatten)},
    {"name": "StatementList", "symbols": ["Statement"], "postprocess": drop},
    {"name": "StatementList", "symbols": ["Statement", "_", "StatementList"], "postprocess": flatten},
    {"name": "Function", "symbols": ["FUNCTION", "__", "Identifier", "_", "FunctionParameters", "_", "Block"], "postprocess": voidFun},
    {"name": "Function", "symbols": ["FUNCTION", "__", "Identifier", "_", "FunctionParameters", "_", "FunctionResult", "_", "Block"], "postprocess": fun},
    {"name": "FunctionParameters", "symbols": ["LB", "_", "RB"], "postprocess": node(Syntax.FunctionArguments)},
    {"name": "FunctionParameters", "symbols": ["LB", "_", "ParameterList", "_", "RB"], "postprocess": compose(node(Syntax.FunctionArguments), flatten)},
    {"name": "ParameterList", "symbols": ["PropertyNameAndType"], "postprocess": id},
    {"name": "ParameterList", "symbols": ["PropertyNameAndType", "_", "COMMA", "_", "ParameterList"], "postprocess": flatten},
    {"name": "FunctionResult", "symbols": ["COLON", "_", "Type"], "postprocess": compose(result, drop)},
    {"name": "Declaration", "symbols": ["LET", "_", "PropertyNameAndType", "_", "EQUALS", "_", "ExpressionStatement"], "postprocess": declaration(Syntax.Declaration)},
    {"name": "Declaration", "symbols": ["LET", "_", "PropertyNameAndType", "_", "SEPARATOR"], "postprocess": declaration(Syntax.Declaration)},
    {"name": "ImmutableDeclaration", "symbols": ["CONST", "_", "PropertyNameAndType", "_", "EQUALS", "_", "ExpressionStatement"], "postprocess": declaration(Syntax.ImmutableDeclaration)},
    {"name": "ImmutableDeclaration", "symbols": ["CONST", "_", "PropertyNameAndType", "_", "EQUALS", "_", "ObjectLiteral", "_", "SEPARATOR"], "postprocess": declaration(Syntax.ImmutableDeclaration)},
    {"name": "ImmutableDeclaration", "symbols": ["CONST", "_", "Identifier", "_", "COLON", "_", "GenericType", "_", "SEPARATOR"], "postprocess": builtinDecl},
    {"name": "Pair", "symbols": ["Identifier", "_", "COLON", "_", "Identifier"], "postprocess": node(Syntax.Pair)},
    {"name": "Export", "symbols": ["EXPORT", "__", "ImmutableDeclaration"], "postprocess": node(Syntax.Export, { value: 'export' })},
    {"name": "Export", "symbols": ["EXPORT", "__", "Function"], "postprocess": node(Syntax.Export, { value: 'export' })},
    {"name": "Export", "symbols": ["EXPORT", "__", "TypeDef"], "postprocess": node(Syntax.Export, { value: 'export' })},
    {"name": "Export", "symbols": ["EXPORT", "__", "Struct"], "postprocess": node(Syntax.Export, { value: 'export' })},
    {"name": "ReturnStatement", "symbols": ["RETURN", "__", "ExpressionStatement"], "postprocess": node(Syntax.ReturnStatement)},
    {"name": "ReturnStatement", "symbols": ["RETURN", "_", "SEPARATOR"], "postprocess": node(Syntax.ReturnStatement)},
    {"name": "Struct", "symbols": ["TYPE", "__", "Identifier", "_", "EQUALS", "_", "StructDefinition", "SEPARATOR"], "postprocess": struct},
    {"name": "TypeDef", "symbols": ["TYPE", "__", "Identifier", "_", "EQUALS", "_", "TypeDefinition", "_", "FATARROW", "_", "Type", "_", "SEPARATOR"], "postprocess": compose(typedef)},
    {"name": "ExpressionStatement", "symbols": ["Expression", "SEPARATOR"], "postprocess": id},
    {"name": "Expression", "symbols": ["Assignment"], "postprocess": id},
    {"name": "Assignment", "symbols": ["Access", "_", "EQUALS", "_", "Ternary"], "postprocess": d => assignment(d, '=')},
    {"name": "Assignment", "symbols": ["Access", "_", "PLSEQUALS", "_", "Ternary"], "postprocess": d => assignment(d, '+=')},
    {"name": "Assignment", "symbols": ["Access", "_", "MINEQUALS", "_", "Ternary"], "postprocess": d => assignment(d, '-=')},
    {"name": "Assignment", "symbols": ["Access", "_", "EQUALS", "_", "ObjectLiteral"], "postprocess": d => assignment(d, '=')},
    {"name": "Assignment", "symbols": ["Ternary"], "postprocess": id},
    {"name": "Ternary", "symbols": ["Ternary", "_", "QUESTION", "_", "TernaryPair"], "postprocess": ternary},
    {"name": "Ternary", "symbols": ["Binary"], "postprocess": id},
    {"name": "TernaryPair", "symbols": ["Expression", "_", "COLON", "_", "Expression"], "postprocess": node(Syntax.Pair)},
    {"name": "Binary", "symbols": ["Logical"], "postprocess": id},
    {"name": "Logical", "symbols": ["Logical", "_", {"literal":"||"}, "_", "Bitwise"], "postprocess": binary},
    {"name": "Logical", "symbols": ["Logical", "_", {"literal":"&&"}, "_", "Bitwise"], "postprocess": binary},
    {"name": "Logical", "symbols": ["Bitwise"], "postprocess": id},
    {"name": "Bitwise", "symbols": ["Bitwise", "_", {"literal":"|"}, "_", "Sum"], "postprocess": binary},
    {"name": "Bitwise", "symbols": ["Bitwise", "_", {"literal":"^"}, "_", "Sum"], "postprocess": binary},
    {"name": "Bitwise", "symbols": ["Bitwise", "_", {"literal":"&"}, "_", "Sum"], "postprocess": binary},
    {"name": "Bitwise", "symbols": ["Equality"], "postprocess": id},
    {"name": "Equality", "symbols": ["Equality", "_", {"literal":"=="}, "_", "Comparison"], "postprocess": binary},
    {"name": "Equality", "symbols": ["Equality", "_", {"literal":"!="}, "_", "Comparison"], "postprocess": binary},
    {"name": "Equality", "symbols": ["Comparison"], "postprocess": id},
    {"name": "Comparison", "symbols": ["Comparison", "_", {"literal":"<"}, "_", "Shift"], "postprocess": binary},
    {"name": "Comparison", "symbols": ["Comparison", "_", {"literal":">"}, "_", "Shift"], "postprocess": binary},
    {"name": "Comparison", "symbols": ["Comparison", "_", {"literal":"<="}, "_", "Shift"], "postprocess": binary},
    {"name": "Comparison", "symbols": ["Comparison", "_", {"literal":">="}, "_", "Shift"], "postprocess": binary},
    {"name": "Comparison", "symbols": ["Shift"], "postprocess": id},
    {"name": "Shift", "symbols": ["Shift", "_", {"literal":">>"}, "_", "Sum"], "postprocess": binary},
    {"name": "Shift", "symbols": ["Shift", "_", {"literal":"<<"}, "_", "Sum"], "postprocess": binary},
    {"name": "Shift", "symbols": ["Shift", "_", {"literal":">>>"}, "_", "Sum"], "postprocess": binary},
    {"name": "Shift", "symbols": ["Sum"], "postprocess": id},
    {"name": "Sum", "symbols": ["Sum", "_", {"literal":"+"}, "_", "Product"], "postprocess": binary},
    {"name": "Sum", "symbols": ["Sum", "_", {"literal":"-"}, "_", "Product"], "postprocess": binary},
    {"name": "Sum", "symbols": ["Product"], "postprocess": id},
    {"name": "Product", "symbols": ["Product", "_", {"literal":"*"}, "_", "Typecast"], "postprocess": binary},
    {"name": "Product", "symbols": ["Product", "_", {"literal":"/"}, "_", "Typecast"], "postprocess": binary},
    {"name": "Product", "symbols": ["Product", "_", {"literal":"%"}, "_", "Typecast"], "postprocess": binary},
    {"name": "Product", "symbols": ["Typecast"], "postprocess": id},
    {"name": "Typecast", "symbols": ["Expression", "_", "COLON", "_", "Type"], "postprocess": node(Syntax.Pair)},
    {"name": "Typecast", "symbols": ["Unary"], "postprocess": id},
    {"name": "Unary", "symbols": [{"literal":"!"}, "Call"], "postprocess": unary},
    {"name": "Unary", "symbols": [{"literal":"~"}, "Call"], "postprocess": unary},
    {"name": "Unary", "symbols": [{"literal":"-"}, "Call"], "postprocess": unary},
    {"name": "Unary", "symbols": [{"literal":"+"}, "Call"], "postprocess": unary},
    {"name": "Unary", "symbols": [{"literal":"++"}, "Call"], "postprocess": unary},
    {"name": "Unary", "symbols": [{"literal":"--"}, "Call"], "postprocess": unary},
    {"name": "Unary", "symbols": ["Call"], "postprocess": id},
    {"name": "Call", "symbols": ["Access", "_", "LB", "_", "ArgumentList", "_", "RB"], "postprocess": compose(call, flatten)},
    {"name": "Call", "symbols": ["Access", "_", "LB", "_", "RB"], "postprocess": call},
    {"name": "Call", "symbols": ["Access"], "postprocess": id},
    {"name": "ArgumentList", "symbols": ["Expression"], "postprocess": id},
    {"name": "ArgumentList", "symbols": ["Expression", "_", "COMMA", "_", "ArgumentList"], "postprocess": flatten},
    {"name": "Access", "symbols": ["Identifier", "DOT", "Identifier"], "postprocess": subscript},
    {"name": "Access", "symbols": ["NativeType", "DOT", "Identifier"], "postprocess": subscript},
    {"name": "Access", "symbols": ["Identifier", "LSB", "_", "Ternary", "_", "RSB"], "postprocess": subscript},
    {"name": "Access", "symbols": ["Grouping"], "postprocess": id},
    {"name": "Grouping", "symbols": ["LB", "_", "Expression", "_", "RB"], "postprocess": nth(2)},
    {"name": "Grouping", "symbols": ["Atom"], "postprocess": id},
    {"name": "Atom", "symbols": ["Identifier"], "postprocess": id},
    {"name": "Atom", "symbols": ["StringLiteral"], "postprocess": id},
    {"name": "Atom", "symbols": ["Number"], "postprocess": id},
    {"name": "Type", "symbols": ["_Type"], "postprocess": id},
    {"name": "Type", "symbols": ["_Type", "_", "LSB", "_", "RSB"], "postprocess": d => ({ ...d[0], value: d[0].value + "[]", type: d[0].type + "[]" })},
    {"name": "_Type", "symbols": ["NativeType"], "postprocess": id},
    {"name": "_Type", "symbols": ["GenericType"], "postprocess": id},
    {"name": "_Type", "symbols": ["Identifier"], "postprocess": type},
    {"name": "NativeType", "symbols": [(lexer.has("type") ? {type: "type"} : type)], "postprocess": type},
    {"name": "GenericType", "symbols": ["Identifier", "LT", "_", "StaticObjectLiteral", "_", "GT"], "postprocess": typeGeneric},
    {"name": "Identifier", "symbols": [(lexer.has("identifier") ? {type: "identifier"} : identifier)], "postprocess": identifier},
    {"name": "Number", "symbols": [(lexer.has("number") ? {type: "number"} : number)], "postprocess": constant},
    {"name": "StringLiteral", "symbols": [(lexer.has("string") ? {type: "string"} : string)], "postprocess": string},
    {"name": "Boolean", "symbols": [{"literal":"true"}], "postprocess": boolean},
    {"name": "Boolean", "symbols": [{"literal":"false"}], "postprocess": boolean},
    {"name": "word", "symbols": [/[a-zA-Z_]/], "postprocess": id},
    {"name": "word", "symbols": ["word", /[a-zA-Z0-9_]/], "postprocess": add},
    {"name": "digit", "symbols": [/[0-9]/], "postprocess": id},
    {"name": "digit", "symbols": ["digit", /[0-9]/], "postprocess": add},
    {"name": "Comment", "symbols": [(lexer.has("comment") ? {type: "comment"} : comment)], "postprocess": comment},
    {"name": "Comment", "symbols": [(lexer.has("comment") ? {type: "comment"} : comment), "_", "Comment"], "postprocess": comment},
    {"name": "SEPARATOR", "symbols": ["_", {"literal":";"}], "postprocess": nuller},
    {"name": "QUESTION", "symbols": [{"literal":"?"}], "postprocess": nuller},
    {"name": "COMMA", "symbols": [{"literal":","}], "postprocess": nuller},
    {"name": "DOT", "symbols": [{"literal":"."}], "postprocess": nuller},
    {"name": "LB", "symbols": [{"literal":"("}], "postprocess": nuller},
    {"name": "RB", "symbols": [{"literal":")"}], "postprocess": nuller},
    {"name": "LSB", "symbols": [{"literal":"["}], "postprocess": nuller},
    {"name": "RSB", "symbols": [{"literal":"]"}], "postprocess": nuller},
    {"name": "LCB", "symbols": [{"literal":"{"}], "postprocess": nuller},
    {"name": "RCB", "symbols": [{"literal":"}"}], "postprocess": nuller},
    {"name": "COLON", "symbols": [{"literal":":"}], "postprocess": nuller},
    {"name": "EQUALS", "symbols": [{"literal":"="}], "postprocess": nuller},
    {"name": "PLSEQUALS", "symbols": [{"literal":"+="}], "postprocess": nuller},
    {"name": "MINEQUALS", "symbols": [{"literal":"-="}], "postprocess": nuller},
    {"name": "GT", "symbols": [{"literal":">"}], "postprocess": nuller},
    {"name": "LT", "symbols": [{"literal":"<"}], "postprocess": nuller},
    {"name": "FATARROW", "symbols": [{"literal":"=>"}], "postprocess": nuller},
    {"name": "SPREAD", "symbols": [{"literal":"..."}], "postprocess": nuller},
    {"name": "FUNCTION", "symbols": [{"literal":"function"}], "postprocess": nuller},
    {"name": "LET", "symbols": [{"literal":"let"}], "postprocess": nuller},
    {"name": "CONST", "symbols": [{"literal":"const"}], "postprocess": nuller},
    {"name": "EXPORT", "symbols": [{"literal":"export"}], "postprocess": nuller},
    {"name": "IMPORT", "symbols": [{"literal":"import"}], "postprocess": nuller},
    {"name": "AS", "symbols": [{"literal":"as"}], "postprocess": nuller},
    {"name": "FROM", "symbols": [{"literal":"from"}], "postprocess": nuller},
    {"name": "RETURN", "symbols": [{"literal":"return"}], "postprocess": nuller},
    {"name": "TYPE", "symbols": [{"literal":"type"}], "postprocess": nuller},
    {"name": "IF", "symbols": [{"literal":"if"}], "postprocess": nuller},
    {"name": "ELSE", "symbols": [{"literal":"else"}], "postprocess": nuller},
    {"name": "FOR", "symbols": [{"literal":"for"}], "postprocess": nuller},
    {"name": "WHILE", "symbols": [{"literal":"while"}], "postprocess": nuller},
    {"name": "SWITCH", "symbols": [{"literal":"switch"}], "postprocess": nuller},
    {"name": "DO", "symbols": [{"literal":"do"}], "postprocess": nuller},
    {"name": "BREAK", "symbols": [{"literal":"break"}], "postprocess": nuller}
]
  , ParserStart: "Program"
}
if (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {
   module.exports = grammar;
} else {
   window.grammar = grammar;
}
})();
