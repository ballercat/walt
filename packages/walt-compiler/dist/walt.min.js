!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n(e.Walt={})}(this,function(exports){"use strict";function blockParser(e){const n=e.startNode(),t=[];if(e.eat(["{"])){let n;for(;e.token&&"}"!==e.token.value;)(n=statement(e))&&t.push(n);e.expect(["}"])}return e.endNode(_extends({},n,{params:t}),Syntax.Block)}function parselambda(e,n,t){const a=t[0],r=t[1],i=t[2]||r||a;t.splice(-3);let o=[];const s=_extends({},n,{type:"i32",range:[e.token.start,e.token.end],meta:{},Type:Syntax.Closure,params:[]}),[u,c]=a.params;return o=a.Type===Syntax.Pair?null!=u&&null!=c?u.Type===Syntax.Pair?[makeArgs(u),makeResult(c)]:[makeArgs(u.Type===Syntax.Sequence?u:a),makeResult(c.Type===Syntax.Type?c:null)]:[makeArgs(null),makeResult(u)]:a.Type===Syntax.Sequence?[makeArgs(a),makeResult(r.Type===Syntax.Type?r:null)]:[makeArgs(null),makeResult(null)],_extends({},s,{params:[_extends({},s,{Type:Syntax.FunctionDeclaration,params:[...o,i]})]})}function binary(e,n,t){const a=_extends({},t[0]);a.value=n.value,a.params=t;let r=Syntax.BinaryExpression;if("="===a.value)r=Syntax.Assignment;else if("-="===a.value||"+="===a.value){r=Syntax.Assignment;const t=a.value[0];a.value="=",a.params=[a.params[0],binary(e,_extends({},n,{value:t}),[a.params[0],a.params[1]])]}else{if("["===a.value||"."===a.value)return subscriptFromNode(e,a);":"===a.value?r=Syntax.Pair:"||"!==a.value&&"&&"!==a.value||(r=Syntax.Select)}return e.endNode(a,r)}function unary(e,n,t){const[a]=t;switch(n.value){case"--":return _extends({},a,{Type:Syntax.UnaryExpression,value:"-",meta:{},params:[_extends({},a,{value:"0",Type:Syntax.Constant,params:[],meta:{}}),a]});case"!":case"~":return _extends({},a,{value:n.value,params:t,Type:Syntax.UnaryExpression});default:return _extends({},n,{range:[n.start,a.range[1]],meta:{},Type:Syntax.Spread,params:[a]})}}function objectLiteral(e,n,t){const a=e.startNode(n);return a.params=t,e.endNode(a,Syntax.ObjectLiteral)}function parseConstant(e){const n=e.startNode(),t=e.token.value,a=-1!==t.toString().indexOf(".")?"f32":"i32";return e.endNode(_extends({},n,{type:a,value:t}),Syntax.Constant)}function stringLiteral(e){const n=e.startNode();switch(n.value=e.token.value.substring(1,e.token.value.length-1),n.value){case"\\b":n.value="\b";break;case"\\f":n.value="\f";break;case"\\n":n.value="\n";break;case"\\r":n.value="\r";break;case"\\t":n.value="\t";break;case"\\v":n.value="\v";break;case"\\0":n.value="\0";break;case"\\'":n.value="'";break;case'\\"':n.value='"'}const t="'"===e.token.value[0]&&1===Array.from(n.value).length?Syntax.CharacterLiteral:Syntax.StringLiteral;return e.endNode(n,t)}function builtInType(e){if("<"===e.stream.peek().value){const n=e.token.value;e.eat(["Memory","Table"]),e.eat(["<"]),e.eat(["{"]);const t=e.makeNode({value:n,type:n,params:[expression(e)]},Syntax.Type);return e.eat(["}"]),t}return e.makeNode({value:e.token.value,type:e.token.value},Syntax.Type)}function maybeFunctionDeclaration(e){if(!e.eat(["function"]))return declaration(e);const n=e.startNode(),t=e.expect(null,Syntax.Identifier).value,a=parseArguments(e),r=parseFunctionResult(e);e.expect(["{"]);const i=[];for(;e.token&&"}"!==e.token.value;){const n=statement(e);n&&i.push(n)}return e.expect(["}"]),e.endNode(_extends({},n,{value:t,params:[a,r,...i]}),Syntax.FunctionDeclaration)}function generateErrorString(e,n,t,a,r){let i,o,s;return t.start.line!==t.end.line?(s=t.start.col+1,o=t.start.col,i=t.start.line):(i=t.start.line,o=t.start.col,s=t.end.col),"\n"+(()=>{if(t.start.sourceLine!==t.end.sourceLine)return t.start.sourceLine+"\n"+t.end.sourceLine;return t.end.sourceLine})()+"\n"+new Array(s-o+1).join("^").padStart(s," ")+` ${n}`+"\n"+e+"\n"+`  at ${r} (${a}:${i}:${o})`}function typeParser(e){const n=e.startNode();e.eat(["type"]);const t=e.expect(null,Syntax.Identifier).value;e.expect(["="]);const a=e.token.value;if(e.eat(null,Syntax.Identifier)){e.expect(["<"]);const r=e.makeNode(_extends({},e.token,{type:null}),Syntax.Identifier);e.expect(null,Syntax.Identifier),e.expect([">"]);const i=e.endNode(_extends({},n,{value:t,params:[_extends({},r,{value:a}),r]}),Syntax.GenericType);return i}if(e.eat(["("])){const a=expression(e),r=null!=a?_extends({},a,{value:"FUNCTION_ARGUMENTS",Type:Syntax.FunctionArguments,params:[a]}):_extends({},n,{value:"FUNCTION_ARGUMENTS",Type:Syntax.FunctionArguments,params:[]});e.expect([")"]),e.expect(["=>"]);const i=_extends({},expression(e),{value:"FUNCTION_RESULT",Type:Syntax.FunctionResult});return e.endNode(_extends({},n,{value:t,type:i.type,params:[r,i]}),Syntax.Typedef)}if("{"!==e.token.value){const t=n.range[0],a=e.token.end;throw new SyntaxError(generateErrorString("Invalid type syntax","A function type must be of form (<type>, ...) <type>",{start:t,end:a},"",""))}return e.endNode(_extends({},n,{value:t,params:[expression(e)],type:"i32"}),Syntax.Struct)}function parseExport(e){const n=e.startNode();if(e.eat(["export"]),"type"===e.token.value){const t=typeParser(e);return e.endNode(_extends({},n,{params:[t]}),Syntax.Export)}const t=[maybeFunctionDeclaration(e)];return e.endNode(_extends({},n,{params:t}),Syntax.Export)}function parseImport(e){const n=e.startNode();if(e.eat(["import"]),!e.eat(["{"]))throw e.syntaxError("expected {");const t=expression(e);e.expect(["}"]),e.expect(["from"]);const a=expression(e);return e.endNode(_extends({},n,{params:[t,a]}),Syntax.Import)}function breakParser(e){const n=e.startNode();return e.expect(["break"]),e.endNode(n,Syntax.Break)}function parseIfStatement(e){const n=_extends({},e.startNode(e.token));e.eat(["if"]);const t=[condition(e)],a=statement(e);for(a&&t.push(a),e.eat([";"]);e.eat(["else"]);){const n=e.makeNode(null,Syntax.Else),a=[],r=statement(e);r&&a.push(r),t.push(_extends({},n,{params:a}))}return e.endNode(_extends({},n,{params:t}),Syntax.IfThenElse)}function maybeAssignment(e){const n=e.stream.peek().value;return"["===n||"."===n?memoryStore(e):expression(e)}function tokenStream(e){const n=e.length;let t=0;const a=()=>e[++t];return{pos:t,tokens:e,next:a,peek:()=>e[t+1],last:()=>e[n-1],length:n}}function parse(e){const n=new Stream(e),t=tokenStream(new Tokenizer(n).parse()),a=new Context({stream:t,token:t.tokens[0],lines:n.lines,filename:"unknown.walt"}),r=a.makeNode({value:"ROOT_NODE"},Syntax.Program);if(!a.stream||!a.stream.length)return r;for(;a.stream.peek();){const e=statement(a);e&&r.params.push(e)}return r}function mapNode(e){const n=t=>{if(null==t)return t;const a=(()=>{if("*"in e&&"function"==typeof e["*"])return e["*"];if(t.Type in e&&"function"==typeof e[t.Type])return e[t.Type];return e=>e})();if(2===a.length)return a(t,n);const r=a(t);const i=r.params.map(n);return _extends({},r,{params:i})};return n}function walker(e){const n=t=>{if(null==t)return t;const{params:a}=t;const r=(()=>{if("*"in e&&"function"==typeof e["*"])return e["*"];if(t.Type in e&&"function"==typeof e[t.Type])return e[t.Type];return()=>t})();if(2===r.length)return r(t,n),t;r(t);a.forEach(n);return t};return n}function mapCharacterLiteral(e){const n=e.value.codePointAt(0);return _extends({},e,{Type:Syntax.Constant,type:"i32",value:String(n)})}function mapUnary(e,n){const[t,a]=e.params.map(n);switch(e.value){case"!":const r=["i64","f64"].includes(t.type)?"63":"31";return n(expressionFragment(`(((${String(t)} >> ${r}) | ((~${String(t)} + 1) >> ${r})) + 1)`));case"~":const i=["i64","f64"].includes(n(t).type)?"0xffffffffffff":"0xffffff";return n(expressionFragment(`(${String(t)} ^ ${i})`));default:return _extends({},e,{type:a.type,params:[_extends({},t,{type:a.type}),a],Type:Syntax.BinaryExpression})}}function imports(){return parse(`\n    import {\n      '${CLOSURE_MALLOC}': ClosureGeti32,\n      '${CLOSURE_FREE}': ClosureFree,\n      '${CLOSURE_GET}-i32': ClosureGeti32,\n      '${CLOSURE_GET}-f32': ClosureGetf32,\n      '${CLOSURE_GET}-i64': ClosureGeti64,\n      '${CLOSURE_GET}-f64': ClosureGetf64,\n      '${CLOSURE_SET}-i32': ClosureSeti32,\n      '${CLOSURE_SET}-f32': ClosureSetf32,\n      '${CLOSURE_SET}-i64': ClosureSeti64,\n      '${CLOSURE_SET}-f64': ClosureSetf64\n    } from 'walt-plugin-closure';\n    type ClosureFree = (i32) => void;\n    type ClosureGeti32 = (i32) => i32;\n    type ClosureGetf32 = (i32) => f32;\n    type ClosureGeti64 = (i32) => i64;\n    type ClosureGetf64 = (i32) => f64;\n    type ClosureSeti32 = (i32, i32) => void;\n    type ClosureSetf32 = (i32, f32) => void;\n    type ClosureSeti64 = (i32, i64) => void;\n    type ClosureSetf64 = (i32, f64) => void;\n  `).params}function hasNode(e,n){const t=n=>n&&n.Type===e,a=e=>{if(null==e)return!1;return t(e)||e.params.some(a)};return a(n)}function semantics(e){const n={},t={},a={},r={},i={},o=[],s=[],u={};hasNode(Syntax.Closure,e)&&(e=_extends({},e,{params:[...imports(),...e.params]}));const c=mapNode({[Syntax.Export]:(e,n)=>{const[t]=e.params;if(null!=t&&[Syntax.Typedef,Syntax.Struct].includes(t.Type))return n(_extends({},t,{meta:_extends({},t.meta,{EXPORTED:!0})}));return e},[Syntax.Typedef]:(e,n)=>{let t=0;const r=[];walker({Assignment(e){const n=e.params[1];r.push(n)},Type(){t+=1}})(e);const i=_extends({},e,{meta:_extends({},e.meta,{FUNCTION_METADATA:{argumentsCount:t},DEFAULT_ARGUMENTS:r})});a[e.value]=i;return i},[Syntax.GenericType]:mapGeneric({types:a})})(e),p=mapNode({[Syntax.Typedef]:(e,n)=>e,[Syntax.Import]:mapImport({functions:n,types:a,globals:t}),[Syntax.Declaration]:parseGlobalDeclaration(!1,{globals:t,types:a}),[Syntax.ImmutableDeclaration]:parseGlobalDeclaration(!0,{globals:t,types:a}),[Syntax.CharacterLiteral]:mapCharacterLiteral,[Syntax.Struct]:mapStruct({userTypes:r}),[Syntax.FunctionDeclaration]:mapFunctionNode$1({hoist:o,hoistImports:s,types:a,globals:t,functions:n,userTypes:r,table:i,statics:u})})(c);return _extends({},p,{meta:_extends({},p.meta,{[AST_METADATA]:{functions:n,globals:t,types:a,userTypes:r,statics:u}}),params:[...s,...p.params,...o]})}function validate(e,{filename:n}){const t=e.meta[AST_METADATA];if(null==t)throw new Error("Missing AST metadata!");const{types:a,functions:r,userTypes:i}=t,o=[];walker({[Syntax.Pair]:e=>{const[t,a]=e.range;o.push(generateErrorString(`Unexpected expression ${e.Type}`,"",{start:t,end:a},n,GLOBAL_LABEL))},[Syntax.Export]:e=>{const t=e.params[0];const[a,r]=t.range;const i=t.meta[GLOBAL_INDEX];null==i||t.params.length||o.push(generateErrorString("Global exports must have a value","",{start:a,end:r},n,GLOBAL_LABEL))},[Syntax.Import]:(e,t)=>{walker({[Syntax.BinaryExpression]:(e,t)=>{const[a,r]=e.range;o.push(generateErrorString("Using an 'as' import without a type.","A type for original import "+e.params[0].value+" is not defined nor could it be inferred.",{start:a,end:r},n,GLOBAL_LABEL))},[Syntax.Identifier]:(e,t)=>{const[a,r]=e.range;o.push(generateErrorString("Infered type not supplied.","Looks like you'd like to infer a type, but it was never provided by a linker. Non-concrete types cannot be compiled.",{start:a,end:r},n,GLOBAL_LABEL))},[Syntax.Pair]:(e,t)=>{const r=e.params[1];if(!isBuiltinType(r.value)&&null==a[r.value]){const[e,t]=r.range;o.push(generateErrorString(`Undefined Type ${r.value}`,`Invalid Import. ${r.value} type does not exist`,{start:e,end:t},n,GLOBAL_LABEL))}}})(e)},[Syntax.Struct]:(e,n)=>{},[Syntax.ImmutableDeclaration]:(e,n)=>{},[Syntax.Declaration]:(e,t)=>{const[r,s]=e.range;const[u]=e.params;if(null!=e.meta[TYPE_CONST]){const e=[Syntax.Constant,Syntax.StringLiteral];null==u||e.includes(u.Type)||o.push(generateErrorString("Global Constants must be initialized with a Number literal.","WebAssembly does not allow for non number literal constant initializers.",{start:r,end:s},n,GLOBAL_LABEL)),null==u&&o.push(generateErrorString("Constant declaration without an initializer.","Global constants must be initialized with a Number literal.",{start:r,end:s},n,GLOBAL_LABEL))}isBuiltinType(e.type)||a[e.type]||i[e.type]||o.push(generateErrorString("Unknown type used in a declaration, "+`"${String(e.type)}"`,"Variables must be assigned with a known type.",{start:r,end:s},n,GLOBAL_LABEL))},[Syntax.FunctionDeclaration]:(e,t)=>{const s=`${e.value}()`;walker({[Syntax.Declaration]:(e,t)=>{const[r,u]=e.range;const[c]=e.params;null!=c&&null!=statements[c.Type]&&o.push(generateErrorString(`Unexpected statement ${c.Type}`,"Attempting to assign a statement to a variable. Did you miss a semicolon(;)?",{start:r,end:u},n,s));null!=e.meta[TYPE_CONST]&&null==c&&o.push(generateErrorString("Constant declaration without an initializer.","Local Constants must be initialized with an expression.",{start:r,end:u},n,s));isBuiltinType(e.type)||a[e.type]||i[e.type]||o.push(generateErrorString("Unknown type used in a declartion, "+`"${String(e.type)}"`,"Variables must be assigned with a known type.",{start:r,end:u},n,s))},[Syntax.Assignment]:e=>{const[t]=e.params;const[a,r]=e.range;const i=e.params.find(e=>null!=statements[e.Type]);null!=i&&o.push(generateErrorString("Unexpected statement in assignment","Statments cannot be used in assignment expressions. Did you miss a semicolon?",{start:i.range[0],end:i.range[1]},n,s));const u=t.meta[TYPE_CONST];null!=u&&o.push(generateErrorString(`Cannot reassign a const variable ${t.value}`,"const variables cannot be reassigned, use let instead.",{start:a,end:r},n,s))},[Syntax.ArraySubscript]:(e,t)=>{const[a,r]=e.params;const[i,u]=e.range;if(null==r.value){const e=r.meta[ALIAS];o.push(generateErrorString("Cannot generate memory offset",`Undefined key ${null!=e?e:r.value} for type ${String(a.type)}`,{start:i,end:u},n,s))}},[Syntax.ReturnStatement]:(t,a)=>{t.params.map(a);if(null==e.type)return;const[r]=t.params;const[u]=t.range;const c=null!=r?r.range[1]:t.range[1];const p=(()=>{if(null==r)return null;if(null!=i[r.type])return"i32";return r.type})();typeWeight(p)!==typeWeight(e.type)&&o.push(generateErrorString("Missing return value","Inconsistent return value. Expected "+e.type+" received "+String(p),{start:u,end:c},n,s))},[Syntax.FunctionCall]:(e,t)=>{if(null==r[e.value]){const[t,a]=e.range;o.push(generateErrorString("Undefined function reference",`${e.value} is not defined.`,{start:t,end:a},n,s))}},[Syntax.IndirectFunctionCall]:(e,t)=>{const r=e.params[e.params.length-1];const i=a[r.type];if(!isBuiltinType(r.type)&&null==i){const[t,a]=e.range;o.push(generateErrorString("Cannot make an indirect call without a valid function type",`${r.value} has type ${String(r.type)} which is not defined. Inidrect calls must have pre-defined types.`,{start:t,end:a},n,s))}}})(e)}})(e);const s=o.length;if(s>0){const e=o.reduce((e,n)=>e+"\n"+`${n}\n`,`Cannot generate WebAssembly for ${n}. ${s} problems.\n`);throw new Error(e)}}function generateNoop(){return[]}function generateExport(e){const n=e.meta[FUNCTION_INDEX],t=e.meta[GLOBAL_INDEX];if(null!=t){const n=externaKindMap[String(e.type)]||EXTERN_GLOBAL,a=[EXTERN_MEMORY,EXTERN_TABLE].includes(n)?0:t;return{index:a,kind:n,field:e.value}}return{index:n,kind:EXTERN_FUNCTION,field:e.value}}function generateMemory$2(e){const n={max:0,initial:0,type:""};return walker({[Syntax.Pair]:({params:e})=>{const[{value:t},{value:a}]=e;"initial"===t?n.initial=parseInt(a):"element"===t?n.type=a:"max"===t&&(n.max=parseInt(a))}})(e),n}function generateImportFromNode(e){const[n,t]=e.params,{value:a}=t,r=[];return walker({[Syntax.Pair]:(e,n)=>{const[t,i]=e.params;const o=getFieldName(t);const{value:s}=i;const u=getKindConstant(s);const c=(()=>{const e=i.meta[TYPE_INDEX];if(e)return e;return null})();const p="Memory"===s?parseBounds(i):{};r.push(_extends({module:a,field:o,global:u===EXTERN_GLOBAL,kind:u,type:stringToType[s],typeIndex:c},p))}})(n),r}function generateType(e){const n=e.value;invariant_1("string"==typeof n,`Generator: A type must have a valid string identifier, node: ${JSON.stringify(e)}`);const[t,a]=e.params,r=[];return walker({[Syntax.Type]:(e,n)=>{r.push(getType$1(e.value))},[Syntax.Identifier]:(e,n)=>{r.push(getType$1(e.value))}})(t),{id:n,params:r,result:a.type&&"void"!==a.type?getType$1(a.type):null}}function*stringDecoder(e,n){let t=0,a=0,r=0,i=n;for(;;){const n=e.getUint8(i,!0);if(t|=(127&n)<<r,i+=1,0==(128&n))break;r+=7}let o=0;for(;a<t;){for(o=0,r=0;;){const n=e.getUint8(i,!0);if(o|=(127&n)<<r,i+=1,0==(128&n))break;r+=7}a+=1,yield o}}function stringEncoder(e){const n=new OutputStream,t=new OutputStream;t.push("varuint32",e.length,e);let a=0;for(a=0;a<e.length;a++)t.push("varuint32",e.codePointAt(a),e[a]);return n.write(t),n}function generateData(e,n){let t=n;const a={},r=Object.keys(e).reduce((e,n)=>{const r=stringEncoder(n);e.push({offset:Number(t),data:r});a[n]=t;t+=r.size;return e},[]),i=new OutputStream;return i.push(index_12,t,String(t)),{data:[{offset:0,data:i},...r],map:a}}function generator(e,n){const t={Version:n.version,Types:[],Start:[],Element:[],Code:[],Exports:[],Imports:[],Globals:[],Functions:[],Memory:[],Table:[],Artifacts:[],Data:[],Name:{module:n.filename,functions:[],locals:[]}};let{statics:a}=e.meta[AST_METADATA];null!=n.linker&&(a=_extends({},n.linker.statics,a));const{map:r,data:i}=generateData(a,DATA_SECTION_HEADER_SIZE);Object.keys(a).length>0&&(t.Data=i);const o=e=>{const n=generateImplicitFunctionType(e);return t.Types.findIndex(e=>{const t=e.params.length===n.params.length&&e.params.reduce((e,t,a)=>e&&t===n.params[a],!0);const a=e.result===n.result;return t&&a})},s=e=>t.Element.findIndex(n=>n.functionIndex===e),u={},c=mapNode({[Syntax.Typedef]:(e,n)=>{let a=t.Types.findIndex(({id:n})=>n===e.value);let r=t.Types[a];null==r&&(a=t.Types.length,t.Types.push(generateType(e)));r=_extends({},e,{meta:_extends({},e.meta,{[TYPE_INDEX]:a})});u[e.value]={typeIndex:a,typeNode:r};return r}})(mapNode({[Syntax.Import]:(e,n)=>e,[Syntax.StringLiteral]:(e,n)=>{if(0===Object.keys(a).length)return e;const{value:t}=e;return _extends({},e,{value:String(r[t]),Type:Syntax.Constant})}})(e));return walker({[Syntax.Typedef]:(e,n)=>e,[Syntax.Export]:e=>{const[n]=e.params;t.Exports.push(generateExport(n))},[Syntax.ImmutableDeclaration]:e=>{const n=e.meta[GLOBAL_INDEX];if(null!=n)switch(e.type){case"Memory":t.Memory.push(generateMemory(e));break;case"Table":t.Table.push(generateMemory$2(e))}},[Syntax.Declaration]:e=>{const n=e.meta[GLOBAL_INDEX];null!=n&&t.Globals.push(generateInit(e))},[Syntax.Import]:e=>{t.Imports.push(...generateImportFromNode(e))},[Syntax.FunctionDeclaration]:e=>{const a=(()=>{const n=o(e);if(-1===n)return t.Types.push(generateImplicitFunctionType(e)),t.Types.length-1;return n})();const r=mapNode({FunctionPointer(e){const n=e.meta[FUNCTION_INDEX];let a=s(n);return a<0&&(a=t.Element.length,t.Element.push(generateElement(n))),e}})(e);const i=e.meta[FUNCTION_INDEX];invariant_1(null!=i,"Function index must be set");t.Functions[i]=a;t.Code[i]=generateCode(r);"start"===r.value&&t.Start.push(i);if(n.encodeNames){t.Name.functions.push({index:i,name:e.value});const n=e.meta[FUNCTION_METADATA];null!=n&&Object.keys(n.locals).length&&(t.Name.locals[i]={index:i,locals:Object.entries(n.locals).map(([e,n])=>({name:e,index:Number(n.meta["local/index"])}))})}}})(c),t.Code=t.Code.filter(Boolean),t}function write(e){return(new OutputStream).push(index_12,MAGIC,"\\0asm").push(index_12,e,`version ${e}`)}function emitString(e,n,t){e.push(varuint32,n.length,t);for(let t=0;t<n.length;t++)e.push(index_9,n.charCodeAt(t),n[t]);return e}function emitTables(e){const n=new OutputStream;return e.length&&n.push(varuint32,e[0],"start function"),n}function emitTables$1(e){const n=new OutputStream;return n.push(varuint32,e.length,"count"),e.forEach(e=>emitEntry$1(n,e)),n}function emit$9(e){const n=new OutputStream;n.push(varuint32,e.length,"entries");for(let t=0,a=e.length;t<a;t++){const a=e[t];emitDataSegment(n,a)}return n}function emit(e,n){const t=(new OutputStream).write(write(e.Version)).write(section.type(e)).write(section.imports(e)).write(section.function(e)).write(section.table(e)).write(section.memory(e)).write(section.globals(e)).write(section.exports(e)).write(section.start(e)).write(section.element(e)).write(section.code(e)).write(section.data(e));return n.encodeNames?t.write(section.name(e)):t}function closurePlugin$$1(){return compileWalt(source,{version:1,encodeNames:!1,filename:"walt-closure-plugin",lines:source.split("\n")})}function compileWalt(e,n){return getIR(e,n).buffer()}const Program="Program",Keyword="Keyword",Export="Export",Import="Import",Statement="Statement",IfThenElse="IfThenElse",Select="Select",Else="Else",UnaryExpression="UnaryExpression",BinaryExpression="BinaryExpression",TernaryExpression="TernaryExpression",NumberLiteral="NumberLiteral",StringLiteral="StringLiteral",CharacterLiteral="CharacterLiteral",Punctuator="Punctuator",Identifier="Identifier",ArraySubscript="ArraySubscript",Constant="Constant",Type="Type",GenericType="GenericType",UserType="UserType",FunctionType="FunctionType",Declaration="Declaration",ImmutableDeclaration="ImmutableDeclaration",FunctionDeclaration="FunctionDeclaration",ArrayDeclaration="ArrayDeclaration",IndirectFunctionCall="IndirectFunctionCall",FunctionCall="FunctionCall",Loop="Loop",MemoryAssignment="MemoryAssignment",Assignment="Assignment",Param="Param",Typedef="Typedef",Struct="Struct",ReturnStatement="ReturnStatement",Sequence="Sequence",ObjectLiteral="ObjectLiteral",Pair="Pair",TypeCast="TypeCast",Break="Break",Comment="Comment",Sizeof="Sizeof",Spread="Spread",Closure="Closure",Noop="Noop",ClosureType="ClosureType",Block="Block",ObjectField="ObjectField",FunctionIndex="FunctionIndex",FunctionIdentifier="FunctionIdentifier",FunctionPointer="FunctionPointer",FunctionArguments="FunctionArguments",FunctionResult="FunctionResult",FunctionLocals="FunctionLocals",NativeMethod="NativeMethod",i32="i32",f32="f32",i64="i64",f64="f64",Memory="Memory",Table="Table",bool="bool",builtinTypes={i32:i32,f32:f32,i64:i64,f64:f64,Memory:Memory,Table:Table,bool:bool},statements={Program:Program,Export:Export,Import:Import,IfThenElse:IfThenElse,Else:Else,Declaration:Declaration,ImmutableDeclaration:ImmutableDeclaration,FunctionDeclaration:FunctionDeclaration,ArrayDeclaration:ArrayDeclaration,Loop:Loop,MemoryAssignment:MemoryAssignment,Assignment:Assignment,Typedef:Typedef,Struct:Struct,ReturnStatement:ReturnStatement,Sequence:Sequence,ObjectLiteral:ObjectLiteral,Pair:Pair,Break:Break,Comment:Comment,Sizeof:Sizeof,Spread:Spread,Noop:Noop,Block:Block};var Syntax={Program:Program,Keyword:Keyword,Export:Export,Import:Import,Statement:Statement,IfThenElse:IfThenElse,Select:Select,Else:Else,UnaryExpression:UnaryExpression,BinaryExpression:BinaryExpression,TernaryExpression:TernaryExpression,NumberLiteral:NumberLiteral,StringLiteral:StringLiteral,CharacterLiteral:CharacterLiteral,Punctuator:Punctuator,Identifier:Identifier,ArraySubscript:ArraySubscript,Constant:Constant,Type:Type,GenericType:GenericType,UserType:UserType,FunctionType:FunctionType,Declaration:Declaration,ImmutableDeclaration:ImmutableDeclaration,FunctionDeclaration:FunctionDeclaration,ArrayDeclaration:ArrayDeclaration,IndirectFunctionCall:IndirectFunctionCall,FunctionCall:FunctionCall,Loop:Loop,MemoryAssignment:MemoryAssignment,Assignment:Assignment,Param:Param,Typedef:Typedef,Struct:Struct,ReturnStatement:ReturnStatement,Sequence:Sequence,ObjectLiteral:ObjectLiteral,Pair:Pair,TypeCast:TypeCast,Break:Break,Comment:Comment,Sizeof:Sizeof,Spread:Spread,Closure:Closure,Noop:Noop,ClosureType:ClosureType,Block:Block,ObjectField:ObjectField,FunctionIndex:FunctionIndex,FunctionIdentifier:FunctionIdentifier,FunctionPointer:FunctionPointer,FunctionArguments:FunctionArguments,FunctionResult:FunctionResult,FunctionLocals:FunctionLocals,NativeMethod:NativeMethod},_extends=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},objectWithoutProperties=function(e,n){var t={};for(var a in e)n.indexOf(a)>=0||Object.prototype.hasOwnProperty.call(e,a)&&(t[a]=e[a]);return t};const makeResult=e=>_extends({range:[]},e,{meta:{},params:[],Type:Syntax.FunctionResult,value:"FUNCTION_RESULT"}),makeArgs=e=>_extends({range:[]},e,{params:(()=>{if(null==e)return[];return e.Type===Syntax.Sequence?e.params:[e]})(),type:null,meta:{},value:"FUNCTION_ARGUMENTS",Type:Syntax.FunctionArguments}),subscriptFromNode=(e,n)=>{const[t]=n.params;return e.endNode(_extends({},n,{value:t.value}),Syntax.ArraySubscript)},ternary=(e,n,t)=>{const a=e.startNode(t[0]);a.params=t;a.value=n.value;a.type=t[t.length-1].type;return e.endNode(a,Syntax.TernaryExpression)},flattenSequence=e=>e.reduce((e,n)=>{n.Type===Syntax.Sequence?e.push.apply(e,flattenSequence(n.params)):e.push(n);return e},[]),sequence=(e,n,t)=>{const a=e.startNode(t[0]);a.value=n.value;a.params=flattenSequence(t);return e.endNode(a,Syntax.Sequence)},operator=(e,n,t)=>{const a=n.pop();switch(a.value){case"=>":return parselambda(e,a,t);case"?":return ternary(e,a,t.splice(-2));case",":return sequence(e,a,t.splice(-2));case"{":return objectLiteral(e,a,t.splice(-1));case"--":case"...":case"sizeof":case"~":case"!":return unary(e,a,t.splice(-1));default:return binary(e,a,t.splice(-2))}},PRECEDENCE_MEMBER_ACCESS=19,PRECEDENCE_NOT=18,PRECEDENCE_ASSIGNMENT=3,PRECEDENCE_DIVIDE=1,PRECEDENCE_MULTIPLY=1,PRECEDENCE_ADDITION=0,PRECEDENCE_SUBTRACTION=0,PRECEDENCE_SHIFT=-1,PRECEDENCE_COMMA=-2,PRECEDENCE_BITWISE_XOR=-2,PRECEDENCE_SPREAD=-1,PRECEDENCE_BITWISE_AND=-1,PRECEDENCE_BITWISE_OR=-3,PRECEDENCE_LOGICAL_AND=-4,PRECEDENCE_LOGICAL_OR=-5,PRECEDENCE_KEY_VALUE_PAIR=-1,PRECEDENCE_PARAMS=-99,precedence={"=>":PRECEDENCE_PARAMS,"(":PRECEDENCE_PARAMS,",":PRECEDENCE_COMMA,as:PRECEDENCE_COMMA+1,">>":PRECEDENCE_SHIFT,">>>":PRECEDENCE_SHIFT,"<<":PRECEDENCE_SHIFT,"+":PRECEDENCE_ADDITION,"-":PRECEDENCE_SUBTRACTION,"*":PRECEDENCE_MULTIPLY,"/":PRECEDENCE_DIVIDE,"==":2,"!=":2,".":PRECEDENCE_MEMBER_ACCESS,"=":-1,"-=":PRECEDENCE_ASSIGNMENT,"+=":PRECEDENCE_ASSIGNMENT,"?":4,">":5,"<":5,":":PRECEDENCE_KEY_VALUE_PAIR,"^":PRECEDENCE_BITWISE_XOR,"&":PRECEDENCE_BITWISE_AND,"|":PRECEDENCE_BITWISE_OR,"&&":PRECEDENCE_LOGICAL_AND,"||":PRECEDENCE_LOGICAL_OR,"...":PRECEDENCE_SPREAD,"~":PRECEDENCE_NOT,"!":PRECEDENCE_NOT},getPrecedence=e=>precedence[e.value],getAssociativty=e=>{switch(e.value){case"=":case"-=":case"+=":case"--":case"++":case"?":return"right";case"+":case"-":case"/":case"*":case":":default:return"left"}},maybeIdentifier=e=>{const n=e.startNode();e.eat(null,Syntax.Identifier);if("false"===n.value||"true"===n.value)return n.type="bool",n.value="true"===n.value?"1":"0",e.endNode(n,Syntax.Constant);if(e.eat(["("])){const t=[expression(e)],a=e.endNode(_extends({},n,{params:t.filter(Boolean)}),Syntax.FunctionCall);return e.expect([")"]),a}return e.endNode(n,Syntax.Identifier)},last=e=>e[e.length-1],isPunctuatorAndNotBracket=e=>e&&e.type===Syntax.Punctuator&&"]"!==e.value&&")"!==e.value,predicate=(e,n)=>";"!==e.value&&n>0,validKeywordsInExpressions=["as"],expression=(e,n=predicate)=>{const t=[];const a=[];let r=1;let i=null;const o=()=>a.push(operator(e,t,a));const s=e=>{let n=last(t);for(;n&&n.value!==e;)o(),n=last(t)};const u=e=>{let n=last(t);for(;n&&n.Type!==Syntax.Sequence&&getPrecedence(n)>=e&&"left"===getAssociativty(n);)o(),n=last(t)};const c=()=>{switch(e.token.value){case"=>":return u(getPrecedence(e.token)),t.push(e.token),e.next(),"{"===e.token.value&&a.push(blockParser(e)),!1;case"(":case"[":r++,t.push(e.token);break;case"]":r--,s("["),o();break;case")":if(--r<1)return!1;s("("),t.pop();break;case"{":r++,t.push(e.token);break;case"}":if(--r<1)return!1;s("{"),o();break;default:{const n=(e=>{if("-"===e.value&&null==i||"-"===e.value&&isPunctuatorAndNotBracket(i))return _extends({},e,{value:"--"});return e})(e.token);u(getPrecedence(n)),t.push(n)}}};const p=()=>{switch(e.token.type){case Syntax.Constant:a.push(parseConstant(e));break;case Syntax.Identifier:return i=e.token,a.push(maybeIdentifier(e)),!1;case Syntax.StringLiteral:a.push(stringLiteral(e));break;case Syntax.Type:a.push(builtInType(e));break;case Syntax.Keyword:case Syntax.Punctuator:if(e.token.type===Syntax.Keyword&&!validKeywordsInExpressions.includes(e.token.value))break;const n=c();if(null!=n)return n}return!0};for(;e.token&&n(e.token,r);)p()&&(i=e.token,e.next());for(;t.length;)o();return a.pop()},declaration=e=>{const n=e.startNode();let t=Syntax.Declaration;"const"===e.token.value&&(t=Syntax.ImmutableDeclaration);e.eat(["const","let","function"]);n.value=e.expect(null,Syntax.Identifier).value;e.expect([":"]);let a=e.token.value;e.eat(null,Syntax.Type)||e.expect(null,Syntax.Identifier);const r=[];e.eat(["<"])?(e.eat(["{"]),r.push(expression(e)),e.eat(["}"]),e.eat([">"])):e.eat(["="])&&r.push(expression(e));return e.endNode(_extends({},n,{params:r,type:a}),t)},parseArguments=e=>{e.expect(["("]);const n=e.makeNode({params:[expression(e)],value:"FUNCTION_ARGUMENTS"},Syntax.FunctionArguments);e.expect([")"]);return n},parseFunctionResult=e=>{const n=e.startNode();if(e.eat([":"]))return e.endNode(_extends({},n,{value:e.token.value,type:(()=>{const n=e.token.value;if(e.eat(null,Syntax.Type))return"void"===n?null:n;e.expect(null,Syntax.Identifier);return"i32"})()}),Syntax.FunctionResult);return e.endNode(_extends({},n,{value:"FUNCTION_RESULT"}),Syntax.FunctionResult)},paramList=e=>{e.expect(["("]);const n=[];let t=null;for(;e.token.value&&")"!==e.token.value;)(t=expression(e))&&(n.push(t),e.eat([";"]));e.expect([")"]);return n},forLoop=e=>{const n=e.startNode();e.eat(["for"]);const[t,a,r]=paramList(e);const i=[];e.expect(["{"]);let o=null;for(;e.token&&"}"!==e.token.value;)(o=statement(e))&&i.push(o);e.expect(["}"]);return e.endNode(_extends({},n,{params:[t,a,...i,r]}),Syntax.Loop)},whileLoop=e=>{const n=e.startNode();e.eat(["while"]);e.expect(["("]);const t=e.makeNode({},Syntax.Noop);const a=expression(e);const r=[];e.expect([")"]);e.expect(["{"]);let i=null;for(;e.token&&"}"!==e.token.value;)(i=statement(e))&&r.push(i);e.expect(["}"]);return e.endNode(_extends({},n,{params:[t,a,...r]}),Syntax.Loop)};class Context{constructor({stream:e,token:n,lines:t}){this.token=n,this.stream=e,this.lines=t}syntaxError(e,n){return new SyntaxError(generateErrorString(e,n||"",this.token,this.filename||"unknown","unknown"))}unexpectedValue(e){return this.syntaxError(`Expected: ${String(e)}`,"Unexpected value")}unexpected(e){return this.syntaxError(`Expected: ${String(e)}`,`Unexpected token ${this.token.type}`)}unknown({value:e}){return this.syntaxError("Unknown token",e)}unsupported(){return this.syntaxError("Language feature not supported",this.token.value)}expect(e,n){const t=this.token;if(!this.eat(e,n))throw e?this.unexpectedValue(e):this.unexpected(n);return t}next(){this.token=this.stream.next()}eat(e,n){return null!=this.token&&(e?!!e.includes(this.token.value)&&(this.next(),!0):this.token.type===n&&(this.next(),!0))}startNode(e=this.token||{}){return{Type:"",value:e.value,range:[e.start],meta:{},params:[],type:null}}endNode(e,n){const t=this.token||this.stream.last()||{},a=e.range.concat(t.start),r=()=>{const e=a[0];const n=a[a.length-1];return e.sourceLine.slice(e.col,n.col)},{toString:i}=e,o=objectWithoutProperties(e,["toString"]);return _extends({toString:r},o,{Type:n,range:a})}makeNode(e,n){return this.endNode(_extends({},this.startNode(),e),n)}}const returnStatement=e=>{const n=e.startNode();e.expect(["return"]);const t=expression(e);n.params.push(t);return e.endNode(n,Syntax.ReturnStatement)},condition=e=>{e.expect(["("]);const n=expression(e);e.expect([")"]);return n},keyword=e=>{switch(e.token.value){case"let":case"const":return declaration(e);case"function":return maybeFunctionDeclaration(e);case"export":return parseExport(e);case"import":return parseImport(e);case"type":return typeParser(e);case"if":return parseIfStatement(e);case"for":return forLoop(e);case"while":return whileLoop(e);case"return":return returnStatement(e);case"break":return breakParser(e);default:throw e.unsupported()}};var NODE_ENV="production",invariant=function(e,n,t,a,r,i,o,s){if("production"!==NODE_ENV&&void 0===n)throw new Error("invariant requires an error message argument");if(!e){var u;if(void 0===n)u=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var c=[t,a,r,i,o,s],p=0;(u=new Error(n.replace(/%s/g,function(){return c[p++]}))).name="Invariant Violation"}throw u.framesToPop=1,u}},invariant_1=invariant;const memoryStore=e=>{const n=expression(e);invariant_1(n.params.length>0,"Memory Store expression could not be parsed");const t=n.params[0].type;return e.endNode(_extends({},n,{type:t}),Syntax.MemoryAssignment)},statement=e=>{switch(e.token.type){case Syntax.Keyword:return keyword(e);case Syntax.Identifier:return maybeAssignment(e);case Syntax.Punctuator:default:return e.eat([";"])?null:"{"===e.token.value?blockParser(e):expression(e)}},eol=e=>"\n"===e;class Stream{constructor(e){this.pos=this.line=this.col=0,this.input=e,this.lines=e.split("\n"),this.newLine()}peek(){return this.input.charAt(this.pos)}next(){const e=this.input.charAt(this.pos++);return this.eol(e)?this.newLine():this.col++,e}newLine(){this.line++,this.col=0}eol(e){return"\n"===e}eof(e){return""===e}static whitespace(e){return"\n"===e||" "===e||"\t"===e||"\v"===e||"\r"===e||"\f"===e}}const fsearch=e=>{const n=n=>{if(e&&e.children[n])return fsearch(e.children[n]);return null};n.leaf=e.leaf;return n};class Trie{constructor(e){this.root={char:"",children:{},leaf:!1},e.map(e=>this.add(e)),this.fsearch=fsearch(this.root)}add(e){let n=this.root,t=e.slice(0,1);for(e=e.slice(1);void 0!==n.children[t]&&t.length>0;)n=n.children[t],t=e.slice(0,1),e=e.slice(1);for(;t.length>0;){const a={char:t,children:{},leaf:!1};n.children[t]=a,n=a,t=e.slice(0,1),e=e.slice(1)}n.leaf=!0}}var trie$1=Trie;const wrap=(e,n,t)=>{const a=a=>{const r=e(a);return"function"==typeof r?wrap(r,n,t):r};a.type=n;a.supported=t;a.strict=!!t;a.leaf=e.leaf;return a};var token=wrap;const supported=["+","++","-","--",">>",">>>","<<","=","==","+=","-=","=>","<=",">=","!=","%","/","^","&","~","|","!","**",":","(",")",".","{","}",",","[","]",";",">","<","?","||","&&","{","}","..."],trie=new trie$1(supported);var punctuator=token(trie.fsearch,Syntax.Punctuator,supported);const{isNaN:isNaN,parseInt:parseInt$1}=Number,isNumber=e=>!isNaN(parseInt$1(e)),isDot=e=>"."===e,number=e=>isNumber(e)?number:null,numberOrDot=e=>{if(isDot(e))return number;if(isNumber(e))return numberOrDot;return null},hex=e=>{if(/[0-9a-fA-F]/.test(e))return hex;return null},maybeExponent=e=>{switch(e){case"e":case"E":return number;default:return numberOrDot(e)}},maybeModifier=e=>{switch(e){case"b":case"B":case"o":return number;case"x":case"X":return hex;default:return numberOrDot(e)}},root=e=>{if("-"===e)return root;if(isDot(e))return number;if("0"===e)return maybeModifier;if(isNumber(e))return maybeExponent;return null};var constant=token(root,Syntax.Constant);const quoteOK=e=>()=>e,nextFails=()=>null,endsInSingleQuote=e=>{if(/\\/.test(e))return quoteOK(endsInSingleQuote);if("'"===e)return nextFails;return endsInSingleQuote},endsInDoubleQuote=e=>{if(/\\/.test(e))return quoteOK(endsInDoubleQuote);if('"'===e||"`"===e)return nextFails;return endsInDoubleQuote},maybeQuote=e=>{if("'"===e)return endsInSingleQuote;if('"'===e||"`"===e)return endsInDoubleQuote;return null},stringParser=token(maybeQuote,Syntax.StringLiteral),isValidIdentifier=e=>!stringParser(e)&&!punctuator(e)&&!eol(e)&&" "!==e,supportAny=e=>isValidIdentifier(e)?supportAny:null,parse$1=e=>isValidIdentifier(e)&&!constant(e)?supportAny:null,tokenParser=token(parse$1,Syntax.Identifier),supported$1=["break","if","else","import","as","from","export","return","switch","case","default","const","let","for","continue","do","while","function","global","module","type","lambda","catch","extends","super","this","debugger","var","class","try","finally","typeof"],trie$2=new trie$1(supported$1),root$1=trie$2.fsearch;var keyword$2=token(root$1,Syntax.Keyword,supported$1);const SLASH="/",ASTERIX="*",SINGLE_LINE=`${SLASH}${SLASH}`,MULTI_LINE_START=`${SLASH}${ASTERIX}`,MULTI_LINE_END=`${ASTERIX}${SLASH}`,COMMENT_IDENTIFIERS=[SINGLE_LINE,MULTI_LINE_START,MULTI_LINE_END],parser=e=>{let n=!1;let t=!1;let a;const r=e=>{eol(e)&&(t=!1);switch(`${a}${e}`){case MULTI_LINE_END:return n=!1,r;case MULTI_LINE_START:return n=!0,r;case SINGLE_LINE:return t=!0,r;default:if(n||t)return a=e,r}};const i=e=>{const t=a;a=e;if(e===SLASH||n||COMMENT_IDENTIFIERS.indexOf(`${t}${e}`)>-1)return r;return null};return i(e)};var comments=token(parser,Syntax.Comment);const supported$2=["i32","i64","f32","f64","i32[]","i64[]","f32[]","f64[]","u8[]","bool","Function","Memory","Table","void"],trie$3=new trie$1(supported$2);var type=token(trie$3.fsearch,Syntax.Type,supported$2);class Tokenizer{constructor(e,n=[punctuator,constant,tokenParser,keyword$2,stringParser,type,comments]){this.stream=e,this.tokens=[],this.pos=0,this.parsers=n}next(){let e="";this.seekNonWhitespace();let n,t="",a=this.parsers,r=this.match(t,a),i={sourceLine:this.stream.lines[this.stream.line-1],line:this.stream.line,col:this.stream.col};do{t=this.stream.peek(),a=this.match(t,a),e+=t,this.stream.next(),n=this.stream.peek(),r=this.match(n,a)}while(!this.stream.eof(n)&&r.length>0);if(this.stream.eof(e))return null;const o=this.token(e,a);return o.start=i,o.end={sourceLine:this.stream.lines[this.stream.line-1],line:this.stream.line,col:this.stream.col},o.type!==comments.type&&this.tokens.push(o),this.tokens[this.pos++]}match(e,n){return n.map(n=>n(e)).filter(e=>e)}token(e,n,t={type:"unknown",value:e,start:{},end:{}}){return n.length>1&&(n=n.filter(e=>!e.strict||e.leaf)).length>1&&(n=n.filter(e=>e.strict)),t.type=n.pop().type,t}seekNonWhitespace(){for(;this.stream.peek()&&Stream.whitespace(this.stream.peek());)this.stream.next()}parse(){for(;!this.stream.eof(this.stream.peek());)this.next();return this.tokens}}var slice=Array.prototype.slice,toArray$1=function(e){return slice.call(e)},tail=function(e){return slice.call(e,1)},createFn=function(e,n,t){var a=t-n.length;switch(a){case 0:return function(){return processInvocation(e,concatArgs(n,arguments),t)};case 1:return function(a){return processInvocation(e,concatArgs(n,arguments),t)};case 2:return function(a,r){return processInvocation(e,concatArgs(n,arguments),t)};case 3:return function(a,r,i){return processInvocation(e,concatArgs(n,arguments),t)};case 4:return function(a,r,i,o){return processInvocation(e,concatArgs(n,arguments),t)};case 5:return function(a,r,i,o,s){return processInvocation(e,concatArgs(n,arguments),t)};case 6:return function(a,r,i,o,s,u){return processInvocation(e,concatArgs(n,arguments),t)};case 7:return function(a,r,i,o,s,u,c){return processInvocation(e,concatArgs(n,arguments),t)};case 8:return function(a,r,i,o,s,u,c,p){return processInvocation(e,concatArgs(n,arguments),t)};case 9:return function(a,r,i,o,s,u,c,p,l){return processInvocation(e,concatArgs(n,arguments),t)};case 10:return function(a,r,i,o,s,u,c,p,l,d){return processInvocation(e,concatArgs(n,arguments),t)};default:return createEvalFn(e,n,a)}},concatArgs=function(e,n){return e.concat(toArray$1(n))},createEvalFn=function(fn,args,arity){var argList=makeArgList(arity),fnStr="false||function("+argList+"){ return processInvocation(fn, concatArgs(args, arguments)); }";return eval(fnStr)},makeArgList=function(e){for(var n=[],t=0;t<e;t+=1)n.push("a"+t.toString());return n.join(",")},trimArrLength=function(e,n){return e.length>n?e.slice(0,n):e},processInvocation=function(e,n,t){return n=trimArrLength(n,t),n.length===t?e.apply(null,n):createFn(e,n,t)},curry=function(e){return createFn(e,[],e.length)};curry.to=curry(function(e,n){return createFn(n,[],e)}),curry.adaptTo=curry(function(e,n){return curry.to(e,function(e){var t=tail(arguments).concat(e);return n.apply(this,t)})}),curry.adapt=function(e){return curry.adaptTo(e.length,e)};var curry_1=curry;const FUNCTION_INDEX="function/index",LOCAL_INDEX="local/index",GLOBAL_INDEX="global/index",TYPE_CONST="type/const",TYPE_ARRAY="type/array",TYPE_OBJECT="type/object",TYPE_INDEX="type/index",OBJECT_SIZE="object/size",TYPE_CAST="type/cast",OBJECT_KEY_TYPES="object/key-types",CLOSURE_TYPE="closure/type",AST_METADATA="AST_METADATA",FUNCTION_METADATA="FUNCTION_METADATA",ALIAS="alias",mapImport=curry_1((e,n,t)=>mapNode({[Syntax.BinaryExpression]:(e,n)=>{const[t,a]=e.params;if(t.Type!==Syntax.Pair)return e;const[r,i]=t.params;return n(_extends({},t,{params:[_extends({},a,{meta:_extends({},r.meta,{AS:r.value})}),i]}))},[Syntax.Pair]:(n,t)=>{const{types:a,functions:r,globals:i}=e;const[o,s]=n.params;if(null!=a[s.value]){const e=Object.keys(r).length,t=Object.keys(a).indexOf(s.value),i=_extends({},o,{id:o.value,type:a[s.value].type,meta:_extends({},o.meta,{[FUNCTION_INDEX]:e,[TYPE_INDEX]:t,FUNCTION_METADATA:a[s.value].meta.FUNCTION_METADATA,DEFAULT_ARGUMENTS:a[s.value].meta.DEFAULT_ARGUMENTS})});return r[o.value]=i,_extends({},n,{params:[i,a[s.value]]})}if(!["Table","Memory"].includes(s.type)){const e=Object.keys(i).length;i[o.value]=_extends({},o,{meta:{[GLOBAL_INDEX]:e,[TYPE_CONST]:!0},type:s.type})}return n}})(n)),extendNode=curry_1((e,n)=>_extends({},n,e)),getTypeSize=e=>{switch(e){case"i64":case"f64":return 8;case"i32":case"f32":case"bool":default:return 4}},parseArray=e=>{const n="[]"===e.slice(-2)?"i32":null;return{arrayType:n?e.slice(0,-2):null,subscriptType:n}},parse$2=({isConst:e,types:n,scope:t,node:a})=>{const{subscriptType:r,arrayType:i}=parseArray(a.type);const o=n[a.type]&&n[a.type].meta[CLOSURE_TYPE]?"i64":null;return[r||o||a.type,{[TYPE_ARRAY]:i,[TYPE_CONST]:e||null,[CLOSURE_TYPE]:o,[TYPE_INDEX]:Object.keys(n).indexOf(a.type)},Object.keys(t).length]},parseDeclaration=curry_1((e,n,t)=>{const{locals:a,closures:r,types:i}=n;const[o,s,u]=parse$2({isConst:e,types:i,scope:a,node:t});a[t.value]=extendNode({params:t.params.map(extendNode({type:t.type})),type:o,meta:_extends({},s,{[LOCAL_INDEX]:u}),Type:Syntax.Declaration},t);null!=r.variables[t.value]&&t.params[0]&&(r.offsets[t.value]=r.envSize,r.envSize+=getTypeSize(t.type))}),parseGlobalDeclaration=curry_1((e,n,t)=>{const{globals:a,types:r}=n;const[i,o,s]=parse$2({isConst:e,types:r,scope:a,node:t});if(["Table","Memory"].includes(t.type))return extendNode({meta:{[GLOBAL_INDEX]:-1}},t);a[t.value]=extendNode({meta:_extends({},o,{[GLOBAL_INDEX]:s}),type:i,Type:Syntax.Declaration},t);return a[t.value]}),fragment=(e,n)=>{const t=new Stream(e);const a=new Tokenizer(t);const r=tokenStream(a.parse());const i=new Context({stream:r,token:r.tokens[0],lines:t.lines,filename:"unknown.walt"});return n(i)},expressionFragment=e=>fragment(e,expression),patchStringSubscript=(e,n)=>{const t=n[1];const a=e[t.value];return[n[0],_extends({},t,{meta:{[ALIAS]:t.value},value:a,type:"i32",Type:Syntax.Constant})]},mapArraySubscript=curry_1(({userTypes:e},n,t)=>{const a=n.params.map(t);const[r,i]=a;const o=e[r.type];if(null!=o){const e=o.meta[TYPE_OBJECT],t=o.meta[OBJECT_KEY_TYPES];return _extends({},n,{type:t?t[i.value]:"i32",params:patchStringSubscript(e,a)})}if(r.Type===Syntax.Type&&i.Type===Syntax.FunctionCall)return _extends({},n,{Type:Syntax.NativeMethod,type:r.value,value:r.value+"."+i.value,params:i.params});const s=r.type;return _extends({},n,{type:s,params:a})}),mapIdentifier=curry_1(({locals:e,globals:n,functions:t,table:a},r)=>{const i=e[r.value];const o=n[r.value];if("__DATA_LENGTH__"===r.value)return _extends({},r,{type:"i32",Type:Syntax.ArraySubscript,params:[_extends({},r,{type:"i32",value:"0",Type:Syntax.Constant}),_extends({},r,{type:"i32",value:"0",Type:Syntax.Constant})]});if(null!=i){const e=(()=>{const e=i.meta[TYPE_ARRAY];return e||i.type})();return _extends({},r,{type:e,meta:_extends({},i.meta)})}if(null!=o)return _extends({},r,{type:n[r.value].type,meta:_extends({},o.meta)});if(null!=t[r.value])return null==a[r.value]&&(a[r.value]=t[r.value]),_extends({},r,{type:"i32",meta:{[FUNCTION_INDEX]:Object.keys(t).indexOf(r.value)},value:Object.keys(a).indexOf(r.value),Type:Syntax.FunctionPointer});return r}),variableSize=e=>{switch(e){case"i64":case"f64":return"8";case"i32":case"f32":default:return"4"}},mapSizeof=curry_1(({locals:e,globals:n,functions:t,userTypes:a},r)=>{const[i]=r.params;const o=e[i.value];const s=n[i.value];const u=a[i.value]||(o?a[o.type]:null);const c=t[i.value];if(null!=u){const e=u.meta[OBJECT_SIZE];return invariant_1(e,"Object size information is missing"),_extends({},r,{value:e,params:[],type:"i32",Type:Syntax.Constant})}const p=o||s||u||c;return _extends({},r,{value:variableSize(p?p.type:i.value),type:"i32",params:[],Type:Syntax.Constant})});var makeAssignment=curry_1(function(e,n,t){const[a,r]=n.params;if(r&&r.Type===Syntax.ObjectLiteral){const n={},i={};walker({[Syntax.Identifier]:(e,t)=>{n[e.value]=_extends({},a,{Type:Syntax.MemoryAssignment,params:[_extends({},a,{Type:Syntax.ArraySubscript,params:[a,e]}),e]})},[Syntax.Pair]:(e,t)=>{const[r,i]=e.params;n[r.value]=_extends({},a,{Type:Syntax.MemoryAssignment,params:[_extends({},a,{Type:Syntax.ArraySubscript,params:[a,r]}),i]})},[Syntax.Spread]:(n,t)=>{const{locals:r,userTypes:o}=e;const[s]=n.params;const u=o[r[s.value].type];const c=u.meta[TYPE_OBJECT];null!=c&&Object.keys(c).forEach(e=>{const n=_extends({},s,{Type:Syntax.Identifier,value:e,params:[]});i[e]=_extends({},a,{Type:Syntax.MemoryAssignment,params:[_extends({},a,{Type:Syntax.ArraySubscript,params:[a,_extends({},n)]}),_extends({},s,{Type:Syntax.ArraySubscript,params:[s,_extends({},n)]})]})})}})(r);const o=Object.values(_extends({},i,n));return _extends({},a,{Type:Syntax.Block,params:o.map(t)})}return _extends({},n,{params:n.params.map(t)})});const CLOSURE_FREE="closure-free",CLOSURE_MALLOC="closure-malloc",CLOSURE_BASE="closure_base",CLOSURE_INNER="closure_inner",CLOSURE_GET="closure--get",CLOSURE_SET="closure--set",expandClosureIdentifier=e=>{const n=()=>_extends({},e,{params:[]});return[_extends({},e,{value:":",meta:{},Type:Syntax.Pair,params:[n(),_extends({},e,{value:"i32",type:"i32",meta:{},params:[],Type:Syntax.Type})]}),...e.params,_extends({},e,{value:":",Type:Syntax.Pair,meta:{},params:[_extends({},e,{value:">>",meta:{},Type:Syntax.BinaryExpression,params:[n(),_extends({},e,{value:"32",type:"i32",meta:{},params:[],Type:Syntax.Constant})]}),_extends({},e,{meta:{},value:"i32",type:"i32",params:[],Type:Syntax.Type})]})]},collapseClosureIdentifier=(e,n)=>_extends({},e,{value:"+",Type:Syntax.BinaryExpression,params:[_extends({},e,{value:":",meta:{},Type:Syntax.Pair,params:[_extends({},e,{Type:Syntax.Identifier,params:[]}),_extends({},e,{value:"i64",type:"i64",Type:Syntax.Type,params:[]})]}),_extends({},n,{value:"<<",Type:Syntax.BinaryExpression,params:[n,_extends({},n,{value:"32",type:"i64",meta:{},params:[],Type:Syntax.Constant})]})]}),mapIdentifierToOffset=(e,n)=>expressionFragment(`${n} + ${e.value}`),getEnclosedVariables=e=>{const n={};const t=curry_1((e,t,a)=>{null==e[t.value]&&(n[t.value]=t)});const a=curry_1((e,n,t)=>{e[n.value]=n});walker({[Syntax.Closure]:(e,n)=>{const r={};const i=a(r);walker({[Syntax.FunctionArguments]:(e,n)=>{walker({[Syntax.Pair]:e=>{const[n]=e.params;i(n,null)}})(e)},[Syntax.Declaration]:i,[Syntax.ImmutableDeclaration]:i,[Syntax.Identifier]:t(r)})(e)}})(e);return n},injectEnvironmentMaybe=({mapFunctionCall:e,variables:n},t)=>{if(Object.keys(n).length>0){const n=t[2];return[...t.slice(0,2),_extends({},n,{value:CLOSURE_BASE,type:"i32",Type:Syntax.Declaration,params:[e(_extends({},n,{type:"i32",meta:{},value:CLOSURE_MALLOC,Type:Syntax.FunctionCall,params:[_extends({},n,{params:[],type:"i32",value:"0",Type:Syntax.Constant})]}))]}),...t.slice(2)]}return t},transformClosedDeclaration=curry_1((e,n,t)=>{const{closures:a,locals:r}=e;const[i]=n.params;if(n.value===CLOSURE_BASE)return _extends({},r[n.value],{params:[_extends({},i,{params:[_extends({},i.params[0],{value:a.envSize})]})].map(t)});if(i&&null!=a.variables[n.value]){const{offsets:e}=a;return t(_extends({},i,{value:`${CLOSURE_SET}-${n.type}`,params:[_extends({},mapIdentifierToOffset(_extends({},i,{value:CLOSURE_BASE}),e[n.value])),i],meta:{},Type:Syntax.FunctionCall}))}return _extends({},r[n.value],{params:r[n.value].params.map(t)})});var makeClosure=curry_1(function(e,n,t){const{locals:a,closures:r,fun:i}=e,{variables:o,offsets:s}=r;return t(mapNode({[Syntax.FunctionDeclaration]:e=>_extends({},e,{value:`internalClosure--${i.value}`}),[Syntax.FunctionArguments]:(e,n)=>_extends({},e,{params:[_extends({},e,{value:":",params:[_extends({},e,{value:CLOSURE_INNER,params:[],Type:Syntax.Identifier}),_extends({},e,{value:"i32",type:"i32",params:[],Type:Syntax.Type})],Type:Syntax.Pair}),...e.params]}),[Syntax.Assignment]:e=>{const[n,t]=e.params;if(null!=o[n.value]){const r=a[n.value];return _extends({},e,{value:`closure--set-${r.type}`,params:[mapIdentifierToOffset(_extends({},n,{value:String(CLOSURE_INNER)}),s[r.value]),t],meta:{},Type:Syntax.FunctionCall})}return e},[Syntax.Identifier]:(e,n)=>{if(null!=o[e.value]){const n=a[e.value];return _extends({},e,{value:`closure--get-${n.type}`,params:[mapIdentifierToOffset(_extends({},e,{value:CLOSURE_INNER}),s[n.value])],Type:Syntax.FunctionCall})}return e}})(n))});const withDefaultArguments=(e,n)=>{if(null==n)return e;const t=n.meta.FUNCTION_METADATA.argumentsCount;const a=e.params.length>0&&e.params[0].Type===Syntax.Sequence?e.params[0].length:e.params.length;const r=t-a;if(r>0)return _extends({},e,{params:[...e.params,...n.meta.DEFAULT_ARGUMENTS.slice(r-1)]});return e};var makeFunctionCall=curry_1(function(e,n){const{functions:t,types:a,locals:r,mapIdentifier:i,mapSizeof:o}=e;if("sizeof"===n.value)return o(n);if(null!=r[n.value]){const e=_extends({},i(n),{Type:Syntax.Identifier}),t=_extends({},e.meta),r=(()=>{const t=a[e.type];return null!=t?t.type:n.type})();if(null!=e.meta[CLOSURE_TYPE])return _extends({},n,{meta:t,type:r,Type:Syntax.IndirectFunctionCall,params:[...expandClosureIdentifier(e)]});const o=Object.keys(a).indexOf(e.type);return _extends({},n,{meta:_extends({},t,{[TYPE_INDEX]:o}),type:r,params:[...n.params,e],Type:Syntax.IndirectFunctionCall})}const s=Object.keys(t).indexOf(n.value);return withDefaultArguments(_extends({},n,{type:null!=t[n.value]?t[n.value].type:null,meta:{[FUNCTION_INDEX]:s}}),t[n.value])});const typeWeight=e=>{switch(e){case"i32":case"bool":return 0;case"i64":return 1;case"f32":return 2;case"f64":return 3;default:return-1}};var makePair=curry_1((e,n,t)=>{const[a,r]=n.params.map(t);const{type:i}=a;const{value:o}=r;if(r.Type===Syntax.Type&&i&&o)return _extends({},n,{type:o,value:a.value,Type:Syntax.TypeCast,meta:_extends({},n.meta,{[TYPE_CAST]:{to:o,from:i}}),params:[a]});return _extends({},n,{params:n.params.map(t)})});const balanceTypesInMathExpression=e=>{const n=e.params.reduce((e,{type:n})=>{if(typeWeight(e)<typeWeight(n))return n;return e},e.type);const t=e.params.map(e=>{if(null!=e.type&&typeWeight(e.type)!==typeWeight(n))return _extends({},e,{type:n,value:e.value,Type:Syntax.TypeCast,meta:_extends({},e.meta,{[TYPE_CAST]:{to:n,from:e.type}}),params:[e]});return e});return _extends({},e,{params:t,type:n})},initialize=(e,n)=>{const{functions:t,types:a}=e;const r={};const i=[];let o=0;const s={variables:getEnclosedVariables(n),offsets:{},envSize:0};const u=walker({[Syntax.FunctionArguments]:(n,t)=>{walker({[Syntax.Assignment]:e=>{const n=e.params[1];i.push(n)},[Syntax.Pair]:n=>{o+=1;const[a,i]=n.params;const u=_extends({},a,{type:i.value});parseDeclaration(!1,_extends({},e,{locals:r,closures:s}),u,t)}})(n)},[Syntax.Declaration]:parseDeclaration(!1,_extends({},e,{locals:r,closures:s})),[Syntax.ImmutableDeclaration]:parseDeclaration(!0,_extends({},e,{locals:r,closures:s}))})(_extends({},n,{type:(()=>{const e=n.params[1];if(null!=a[e.value]&&a[e.value].meta[CLOSURE_TYPE])return"i64";return e.type})(),meta:_extends({},n.meta,{[FUNCTION_INDEX]:Object.keys(t).length,[FUNCTION_METADATA]:{locals:r,get argumentsCount(){return o}},DEFAULT_ARGUMENTS:i}),params:injectEnvironmentMaybe(_extends({mapFunctionCall:makeFunctionCall(_extends({},e,{locals:r,mapIdentifier:mapIdentifier(_extends({locals:r},e)),mapSizeof:mapSizeof(_extends({locals:r},e))}))},s),n.params)}));t[n.value]=u;return[u,r,s]},mapFunctionNode=(e,n,t)=>{const[a,r,i]=initialize(e,n);const o=mapIdentifier(_extends({},e,{locals:r}));const s=mapArraySubscript(_extends({},e,{locals:r}));const u=mapSizeof(_extends({},e,{locals:r}));const c=makeAssignment(_extends({},e,{locals:r}));const p=makeClosure(_extends({},e,{fun:a,locals:r,closures:i}));const l=makePair(_extends({},e,{locals:r,mapIdentifier:o,mapClosure:p,topLevelTransform:t}));const d=makeFunctionCall(_extends({},e,{locals:r,mapIdentifier:o,mapSizeof:u}));return mapNode({[Syntax.FunctionArguments]:(e,n)=>mapNode({[Syntax.Assignment]:e=>e.params[0],[Syntax.Pair]:e=>{const[n,t]=e.params;return _extends({},e,{params:[r[n.value],t]})}})(e),[Syntax.Declaration]:transformClosedDeclaration(_extends({},e,{locals:r,closures:i})),[Syntax.ImmutableDeclaration]:transformClosedDeclaration(_extends({},e,{locals:r,closures:i})),[Syntax.Identifier]:o,[Syntax.FunctionCall]:d,[Syntax.Pair]:l,[Syntax.UnaryExpression]:mapUnary,[Syntax.BinaryExpression]:(e,n)=>balanceTypesInMathExpression(_extends({},e,{params:e.params.map(n)})),[Syntax.TernaryExpression]:(e,n)=>{const t=e.params.map(n);return _extends({},e,{type:t[0].type,params:t})},[Syntax.Select]:(e,n)=>balanceTypesInMathExpression(_extends({},e,{params:e.params.map(n)})),[Syntax.CharacterLiteral]:mapCharacterLiteral,[Syntax.StringLiteral]:(n,t)=>{const{statics:a}=e;const{value:r}=n;r in a||(a[r]=null);return n},[Syntax.Assignment]:c,[Syntax.MemoryAssignment]:(e,n)=>{const t=e.params.map(n);const{type:a}=t[0];return _extends({},e,{params:t,type:a})},[Syntax.ReturnStatement]:e=>{const[n]=e.params;if(null!=n&&n.Type===Syntax.Constant&&typeWeight(n.type)!==typeWeight(a.type))return _extends({},e,{params:[_extends({},n,{value:":",Type:Syntax.Pair,params:[n,_extends({},n,{value:String(a.type),type:a.type,Type:Syntax.Type,params:[]})]})]});return e},[Syntax.ArraySubscript]:s,[Syntax.Sizeof]:u,[Syntax.Closure]:(n,a)=>{const i=p(n,t);const[s]=i.params;e.hoist.push(s);return a(collapseClosureIdentifier(_extends({},r[CLOSURE_BASE],{meta:[]}),o(_extends({},s,{params:[],type:"i32",Type:Syntax.Identifier,meta:[]}))))}})(a)};var mapFunctionNode$1=curry_1(mapFunctionNode);const getByteOffsetsAndSize=e=>{const n={};const t={};let a=0;walker({[Syntax.Pair]:e=>{const{value:r}=e.params[0];const{value:i}=e.params[1];invariant_1(null==n[r],`Duplicate key ${r} not allowed in object type`);t[r]=i;n[r]=a;switch(i){case"i64":case"f64":a+=8;break;case"i32":case"f32":default:a+=4}}})(e);return[n,a,t]},mapStruct=curry_1(({userTypes:e},n,t)=>{const[a,r,i]=getByteOffsetsAndSize(n.params[0]);const o=_extends({},n,{meta:_extends({},n.meta,{[TYPE_OBJECT]:a,[OBJECT_SIZE]:r,[OBJECT_KEY_TYPES]:i})});e[o.value]=o;return o}),mapGeneric=curry_1((e,n,t)=>{const{types:a}=e;const[r,i]=n.params;const o=a[i.value];const[s,u]=o.params;const c=_extends({},o,{range:r.range,value:n.value,meta:_extends({},o.meta,{[CLOSURE_TYPE]:"Lambda"===r.value}),params:[_extends({},s,{params:[_extends({},s,{params:[],type:"i32",value:"i32",Type:Syntax.Type}),...s.params]}),u]});a[c.value]=c;return c}),i32$1=1,i64$1=2,f32$1=4,f64$1=8,anyfunc=16,func=32,block_type=64,i8=128,u8=256,i16=512,u16=1024,u32=2048,u64=4096,word=4,sizeof={[i32$1]:word,[i64$1]:2*word,[f32$1]:word,[f64$1]:2*word,[u32]:word,[u16]:word>>1,[u8]:word>>2,[i8]:word>>2,[i16]:word>>1,[anyfunc]:word,[func]:word,[block_type]:word},LITTLE_ENDIAN=!0,get$1=(e,n,t)=>{switch(e){case i32$1:return t.getInt32(n,LITTLE_ENDIAN);case i64$1:return t.getInt64(n,LITTLE_ENDIAN);case f32$1:return t.getFloat32(n,LITTLE_ENDIAN);case f64$1:return t.getFloat64(n,LITTLE_ENDIAN);case anyfunc:case func:return t.getUint32(n,LITTLE_ENDIAN);case i8:return t.getInt8(n,LITTLE_ENDIAN);case u8:return t.getUint8(n,LITTLE_ENDIAN);case i16:return t.getInt16(n,LITTLE_ENDIAN);case u16:return t.getUint16(n,LITTLE_ENDIAN);case u32:return t.getUint32(n,LITTLE_ENDIAN);case u64:return t.getUint64(n,LITTLE_ENDIAN);default:return t.getUint8(n,LITTLE_ENDIAN)}},set$1=(e,n,t,a)=>{switch(e){case i32$1:return t.setInt32(n,a,LITTLE_ENDIAN);case i64$1:return t.setInt64(n,a,LITTLE_ENDIAN);case f32$1:return t.setFloat32(n,a,LITTLE_ENDIAN);case f64$1:return t.setFloat64(n,a,LITTLE_ENDIAN);case anyfunc:case func:return t.setUint32(n,a,LITTLE_ENDIAN);case i8:return t.setInt8(n,a,LITTLE_ENDIAN);case u8:return t.setUint8(n,a,LITTLE_ENDIAN);case i16:return t.setInt16(n,a,LITTLE_ENDIAN);case u16:return t.setUint16(n,a,LITTLE_ENDIAN);case u32:return t.setUint32(n,a,LITTLE_ENDIAN);case u64:return t.setUint64(n,a,LITTLE_ENDIAN);default:return t.setUint8(n,a,LITTLE_ENDIAN)}};var index={i32:i32$1,i64:i64$1,f32:f32$1,f64:f64$1,anyfunc:anyfunc,func:func,block_type:block_type,i8:i8,u8:u8,i16:i16,u16:u16,u32:u32,u64:u64,set:set$1,get:get$1,sizeof:sizeof},index_1=index.i32,index_2=index.i64,index_3=index.f32,index_4=index.f64,index_9=index.u8,index_12=index.u32,index_14=index.set,index_16=index.sizeof;const def={},opcodeMap=[],textMap={},___=null,opcode=(e,n,t,a,r,i,o)=>{const s={result:e,first:n,second:t,size:a,code:r,name:i,text:o};def[i]=s;opcodeMap[r]=s;textMap[o]=s;return s};opcode(___,___,___,0,0,"Unreachable","unreachable"),opcode(___,___,___,0,1,"Nop","nop"),opcode(___,___,___,0,2,"Block","block"),opcode(___,___,___,0,3,"Loop","loop"),opcode(___,___,___,0,4,"If","if"),opcode(___,___,___,0,5,"Else","else"),opcode(___,___,___,0,6,"Try","try"),opcode(___,___,___,0,7,"Catch","catch"),opcode(___,___,___,0,8,"Throw","throw"),opcode(___,___,___,0,9,"Rethrow","rethrow"),opcode(___,___,___,0,10,"CatchAll","catch_all"),opcode(___,___,___,0,11,"End","end"),opcode(___,___,___,0,12,"Br","br"),opcode(___,___,___,0,13,"BrIf","br_if"),opcode(___,___,___,0,14,"BrTable","br_table"),opcode(___,___,___,0,15,"Return","return"),opcode(___,___,___,0,16,"Call","call"),opcode(___,___,___,0,17,"CallIndirect","call_indirect"),opcode(___,___,___,0,26,"Drop","drop"),opcode(___,___,___,0,27,"Select","select"),opcode(___,___,___,0,32,"GetLocal","get_local"),opcode(___,___,___,0,33,"SetLocal","set_local"),opcode(___,___,___,0,34,"TeeLocal","tee_local"),opcode(___,___,___,0,35,"GetGlobal","get_global"),opcode(___,___,___,0,36,"SetGlobal","set_global"),opcode(index_1,index_1,___,4,40,"i32Load","i32.load"),opcode(index_2,index_1,___,8,41,"i64Load","i64.load"),opcode(index_3,index_1,___,4,42,"f32Load","f32.load"),opcode(index_4,index_1,___,8,43,"f64Load","f64.load"),opcode(index_1,index_1,___,1,44,"i32Load8S","i32.load8_s"),opcode(index_1,index_1,___,1,45,"i32Load8U","i32.load8_u"),opcode(index_1,index_1,___,2,46,"i32Load16S","i32.load16_s"),opcode(index_1,index_1,___,2,47,"i32Load16U","i32.load16_u"),opcode(index_2,index_1,___,1,48,"i64Load8S","i64.load8_s"),opcode(index_2,index_1,___,1,49,"i64Load8U","i64.load8_u"),opcode(index_2,index_1,___,2,50,"i64Load16S","i64.load16_s"),opcode(index_2,index_1,___,2,51,"i64Load16U","i64.load16_u"),opcode(index_2,index_1,___,4,52,"i64Load32S","i64.load32_s"),opcode(index_2,index_1,___,4,53,"i64Load32U","i64.load32_u"),opcode(___,index_1,index_1,4,54,"i32Store","i32.store"),opcode(___,index_1,index_2,8,55,"i64Store","i64.store"),opcode(___,index_1,index_3,4,56,"f32Store","f32.store"),opcode(___,index_1,index_3,8,57,"f64Store","f64.store"),opcode(___,index_1,index_1,1,58,"i32Store8","i32.store8"),opcode(___,index_1,index_1,2,59,"i32Store16","i32.store16"),opcode(___,index_1,index_2,1,60,"i64Store8","i64.store8"),opcode(___,index_1,index_2,2,61,"i64Store16","i64.store16"),opcode(___,index_1,index_2,4,62,"i64Store32","i64.store32"),opcode(index_1,___,___,0,63,"CurrentMemory","current_memory"),opcode(index_1,index_1,___,0,64,"GrowMemory","grow_memory"),opcode(index_1,___,___,0,65,"i32Const","i32.const"),opcode(index_2,___,___,0,66,"i64Const","i64.const"),opcode(index_3,___,___,0,67,"f32Const","f32.const"),opcode(index_4,___,___,0,68,"f64Const","f64.const"),opcode(index_1,index_1,___,0,69,"i32Eqz","i32.eqz"),opcode(index_1,index_1,index_1,0,70,"i32Eq","i32.eq"),opcode(index_1,index_1,index_1,0,71,"i32Ne","i32.ne"),opcode(index_1,index_1,index_1,0,72,"i32LtS","i32.lt_s"),opcode(index_1,index_1,index_1,0,73,"i32LtU","i32.lt_u"),opcode(index_1,index_1,index_1,0,74,"i32GtS","i32.gt_s"),opcode(index_1,index_1,index_1,0,75,"i32GtU","i32.gt_u"),opcode(index_1,index_1,index_1,0,76,"i32LeS","i32.le_s"),opcode(index_1,index_1,index_1,0,77,"i32LeU","i32.le_u"),opcode(index_1,index_1,index_1,0,78,"i32GeS","i32.ge_s"),opcode(index_1,index_1,index_1,0,79,"i32GeU","i32.ge_u"),opcode(index_1,index_2,___,0,80,"i64Eqz","i64.eqz"),opcode(index_1,index_2,index_2,0,81,"i64Eq","i64.eq"),opcode(index_1,index_2,index_2,0,82,"i64Ne","i64.ne"),opcode(index_1,index_2,index_2,0,83,"i64LtS","i64.lt_s"),opcode(index_1,index_2,index_2,0,84,"i64LtU","i64.lt_u"),opcode(index_1,index_2,index_2,0,85,"i64GtS","i64.gt_s"),opcode(index_1,index_2,index_2,0,86,"i64GtU","i64.gt_u"),opcode(index_1,index_2,index_2,0,87,"i64LeS","i64.le_s"),opcode(index_1,index_2,index_2,0,88,"i64LeU","i64.le_u"),opcode(index_1,index_2,index_2,0,89,"i64GeS","i64.ge_s"),opcode(index_1,index_2,index_2,0,90,"i64GeU","i64.ge_u"),opcode(index_1,index_3,index_3,0,91,"f32Eq","f32.eq"),opcode(index_1,index_3,index_3,0,92,"f32Ne","f32.ne"),opcode(index_1,index_3,index_3,0,93,"f32Lt","f32.lt"),opcode(index_1,index_3,index_3,0,94,"f32Gt","f32.gt"),opcode(index_1,index_3,index_3,0,95,"f32Le","f32.le"),opcode(index_1,index_3,index_3,0,96,"f32Ge","f32.ge"),opcode(index_1,index_3,index_3,0,97,"f64Eq","f64.eq"),opcode(index_1,index_3,index_3,0,98,"f64Ne","f64.ne"),opcode(index_1,index_3,index_3,0,99,"f64Lt","f64.lt"),opcode(index_1,index_3,index_3,0,100,"f64Gt","f64.gt"),opcode(index_1,index_3,index_3,0,101,"f64Le","f64.le"),opcode(index_1,index_3,index_3,0,102,"f64Ge","f64.ge"),opcode(index_1,index_1,___,0,103,"i32Clz","i32.clz"),opcode(index_1,index_1,___,0,104,"i32Ctz","i32.ctz"),opcode(index_1,index_1,___,0,105,"i32Popcnt","i32.popcnt"),opcode(index_1,index_1,index_1,0,106,"i32Add","i32.add"),opcode(index_1,index_1,index_1,0,107,"i32Sub","i32.sub"),opcode(index_1,index_1,index_1,0,108,"i32Mul","i32.mul"),opcode(index_1,index_1,index_1,0,109,"i32DivS","i32.div_s"),opcode(index_1,index_1,index_1,0,110,"i32DivU","i32.div_u"),opcode(index_1,index_1,index_1,0,111,"i32RemS","i32.rem_s"),opcode(index_1,index_1,index_1,0,112,"i32RemU","i32.rem_u"),opcode(index_1,index_1,index_1,0,113,"i32And","i32.and"),opcode(index_1,index_1,index_1,0,114,"i32Or","i32.or"),opcode(index_1,index_1,index_1,0,115,"i32Xor","i32.xor"),opcode(index_1,index_1,index_1,0,116,"i32Shl","i32.shl"),opcode(index_1,index_1,index_1,0,117,"i32ShrS","i32.shr_s"),opcode(index_1,index_1,index_1,0,118,"i32ShrU","i32.shr_u"),opcode(index_1,index_1,index_1,0,119,"i32Rotl","i32.rotl"),opcode(index_1,index_1,index_1,0,120,"i32Rotr","i32.rotr"),opcode(index_2,index_2,___,0,121,"i64Clz","i64.clz"),opcode(index_2,index_2,___,0,122,"i64Ctz","i64.ctz"),opcode(index_2,index_2,___,0,123,"i64Popcnt","i64.popcnt"),opcode(index_2,index_2,index_2,0,124,"i64Add","i64.add"),opcode(index_2,index_2,index_2,0,125,"i64Sub","i64.sub"),opcode(index_2,index_2,index_2,0,126,"i64Mul","i64.mul"),opcode(index_2,index_2,index_2,0,127,"i64DivS","i64.div_s"),opcode(index_2,index_2,index_2,0,128,"i64DivU","i64.div_u"),opcode(index_2,index_2,index_2,0,129,"i64RemS","i64.rem_s"),opcode(index_2,index_2,index_2,0,130,"i64RemU","i64.rem_u"),opcode(index_2,index_2,index_2,0,131,"i64And","i64.and"),opcode(index_2,index_2,index_2,0,132,"i64Or","i64.or"),opcode(index_2,index_2,index_2,0,133,"i64Xor","i64.xor"),opcode(index_2,index_2,index_2,0,134,"i64Shl","i64.shl"),opcode(index_2,index_2,index_2,0,135,"i64ShrS","i64.shr_s"),opcode(index_2,index_2,index_2,0,136,"i64ShrU","i64.shr_u"),opcode(index_2,index_2,index_2,0,137,"i64Rotl","i64.rotl"),opcode(index_2,index_2,index_2,0,138,"i64Rotr","i64.rotr"),opcode(index_3,index_3,index_3,0,139,"f32Abs","f32.abs"),opcode(index_3,index_3,index_3,0,140,"f32Neg","f32.neg"),opcode(index_3,index_3,index_3,0,141,"f32Ceil","f32.ceil"),opcode(index_3,index_3,index_3,0,142,"f32Floor","f32.floor"),opcode(index_3,index_3,index_3,0,143,"f32Trunc","f32.trunc"),opcode(index_3,index_3,index_3,0,144,"f32Nearest","f32.nearest"),opcode(index_3,index_3,index_3,0,145,"f32Sqrt","f32.sqrt"),opcode(index_3,index_3,index_3,0,146,"f32Add","f32.add"),opcode(index_3,index_3,index_3,0,147,"f32Sub","f32.sub"),opcode(index_3,index_3,index_3,0,148,"f32Mul","f32.mul"),opcode(index_3,index_3,index_3,0,149,"f32Div","f32.div"),opcode(index_3,index_3,index_3,0,150,"f32Min","f32.min"),opcode(index_3,index_3,index_3,0,151,"f32Max","f32.max"),opcode(index_3,index_3,index_3,0,152,"f32Copysign","f32.copysign"),opcode(index_3,index_3,index_3,0,153,"f32Abs","f64.abs"),opcode(index_3,index_3,index_3,0,154,"f32Neg","f64.neg"),opcode(index_3,index_3,index_3,0,155,"f32Ceil","f64.ceil"),opcode(index_3,index_3,index_3,0,156,"f32Floor","f64.floor"),opcode(index_3,index_3,index_3,0,157,"f32Trunc","f64.trunc"),opcode(index_3,index_3,index_3,0,158,"f32Nearest","f64.nearest"),opcode(index_3,index_3,index_3,0,159,"f32Sqrt","f64.sqrt"),opcode(index_4,index_4,index_4,0,160,"f64Add","f64.add"),opcode(index_4,index_4,index_4,0,161,"f64Sub","f64.sub"),opcode(index_4,index_4,index_4,0,162,"f64Mul","f64.mul"),opcode(index_4,index_4,index_4,0,163,"f64Div","f64.div"),opcode(index_4,index_4,index_4,0,164,"f64Min","f64.min"),opcode(index_4,index_4,index_4,0,165,"f64Max","f64.max"),opcode(index_4,index_4,index_4,0,166,"f64Copysign","f64.copysign"),opcode(index_1,index_2,___,0,167,"i32Wrapi64","i32.wrap/i64"),opcode(index_1,index_3,___,0,168,"i32TruncSf32","i32.trunc_s/f32"),opcode(index_1,index_3,___,0,169,"i32TruncUf32","i32.trunc_u/f32"),opcode(index_1,index_3,___,0,170,"i32TruncSf64","i32.trunc_s/f64"),opcode(index_1,index_3,___,0,171,"i32TruncUf64","i32.trunc_u/f64"),opcode(index_2,index_1,___,0,172,"i64ExtendSi32","i64.extend_s/i32"),opcode(index_2,index_1,___,0,173,"i64ExtendUi32","i64.extend_u/i32"),opcode(index_2,index_3,___,0,174,"i64TruncSf32","i64.trunc_s/f32"),opcode(index_2,index_3,___,0,175,"i64TruncUf32","i64.trunc_u/f32"),opcode(index_2,index_3,___,0,176,"i64TruncSf64","i64.trunc_s/f64"),opcode(index_2,index_3,___,0,177,"i64TruncUf64","i64.trunc_u/f64"),opcode(index_3,index_1,___,0,178,"f32ConvertSi32","f32.convert_s/i32"),opcode(index_3,index_1,___,0,179,"f32ConvertUi32","f32.convert_u/i32"),opcode(index_3,index_2,___,0,180,"f32ConvertSi64","f32.convert_s/i64"),opcode(index_3,index_2,___,0,181,"f32ConvertUi64","f32.convert_u/i64"),opcode(index_3,index_3,___,0,182,"f32Demotef64","f32.demote/f64"),opcode(index_3,index_1,___,0,183,"f64ConvertSi32","f64.convert_s/i32"),opcode(index_3,index_1,___,0,184,"f64ConvertUi32","f64.convert_u/i32"),opcode(index_3,index_2,___,0,185,"f64ConvertSi64","f64.convert_s/i64"),opcode(index_3,index_2,___,0,186,"f64ConvertUi64","f64.convert_u/i64"),opcode(index_3,index_3,___,0,187,"f64Promotef32","f64.promote/f32"),opcode(index_1,index_3,___,0,188,"i32Reinterpretf32","i32.reinterpret/f32"),opcode(index_2,index_3,___,0,189,"i64Reinterpretf64","i64.reinterpret/f64"),opcode(index_3,index_1,___,0,190,"f32Reinterpreti32","f32.reinterpret/i32"),opcode(index_3,index_2,___,0,191,"f32Reinterpreti64","f64.reinterpret/i64");const getTypecastOpcode=(e,n)=>{const t=e[0];if(["i32","bool"].includes(e)&&"i64"===n)return def.i32Wrapi64;if("i64"===e&&["i32","bool"].includes(n))return def.i64ExtendSi32;if("f32"===e&&"f64"===n)return def.f32Demotef64;if("f64"===e&&"f32"===n)return def.f64Promotef32;const a="f"===t?"ConvertS":"TruncS";return def[e+a+n]},opcodeFromOperator=({type:e,value:n})=>{const t={"+":def[String(e)+"Add"],"-":def[String(e)+"Sub"],"*":def[String(e)+"Mul"],"/":def[String(e)+"DivS"]||def[String(e)+"Div"],"%":def[String(e)+"RemS"]||def[String(e)+"RemU"],"==":def[String(e)+"Eq"],"!=":def[String(e)+"Ne"],">":def[String(e)+"Gt"]||def[String(e)+"GtS"],"<":def[String(e)+"Lt"]||def[String(e)+"LtS"],"<=":def[String(e)+"Le"]||def[String(e)+"LeS"],">=":def[String(e)+"Ge"]||def[String(e)+"GeS"],"?":def.If,":":def.Else,"&":def[String(e)+"And"],"|":def[String(e)+"Or"],"^":def[String(e)+"Xor"],">>":def[String(e)+"ShrS"],">>>":def[String(e)+"ShrU"],"<<":def[String(e)+"Shl"]};return t[n]},I32=127,I64=126,F32=125,F64=124,ANYFUNC=112,FUNC=96,stringToType={i32:I32,i64:I64,f32:F32,f64:F64},getTypeString=e=>{switch(e){case I64:return"i64";case F32:return"f32";case F64:return"f64";case FUNC:return"func";case ANYFUNC:return"anyfunc";case I32:default:return"i32"}},scopeOperation=curry_1((e,n)=>{const t=n.meta[LOCAL_INDEX];const a=n.meta[GLOBAL_INDEX];const r=null!=t?t:a;invariant_1(null!=r,`Unefined index for scope Operation. Possibly missing metadata. op: ${JSON.stringify(e)} node: ${JSON.stringify(n,null,2)}`);const i=null!=t?e+"Local":e+"Global";const o=[Number(r)];return{kind:def[i],params:o,debug:`${n.value}<${n.type?n.type:"?"}>`}}),getConstOpcode=e=>{const n=e.type||builtinTypes.i32;const t=def[n+"Const"]||def.i32Const;const a=[Number(e.value)];return[{kind:t,params:a}]},getType=e=>{switch(e){case builtinTypes.f32:return F32;case builtinTypes.f64:return F64;case builtinTypes.i64:return I64;case builtinTypes.i32:default:return I32}},isBuiltinType=e=>"string"==typeof e&&null!=builtinTypes[e],generateValueType=e=>({mutable:e.meta[TYPE_CONST]?0:1,type:getType(e.type)}),setInScope=scopeOperation("Set"),getInScope=scopeOperation("Get"),GLOBAL_LABEL="global",mergeBlock=(e,n)=>{Array.isArray(n)?e=[...e,...n]:e.push(n);return e},generateFunctionCall=(e,n)=>{const t=e.params.map(mapSyntax(n)).reduce(mergeBlock,[]);const a=e.meta[FUNCTION_INDEX];t.push({kind:def.Call,params:[a],debug:`${e.value}<${e.type?e.type:"void"}>`});return t},generateIndirectFunctionCall=(e,n)=>{const t=e.params.map(mapSyntax(n)).reduce(mergeBlock,[]);const a=e.meta[LOCAL_INDEX];const r=e.meta[TYPE_INDEX];invariant_1(null!=a,"Undefined local index, not a valid function pointer");invariant_1(null!=r,"Variable is not of a valid function pointer type");return[...t,{kind:def.CallIndirect,params:[r,0]}]},generateBinaryExpression=(e,n)=>{const t=e.params.map(mapSyntax(n)).reduce(mergeBlock,[]);t.push({kind:opcodeFromOperator(_extends({},e,{type:e.type})),params:[]});return t},generateTernary=(e,n)=>{const t=mapSyntax(n);const a=e.params[1];const r=e.params.slice(0,1).map(t).reduce(mergeBlock,[]);r.push({kind:opcodeFromOperator(e),valueType:generateValueType(e),params:[]});r.push.apply(r,a.params.slice(0,1).map(t).reduce(mergeBlock,[]));r.push({kind:opcodeFromOperator({value:":",type:"i32"}),params:[]});r.push.apply(r,a.params.slice(-1).map(t).reduce(mergeBlock,[]));r.push({kind:def.End,params:[]});return r},generateIf=(e,n)=>{const t=mapSyntax(n);const[a,r,...i]=e.params;return[...[a].map(t).reduce(mergeBlock,[]),{kind:def.If,params:[64]},...[r].map(t).reduce(mergeBlock,[]),...i.map(t).reduce(mergeBlock,[]),{kind:def.End,params:[]}]},generateFunctionPointer=e=>[{kind:def.i32Const,params:[Number(e.value)]}],generateReturn=e=>{const n=e.params.map(mapSyntax(null)).reduce(mergeBlock,[]);n.push({kind:def.Return,params:[]});return n},generateExpression=(e,n)=>[e].map(mapSyntax(n)).reduce(mergeBlock,[]),generateDeclaration=(e,n={code:[],locals:[]})=>{const t=e.params[0];if(t){const a=e.meta[LOCAL_INDEX],r=isBuiltinType(e.type)?e.type:i32;return[...generateExpression(_extends({},t,{type:r}),n),{kind:def.SetLocal,params:[a],debug:`${e.value}<${String(e.type)}>`}]}return[]},generateArraySubscript=(e,n)=>{const t=e.params[0];const a=t.meta[TYPE_ARRAY];const r=e.params.map(mapSyntax(n)).reduce(mergeBlock,[]);let i=e.type;null!=a&&(r.push.apply(r,[{kind:def.i32Const,params:[2]},{kind:def.i32Shl,params:[]}]),i=a);r.push({kind:def.i32Add,params:[]});r.push({kind:def[String(i)+"Load"],params:[2,0]});return r},generateAssignment=e=>{const[n,t]=e.params;const a=[t].map(mapSyntax(null)).reduce(mergeBlock,[]);a.push(setInScope(n));return a},generateMemoryAssignment=(e,n)=>{const t=e.params[0];const a=t.params[0].meta[TYPE_ARRAY];let r=e.type;const i=e.params[0].params.map(mapSyntax(n)).reduce(mergeBlock,[]);null!=a&&(i.push.apply(i,[{kind:def.i32Const,params:[2]},{kind:def.i32Shl,params:[]}]),r=a);i.push({kind:def.i32Add,params:[]});i.push.apply(i,e.params.slice(1).map(mapSyntax(n)).reduce(mergeBlock,[]));i.push({kind:def[String(r)+"Store"],params:[2,0]});return i},generateLoop=(e,n)=>{const t=[];const a=mapSyntax(n);const[r,i,...o]=e.params;t.push.apply(t,[r].map(a).reduce(mergeBlock,[]));t.push({kind:def.Block,params:[64]});t.push({kind:def.Loop,params:[64]});t.push.apply(t,[i].map(a).reduce(mergeBlock,[]));t.push({kind:def.i32Eqz,params:[]});t.push({kind:def.BrIf,params:[1]});t.push.apply(t,o.map(a).reduce(mergeBlock,[]));t.push({kind:def.Br,params:[0]});t.push({kind:def.End,params:[]});t.push({kind:def.End,params:[]});return t},generateSequence=(e,n)=>e.params.map(mapSyntax(n)).reduce(mergeBlock,[]),generateTypecast=(e,n)=>{const t=e.meta[TYPE_CAST];invariant_1(t,`Cannot generate typecast for node: ${JSON.stringify(e)}`);const{to:a,from:r}=t;const i=e.params.map(mapSyntax(n)).reduce(mergeBlock,[]);return[...i,{kind:getTypecastOpcode(a,r),params:[]}]},generateTypecast$2=()=>[{kind:def.Br,params:[2]}],generateBlock=(e,n)=>e.params.map(mapSyntax(n)).reduce(mergeBlock,[]),generateElse=(e,n)=>[{kind:def.Else,params:[]},...e.params.map(mapSyntax(n)).reduce(mergeBlock,[])],generateSelect=(e,n)=>{const[t,a]=e.params;const r={kind:def.Select,params:[]};const i=[t].map(mapSyntax(n)).reduce(mergeBlock,[]);if("&&"===e.value)return[...[a].map(mapSyntax(n)).reduce(mergeBlock,[]),{kind:def.i32Const,params:[0]},...i,r];return[...i,...[a].map(mapSyntax(n)).reduce(mergeBlock,[]),...i,r]},alignCodes={load8_s:0,load8_u:0,store8:0,load16_s:1,load16_u:1,store16:1,store32:2,load32_s:2,load32_u:2,store:2,load:2},generateNative=(e,n)=>{const t=e.params.map(mapSyntax(n)).reduce(mergeBlock,[]);const a=e.value.split(".").pop();if(null==alignCodes[a])t.push({kind:textMap[e.value],params:[]});else{const n=alignCodes[a],r=[n,0];t.push({kind:textMap[e.value],params:r})}return t},parseBounds=e=>{const n={};walker({[Syntax.Pair]:({params:e})=>{const[{value:t},{value:a}]=e;n[t]=parseInt(a)}})(e);return n},getText=e=>{const n=e.value||"??";const t=e.type;const a=t||"i32";const r=opcodeFromOperator({value:n,type:a});if(!t)return r.text.replace("i32","??");return r.text},parseParams=e=>{const n=[];walker({[Syntax.Pair]:(e,t)=>{n.push(`${e.params[0].value} ${e.params[1].value}`)},[Syntax.Type]:e=>{n.push(e.value)}})(e);return n.length?" param("+n.join(" ")+")":""},parseResult=e=>{if(null==e)return"";return" (result "+(e.type||"??")+")"},typedefString=e=>{const[n,t]=e.params;return"(type "+e.value+` (func${parseParams(n)}${parseResult(t)}))`},getPrinters=e=>({[Syntax.Import]:(n,t)=>{const[a,r]=n.params;walker({[Syntax.Pair]:({params:n},t)=>{const{value:a}=n[0];const i=n[1];if("Memory"===i.value){const n=parseBounds(i);e(`(import "${r.value}" "${a}" (memory ${n.initial}${n.max?n.max:""}))`)}else e(`(import "${r.value}" "${a}" ${typedefString(i)})`)},[Syntax.Identifier]:(n,t)=>{const{value:a}=n;e(`(import "${r.value}" "${a}" (type ??))`)}})(a)},[Syntax.Export]:(n,t)=>{e("(export",2);n.params.forEach(t);e(")",0,-2)},[Syntax.GenericType]:(n,t)=>{e("(type-generic "+n.value+")",0,0," pseudo type")},[Syntax.FunctionCall]:(n,t)=>{n.params.length>0?(e(`(call ${n.value}`,2),n.params.forEach(t),e(")",0,-2)):e(`(call ${n.value})`)},[Syntax.BinaryExpression]:(n,t)=>{const a=getText(n);e("("+a,2);n.params.forEach(t);e(")",0,-2)},[Syntax.ArraySubscript]:(n,t)=>{e("(i32.add",2);n.params.forEach(t);e(")",0,-2)},[Syntax.Typedef]:(n,t)=>{e(typedefString(n))},[Syntax.Identifier]:n=>{const t=null!=n.meta[GLOBAL_INDEX]?"global":"local";e(`(get_${t} ${n.value})`)},[Syntax.Constant]:n=>{e(`(${String(n.type)}.const ${n.value})`)},[Syntax.FunctionDeclaration]:(n,t)=>{const[a,r,...i]=n.params;e(`(func ${n.value}${parseParams(a)}${parseResult(r)}`,2);i.forEach(t);e(")",0,-2)},[Syntax.ReturnStatement]:(n,t)=>{e("(return",2);n.params.forEach(t);e(")",0,-2)},[Syntax.Declaration]:(n,t)=>{const a=null!=n.meta[TYPE_CONST]?"immutable":"mutable";e("(local "+n.value+" "+String(n.type),2,0,` ${a}`);n.params.forEach(t);e(")",0,-2)},[Syntax.ImmutableDeclaration]:(n,t)=>{const a=null!=n.meta[GLOBAL_INDEX]?"global":"local";if("Memory"===n.type){const t=parseBounds(n);e(`(memory ${t.initial}${t.max?` ${t.max}`:""})`)}else e(`(${a} `+n.value+" "+String(n.type),2,0," immutable"),n.params.forEach(t),e(")",0,-2)},[Syntax.StringLiteral]:n=>{e("(i32.const ??)",0,0,` string "${n.value}"`)},[Syntax.Type]:n=>{e(n.value)},[Syntax.TypeCast]:(n,t)=>{const a=n.params[0];const r=getTypecastOpcode(String(n.type),a.type);e("("+r.text,2);n.params.forEach(t);e(")",0,-2)},[Syntax.ArraySubscript]:(n,t)=>{e("("+String(n.type)+".load",2,0);n.params.forEach(t);e(")",0,-2)},[Syntax.MemoryAssignment]:(n,t)=>{e("("+String(n.type)+".store",2,0);n.params.forEach(t);e(")",0,-2)},[Syntax.Assignment]:(n,t)=>{const[a,...r]=n.params;const i=null!=a.meta[GLOBAL_INDEX]?"global":"local";e(`(set_${i} ${a.value}`,2);r.forEach(t);e(")",0,-2)},[Syntax.TernaryExpression]:(n,t)=>{const[a,r]=n.params;e("(select",2);t(r);t(a);e(")",0,-2)},[Syntax.IfThenElse]:(n,t)=>{const[a,r,...i]=n.params;e("(if",2);t(a);e("(then",2);t(r);e(")",0,-2);i.length>0&&(e("(else",2),i.forEach(t),e(")",0,-2));e(")",0,-2)},[Syntax.ObjectLiteral]:(e,n)=>{}}),printNode=e=>{if(null==e)return"";let n=0;const t=[];const a=[];const r=[];const i=(e,i=0,o=0,s="")=>{n+=o;r.push(s);a.push(e);t.push(n+e.length);n+=i};walker(getPrinters(i))(e);const o=Math.max(...t);const s=o+4;const u=a.reduce((e,n,a)=>{e+=n.padStart(t[a]," ").padEnd(s," ")+";"+r[a]+"\n";return e},"");return u},syntaxMap={[Syntax.FunctionCall]:generateFunctionCall,[Syntax.IndirectFunctionCall]:generateIndirectFunctionCall,[Syntax.Constant]:getConstOpcode,[Syntax.BinaryExpression]:generateBinaryExpression,[Syntax.TernaryExpression]:generateTernary,[Syntax.IfThenElse]:generateIf,[Syntax.Else]:generateElse,[Syntax.Select]:generateSelect,[Syntax.Block]:generateBlock,[Syntax.Identifier]:getInScope,[Syntax.FunctionIdentifier]:getInScope,[Syntax.FunctionPointer]:generateFunctionPointer,[Syntax.ReturnStatement]:generateReturn,[Syntax.Declaration]:generateDeclaration,[Syntax.ArraySubscript]:generateArraySubscript,[Syntax.Assignment]:generateAssignment,[Syntax.MemoryAssignment]:generateMemoryAssignment,[Syntax.Loop]:generateLoop,[Syntax.Break]:generateTypecast$2,[Syntax.Sequence]:generateSequence,[Syntax.TypeCast]:generateTypecast,[Syntax.Noop]:generateNoop,[Syntax.NativeMethod]:generateNative},mapSyntax=curry_1((e,n)=>{const t=syntaxMap[n.Type];invariant_1(t,`Unexpected Syntax Token ${n.Type} : ${n.value}`);const a=(e,t)=>{e.kind||invariant_1(e.kind,"Unknown opcode generated in block index %s %s. \nOperand: \n%s",t,JSON.stringify(e),printNode(n))};const r=t(n,e);Array.isArray(r)&&r.forEach(a);return r}),generateElement=e=>({functionIndex:e}),EXTERN_FUNCTION=0,EXTERN_TABLE=1,EXTERN_MEMORY=2,EXTERN_GLOBAL=3,externaKindMap={Memory:EXTERN_MEMORY,Table:EXTERN_TABLE},generateMemory=e=>{const n={max:0,initial:0};walker({[Syntax.Pair]:({params:e})=>{const[{value:t},{value:a}]=e;n[t]=parseInt(a)}})(e);return n},generateInit=e=>{const n=generateValueType(e);const[t]=e.params;if(null!=t){const{value:e}=t;switch(n.type){case F32:case F64:n.init=parseFloat(e);break;case I32:case I64:default:n.init=parseInt(e)}}return n},getKindConstant=e=>{switch(e){case"Memory":return EXTERN_MEMORY;case"Table":return EXTERN_TABLE;case"i32":case"f32":case"i64":case"f64":return EXTERN_GLOBAL;default:return EXTERN_FUNCTION}},getFieldName=e=>{let n=e.value;if(null!=e.meta.AS)return e.meta.AS;return n},getType$1=e=>{switch(e){case"f32":return F32;case"f64":return F64;case"i64":return I64;case"i32":case"Function":default:return I32}},generateImplicitFunctionType=e=>{const[n]=e.params;const t=e.type?getType$1(e.type):null;const a=[];walker({[Syntax.Pair]:e=>{const n=e.params[1];invariant_1(n,"Undefined type in a argument expression");a.push(getType$1(n.value))}})(n);return{params:a,result:t,id:e.value}},encodeSigned=e=>{const n=[];for(;;){const t=127&e,a=64&t;if(0===(e>>=7)&&!a||-1===e&&a){n.push(t);break}n.push(128|t)}return n},encodeUnsigned=e=>{const n=[];for(;;){const t=127&e;if(0==(e>>>=7)){n.push(t);break}n.push(128|t)}return n};class OutputStream{constructor(){this.data=[],this.size=0}push(e,n,t){let a=0;switch(e){case"varuint7":case"varuint32":case"varint7":case"varint1":a=(n=encodeUnsigned(n)).length,invariant_1(a,`Cannot write a value of size ${a}`);break;case"varint32":case"varint64":a=(n=encodeSigned(n)).length,invariant_1(a,`Cannot write a value of size ${a}`);break;default:a=index_16[e],invariant_1(a,`Cannot write a value of size ${a}, type ${e}`)}return this.data.push({type:e,value:n,debug:t}),this.size+=a,this}buffer(e=new ArrayBuffer(this.size)){const n=new DataView(e);let t=0;return this.data.forEach(({type:e,value:a})=>{Array.isArray(a)?a.forEach(e=>index_14(index_9,t++,n,e)):(index_14(e,t,n,a),t+=index_16[e])}),e}write(e){return e&&(this.data=this.data.concat(e.data),this.size+=e.size),this}}const DATA_SECTION_HEADER_SIZE=4,generateCode=e=>{const[n,t,...a]=e.params;const r=e.meta[FUNCTION_METADATA];invariant_1(a,"Cannot generate code for function without body");invariant_1(r,"Cannot generate code for function without metadata");const{locals:i,argumentsCount:o}=r;const s={code:[],locals:Object.keys(i).slice(o).map(e=>generateValueType(i[e])),debug:`Function ${e.value}`};const u=a.map(mapSyntax(s));u&&(s.code=u.reduce(mergeBlock,[]));return s},VERSION_1=1,MAGIC=1836278016,varuint7="varuint7",varuint32="varuint32",varint7="varint7",varint1="varint1",varint32="varint32",varint64="varint64",emit$1=e=>{const n=(new OutputStream).push(varuint32,e.length,"entry count");e.forEach(e=>{emitString(n,e.module,"module");emitString(n,e.field,"field");switch(e.kind){case EXTERN_GLOBAL:n.push(index_9,EXTERN_GLOBAL,"Global"),n.push(index_9,e.type,getTypeString(e.type)),n.push(index_9,0,"immutable");break;case EXTERN_FUNCTION:n.push(index_9,e.kind,"Function"),n.push(varuint32,e.typeIndex,"type index");break;case EXTERN_TABLE:n.push(index_9,e.kind,"Table"),n.push(index_9,ANYFUNC,"function table types"),n.push(varint1,0,"has max value"),n.push(varuint32,0,"iniital table size");break;case EXTERN_MEMORY:n.push(index_9,e.kind,"Memory"),n.push(varint1,!!e.max,"has no max"),n.push(varuint32,e.initial,"initial memory size(PAGES)"),e.max&&n.push(varuint32,e.max,"max memory size(PAGES)")}});return n},emit$2=e=>{const n=new OutputStream;n.push(varuint32,e.length,"count");e.forEach(({field:e,kind:t,index:a})=>{emitString(n,e,"field");n.push(index_9,t,"Global");n.push(varuint32,a,"index")});return n},encode=(e,{type:n,init:t,mutable:a})=>{e.push(index_9,n,getTypeString(n));e.push(index_9,a,"mutable");switch(n){case I32:e.push(index_9,def.i32Const.code,def.i32Const.text),e.push(varint32,t,`value (${t})`);break;case F32:e.push(index_9,def.f32Const.code,def.f32Const.text),e.push(index_3,t,`value (${t})`);break;case F64:e.push(index_9,def.f64Const.code,def.f64Const.text),e.push(index_4,t,`value (${t})`)}e.push(index_9,def.End.code,"end")},emit$3=e=>{const n=new OutputStream;n.push(varuint32,e.length,"count");e.forEach(e=>encode(n,e));return n},emit$4=e=>{e=e.filter(e=>null!==e);const n=new OutputStream;n.push(varuint32,e.length,"count");e.forEach(e=>n.push(varuint32,e,"type index"));return n},emitElement=e=>({functionIndex:n},t)=>{e.push(varuint32,0,"table index");e.push(index_9,def.i32Const.code,"offset");e.push(varuint32,t,t.toString());e.push(index_9,def.End.code,"end");e.push(varuint32,1,"number of elements");e.push(varuint32,n,"function index")},emit$5=e=>{const n=new OutputStream;n.push(varuint32,e.length,"count");e.forEach(emitElement(n));return n},emitType=(e,{params:n,result:t},a)=>{e.push(varint7,FUNC,`func type (${a})`);e.push(varuint32,n.length,"parameter count");n.forEach(n=>e.push(varint7,n,"param"));t?(e.push(varint1,1,"result count"),e.push(varint7,t,`result type ${getTypeString(t)}`)):e.push(varint1,0,"result count")},emit$6=e=>{const n=new OutputStream;n.push(varuint32,e.length,"count");e.forEach((e,t)=>emitType(n,e,t));return n},emitLocal=(e,n)=>{null==n.isParam&&(e.push(varuint32,1,"number of locals of following type"),e.push(varint7,n.type,`${getTypeString(n.type)}`))},emitFunctionBody=(e,{locals:n,code:t,debug:a})=>{const r=new OutputStream;t.forEach(({kind:e,params:n,valueType:t,debug:a})=>{r.push(index_9,e.code,`${e.text}  ${a||""}`);t&&(r.push(index_9,t.type,"result type"),r.push(index_9,t.mutable,"mutable"));n.forEach(n=>{let t=varuint32;let a="i32.literal";if(e.code>=40&&e.code<=62)t=varuint32,a="memory_immediate";else switch(e.result){case index_4:t=index_4,a="f64.literal";break;case index_3:t=index_3,a="f32.literal";break;case index_1:t=varint32,a="i32.literal";break;case index_2:t=varint64,a="i64.literal";break;default:t=varuint32}r.push(t,n,`${a}`)})});const i=new OutputStream;n.forEach(e=>emitLocal(i,e));e.push(varuint32,r.size+i.size+2,a);e.push(varuint32,n.length,"locals count");e.write(i);e.write(r);e.push(index_9,def.End.code,"end")},emit$7=e=>{const n=new OutputStream;n.push(varuint32,e.length,"function count");e.forEach(e=>emitFunctionBody(n,e));return n},emitEntry=(e,n)=>{e.push(varint1,n.max?1:0,"has no max");e.push(varuint32,n.initial,"initial memory size(PAGES)");n.max&&e.push(varuint32,n.max,"max memory size(PAGES)")},emit$8=e=>{const n=new OutputStream;n.push(varuint32,e.length,"count");e.forEach(e=>emitEntry(n,e));return n},typeBytecodes={anyfunc:112},emitEntry$1=(e,n)=>{e.push(varint7,typeBytecodes[n.type],n.type);e.push(varint1,n.max?1:0,"has max");e.push(varuint32,n.initial,"initial table size");n.max&&e.push(varuint32,n.max,"max table size")},emitDataSegment=(e,n)=>{e.push(varuint32,0,"memory index");const{offset:t,data:a}=n;e.push(index_9,def.i32Const.code,def.i32Const.text);e.push(varint32,t,`segment offset (${t})`);e.push(index_9,def.End.code,"end");e.push(varuint32,a.size,"segment size");e.write(a)},emitModuleName=e=>{const n=new OutputStream;emitString(n,e,`name_len: ${e}`);return n},emitFunctionNames=e=>{const n=new OutputStream;n.push(varuint32,e.length,`count: ${String(e.length)}`);e.forEach(({index:e,name:t})=>{n.push(varuint32,e,`index: ${String(e)}`);emitString(n,t,`name_len: ${t}`)});return n},emitLocals=e=>{const n=new OutputStream;n.push(varuint32,e.length,`count: ${String(e.length)}`);e.forEach(({index:e,locals:t})=>{n.push(varuint32,e,`function index: ${String(e)}`);n.push(varuint32,t.length,`number of params and locals ${t.length}`);t.forEach(({index:e,name:t})=>{n.push(varuint32,e,`index: ${String(e)}`);emitString(n,t,`name_len: ${t}`)})});return n},emit$10=e=>{const n=new OutputStream;emitString(n,"name","name_len: name");const t=emitModuleName(e.module);n.push(varuint7,0,"name_type: Module");n.push(varuint32,t.size,"name_payload_len");n.write(t);const a=emitFunctionNames(e.functions);n.push(varuint7,1,"name_type: Function");n.push(varuint32,a.size,"name_payload_len");n.write(a);const r=emitLocals(e.locals);n.push(varuint7,2,"name_type: Locals");n.push(varuint32,r.size,"name_payload_len");n.write(r);return n},SECTION_TYPE=1,SECTION_IMPORT=2,SECTION_FUNCTION=3,SECTION_TABLE=4,SECTION_MEMORY=5,SECTION_GLOBAL=6,SECTION_EXPORT=7,SECTION_START=8,SECTION_ELEMENT=9,SECTION_CODE=10,SECTION_DATA=11,SECTION_NAME=0,writer=({type:e,label:n,emitter:t})=>a=>{const r=a[n];if(!r||Array.isArray(r)&&!r.length)return null;const i=(new OutputStream).push(index_9,e,n+" section");const o=t(r);i.push(varuint32,o.size,"size");i.write(o);return i};var section={type:writer({type:SECTION_TYPE,label:"Types",emitter:emit$6}),imports:writer({type:SECTION_IMPORT,label:"Imports",emitter:emit$1}),function:writer({type:SECTION_FUNCTION,label:"Functions",emitter:emit$4}),table:writer({type:SECTION_TABLE,label:"Table",emitter:emitTables$1}),memory:writer({type:SECTION_MEMORY,label:"Memory",emitter:emit$8}),exports:writer({type:SECTION_EXPORT,label:"Exports",emitter:emit$2}),globals:writer({type:SECTION_GLOBAL,label:"Globals",emitter:emit$3}),start:writer({type:SECTION_START,label:"Start",emitter:emitTables}),element:writer({type:SECTION_ELEMENT,label:"Element",emitter:emit$5}),code:writer({type:SECTION_CODE,label:"Code",emitter:emit$7}),data:writer({type:SECTION_DATA,label:"Data",emitter:emit$9}),name:writer({type:SECTION_NAME,label:"Name",emitter:emit$10})};const _debug=(e,n=0,t)=>{let a=0;return e.data.slice(n,t).map(({type:n,value:t,debug:r})=>{const i=a.toString(16).padStart(8,"0").padEnd(e.data.length.toString().length+1);let o;o=Array.isArray(t)?t.map(e=>e.toString(16)).join().padStart(16):t.toString(16).padStart(16);const s=`${i}: ${o} ; ${r}`;a+=index_16[n]||t.length;return s}).join("\n")+"\n ============ fin ============="},source=`\n  const memory: Memory = { initial: 1 };\n  let heapPointer: i32 = 0;\n  export function malloc(size: i32): i32 {\n    const ptr: i32 = heapPointer;\n    heapPointer += size;\n    return ptr;\n  }\n\n  export function free(ptr: i32) {\n  }\n\n  // Getters\n  export function geti32(ptr: i32): i32 {\n    const view: i32[] = ptr;\n    return view[0];\n  }\n\n  export function getf32(ptr: i32): f32 {\n    const view: f32[] = ptr;\n    return view[0];\n  }\n\n  export function geti64(ptr: i32): i64 {\n    const view: i64[] = ptr;\n    return view[0];\n  }\n\n  export function getf64(ptr: i32): f64 {\n    const view: f64[] = ptr;\n    return view[0];\n  }\n\n  // Setters\n  export function seti32(ptr: i32, value: i32) {\n    const view: i32[] = ptr;\n    view[0] = value;\n  }\n\n  export function setf32(ptr: i32, value: f32) {\n    const view: f32[] = ptr;\n    view[0] = value;\n  }\n\n  export function seti64(ptr: i32, value: i64) {\n    const view: i64[] = ptr;\n    view[0] = value;\n  }\n\n  export function setf64(ptr: i32, value: f64) {\n    const view: f64[] = ptr;\n    view[0] = value;\n  }\n`,mapToImports=e=>{const{malloc:n,free:t,geti32:a,getf32:r,geti64:i,getf64:o,seti32:s,setf32:u,seti64:c,setf64:p}=e.instance.exports;return{[CLOSURE_MALLOC]:n,[CLOSURE_FREE]:t,[`${CLOSURE_GET}-i32`]:a,[`${CLOSURE_GET}-f32`]:r,[`${CLOSURE_GET}-i64`]:i,[`${CLOSURE_GET}-f64`]:o,[`${CLOSURE_SET}-i32`]:s,[`${CLOSURE_SET}-f32`]:u,[`${CLOSURE_SET}-i64`]:c,[`${CLOSURE_SET}-f64`]:p}},VERSION="0.5.3",getIR=(e,{version:n=VERSION_1,encodeNames:t=!1,lines:a=(e?e.split("\n"):[]),filename:r="unknown"}={})=>{const i=parse(e);const o=semantics(i);validate(o,{lines:a,filename:r});const s=generator(o,{version:n,encodeNames:t,lines:a,filename:r});const u=emit(s,{version:n,encodeNames:t,filename:r,lines:a});return u},withPlugins=(e,n)=>{const t={closure:(e,n)=>{n["walt-plugin-closure"]=mapToImports(e)}};const a=Object.entries(e).reduce((e,[n,a])=>{t[n](a,e);return e},{});return _extends({},a,n)};exports.parser=parse,exports.semantics=semantics,exports.validate=validate,exports.generator=generator,exports.emitter=emit,exports.prettyPrintNode=printNode,exports.debug=_debug,exports.closurePlugin=closurePlugin$$1,exports.stringEncoder=stringEncoder,exports.stringDecoder=stringDecoder,exports.walkNode=walker,exports.mapNode=mapNode,exports.VERSION=VERSION,exports.getIR=getIR,exports.withPlugins=withPlugins,exports.default=compileWalt,Object.defineProperty(exports,"__esModule",{value:!0})});
