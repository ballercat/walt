!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(e.Walt={})}(this,function(exports){"use strict";function extend(){for(var e={},t=0;t<arguments.length;t++){var n=arguments[t];for(var r in n)hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}function map(e){function t(n){if(!Array.isArray(n))throw new Error("Transform must be used on an Array. Received "+JSON.stringify(n));const r=(()=>{const[t]=n;if(t.Type in e&&"function"==typeof e[t.Type])return e[t.Type];return identity})();if(2===r.length)return r(n,t);const[o,...s]=r(n),i=o.params.filter(Boolean).map(e=>t([e,...s]));return immutable(o,{params:i})}return t}function mapNode$2(e){const t=n=>{if(null==n)return n;const r=(()=>{if("*"in e&&"function"==typeof e["*"])return e["*"];if(n.Type in e&&"function"==typeof e[n.Type])return e[n.Type];return identity})();if(2===r.length)return r(n,t);const o=r(n);const s=o.params.map(t);return immutable(o,{params:s})};return t}function unwrapExports(e){return e&&e.__esModule?e.default:e}function createCommonjsModule(e,t){return t={exports:{}},e(t,t.exports),t.exports}function id(e){return e[0]}function grammar(){const e=require("moo"),t=require("walt-syntax"),{drop:n,nth:r,nuller:o,nonEmpty:s,add:i,flatten:a,compose:c}=require("./helpers"),u=e.compile(t.tokens),p={current:null,lines:[],get line(){return u.line},get col(){return u.col},save(){return u.save()},reset(e,t){return this.lines=e.split("\n"),u.reset(e,t)},next(){let e=u.next();for(;e&&"comment"===e.type;)e=u.next();return this.current=e,this.current},formatError(e){return u.formatError(e)},has(e){return u.has(e)}},{node:l,binary:m,constant:d,identifier:_,statement:f,unary:y,ternary:x,subscript:h,fun:g,declaration:S,call:T,struct:E,result:b,string:v,char:A,typedef:L,comment:I,voidFun:N,type:O,boolean:C,assignment:w,forLoop:P,whileLoop:B,typeGeneric:k,spread:R,builtinDecl:F,genericType:D,voidClosure:M,closure:U}=require("./nodes")(p);return{Lexer:p,ParserRules:[{name:"_$ebnf$1",symbols:[]},{name:"_$ebnf$1",symbols:["_$ebnf$1","wschar"],postprocess:function(e){return e[0].concat([e[1]])}},{name:"_",symbols:["_$ebnf$1"],postprocess:function(e){return null}},{name:"__$ebnf$1",symbols:["wschar"]},{name:"__$ebnf$1",symbols:["__$ebnf$1","wschar"],postprocess:function(e){return e[0].concat([e[1]])}},{name:"__",symbols:["__$ebnf$1"],postprocess:function(e){return null}},{name:"wschar",symbols:[/[ \t\n\v\f]/],postprocess:id},{name:"StaticObjectLiteral",symbols:["LCB","_","RCB"],postprocess:c(l(t.ObjectLiteral))},{name:"StaticObjectLiteral",symbols:["LCB","_","StaticPropertyList","_","RCB"],postprocess:c(l(t.ObjectLiteral),a)},{name:"StaticPropertyValue",symbols:["Number"],postprocess:id},{name:"StaticPropertyValue",symbols:["Boolean"],postprocess:id},{name:"StaticPropertyValue",symbols:["StringLiteral"],postprocess:id},{name:"StaticProperty",symbols:["Identifier","_","COLON","_","StaticPropertyValue"],postprocess:l(t.Pair)},{name:"StaticPropertyList",symbols:["StaticProperty"],postprocess:id},{name:"StaticPropertyList",symbols:["StaticProperty","_","COMMA","_","StaticPropertyList"],postprocess:a},{name:"ObjectLiteral",symbols:["LCB","_","RCB"],postprocess:l(t.ObjectLiteral)},{name:"ObjectLiteral",symbols:["LCB","_","PropertyList","_","RCB"],postprocess:c(l(t.ObjectLiteral),a)},{name:"PropertyList",symbols:["Property"],postprocess:id},{name:"PropertyList",symbols:["Property","_","COMMA","_","PropertyList"],postprocess:a},{name:"Property",symbols:["Identifier","_","COLON","_","Ternary"],postprocess:l(t.Pair)},{name:"Property",symbols:["SPREAD","Identifier"],postprocess:R},{name:"Property",symbols:["Identifier"],postprocess:id},{name:"StructDefinition",symbols:["LCB","_","PropertyNameAndTypeList","_","RCB"],postprocess:c(l(t.ObjectLiteral),a)},{name:"PropertyNameAndTypeList",symbols:["PropertyNameAndType"],postprocess:id},{name:"PropertyNameAndTypeList",symbols:["PropertyNameAndType","_","COMMA","_","PropertyNameAndTypeList"],postprocess:a},{name:"PropertyNameAndType",symbols:["PropertyName","_","COLON","_","Type"],postprocess:l(t.Pair)},{name:"TypeDefinition",symbols:["LB","_","TypeList","_","RB"],postprocess:a},{name:"TypeDefinition",symbols:["LB","_","RB"],postprocess:a},{name:"TypeList",symbols:["Type"],postprocess:id},{name:"TypeList",symbols:["Type","_","COMMA","_","TypeList"],postprocess:a},{name:"PropertyName",symbols:["Identifier"],postprocess:id},{name:"Import",symbols:["IMPORT","_","ImportDefinition","__","FROM","__","StringLiteral","_","SEPARATOR"],postprocess:l(t.Import)},{name:"ImportDefinition",symbols:["LCB","_","ImportAndTypeList","_","RCB"],postprocess:c(l(t.ObjectLiteral),a)},{name:"ImportAndTypeList",symbols:["ImportName"],postprocess:id},{name:"ImportAndTypeList",symbols:["ImportAndType"],postprocess:id},{name:"ImportAndTypeList",symbols:["ImportName","_","COMMA","_","ImportAndTypeList"],postprocess:a},{name:"ImportAndTypeList",symbols:["ImportAndType","_","COMMA","_","ImportAndTypeList"],postprocess:a},{name:"ImportAndType",symbols:["ImportName","_","COLON","_","Type"],postprocess:l(t.Pair)},{name:"ImportAndType",symbols:["ImportName","_","AS","_","Identifier"],postprocess:l(t.BinaryExpression,{value:"as"})},{name:"ImportAndType",symbols:["ImportAndType","_","AS","_","Identifier"],postprocess:l(t.BinaryExpression,{value:"as"})},{name:"ImportName",symbols:["Identifier"],postprocess:id},{name:"TypeDef",symbols:["TYPE","__","Identifier","_","EQUALS","_","GenericType","_","SEPARATOR"],postprocess:D},{name:"GenericType",symbols:["Identifier","LT","_","Type","_","GT"],postprocess:k},{name:"Closure",symbols:["FunctionParameters","_","FATARROW","_","Block"],postprocess:M},{name:"Closure",symbols:["FunctionParameters","_","FunctionResult","_","FATARROW","_","Block"],postprocess:U},{name:"Expression",symbols:["Closure"],postprocess:id},{name:"If",symbols:["IF","_","LB","_","Expression","_","RB","_","BranchBody"],postprocess:l(t.IfThenElse)},{name:"If",symbols:["IF","_","LB","_","Expression","_","RB","_","BranchBody","_","Else"],postprocess:l(t.IfThenElse)},{name:"Else",symbols:["ELSE","_","BranchBody"],postprocess:l(t.Else)},{name:"BranchBody",symbols:["Statement"],postprocess:id},{name:"BranchBody",symbols:["Block"],postprocess:id},{name:"For",symbols:["FOR","_","LB","_","LoopArgument","_","SEPARATOR","_","Expression","_","SEPARATOR","_","LoopArgument","_","RB","_","BranchBody"],postprocess:P},{name:"LoopArgument",symbols:["Expression"],postprocess:id},{name:"LoopArgument",symbols:["AssignmentExpression"],postprocess:id},{name:"While",symbols:["WHILE","_","LB","_","Expression","_","RB","_","BranchBody"],postprocess:B},{name:"Break",symbols:["BREAK","_","SEPARATOR"],postprocess:l(t.Break)},{name:"Program",symbols:["_"],postprocess:c(l("Program",{value:"ROOT_NODE"}),a)},{name:"Program",symbols:["_","SourceElementList","_"],postprocess:c(l("Program",{value:"ROOT_NODE"}),a)},{name:"SourceElementList",symbols:["SourceElement"],postprocess:a},{name:"SourceElementList",symbols:["SourceElement","_","SourceElementList"],postprocess:c(n,a,a)},{name:"SourceElement",symbols:["Function"],postprocess:id},{name:"SourceElement",symbols:["Declaration"],postprocess:id},{name:"SourceElement",symbols:["ImmutableDeclaration"],postprocess:id},{name:"SourceElement",symbols:["Struct"],postprocess:id},{name:"SourceElement",symbols:["TypeDef"],postprocess:id},{name:"SourceElement",symbols:["Export"],postprocess:id},{name:"SourceElement",symbols:["Import"],postprocess:id},{name:"Statement",symbols:["ExpressionStatement"],postprocess:id},{name:"Statement",symbols:["Declaration"],postprocess:id},{name:"Statement",symbols:["ImmutableDeclaration"],postprocess:id},{name:"Statement",symbols:["Assignment"],postprocess:id},{name:"Statement",symbols:["If"],postprocess:id},{name:"Statement",symbols:["For"],postprocess:id},{name:"Statement",symbols:["While"],postprocess:id},{name:"Statement",symbols:["Break"],postprocess:id},{name:"Statement",symbols:["ReturnStatement"],postprocess:id},{name:"Block",symbols:["LCB","_","RCB"],postprocess:l(t.Block)},{name:"Block",symbols:["LCB","_","StatementList","_","RCB"],postprocess:c(l(t.Block),a)},{name:"StatementList",symbols:["Statement"],postprocess:n},{name:"StatementList",symbols:["Statement","_","StatementList"],postprocess:a},{name:"Function",symbols:["FUNCTION","__","Identifier","_","FunctionParameters","_","Block"],postprocess:N},{name:"Function",symbols:["FUNCTION","__","Identifier","_","FunctionParameters","_","FunctionResult","_","Block"],postprocess:g},{name:"FunctionParameters",symbols:["LB","_","RB"],postprocess:l(t.FunctionArguments)},{name:"FunctionParameters",symbols:["LB","_","ParameterList","_","RB"],postprocess:c(l(t.FunctionArguments),a)},{name:"ParameterList",symbols:["PropertyNameAndType"],postprocess:id},{name:"ParameterList",symbols:["PropertyNameAndType","_","COMMA","_","ParameterList"],postprocess:a},{name:"FunctionResult",symbols:["COLON","_","Type"],postprocess:c(b,n)},{name:"Declaration",symbols:["LET","_","PropertyNameAndType","_","EQUALS","_","ExpressionStatement"],postprocess:S(t.Declaration)},{name:"Declaration",symbols:["LET","_","PropertyNameAndType","_","SEPARATOR"],postprocess:S(t.Declaration)},{name:"ImmutableDeclaration",symbols:["CONST","_","PropertyNameAndType","_","EQUALS","_","ExpressionStatement"],postprocess:S(t.ImmutableDeclaration)},{name:"ImmutableDeclaration",symbols:["CONST","_","PropertyNameAndType","_","EQUALS","_","ObjectLiteral","_","SEPARATOR"],postprocess:S(t.ImmutableDeclaration)},{name:"ImmutableDeclaration",symbols:["CONST","_","Identifier","_","COLON","_","GenericType","_","SEPARATOR"],postprocess:F},{name:"Pair",symbols:["Identifier","_","COLON","_","Identifier"],postprocess:l(t.Pair)},{name:"Export",symbols:["EXPORT","__","ImmutableDeclaration"],postprocess:l(t.Export,{value:"export"})},{name:"Export",symbols:["EXPORT","__","Function"],postprocess:l(t.Export,{value:"export"})},{name:"Export",symbols:["EXPORT","__","TypeDef"],postprocess:l(t.Export,{value:"export"})},{name:"Export",symbols:["EXPORT","__","Struct"],postprocess:l(t.Export,{value:"export"})},{name:"ReturnStatement",symbols:["RETURN","__","ExpressionStatement"],postprocess:l(t.ReturnStatement)},{name:"ReturnStatement",symbols:["RETURN","_","SEPARATOR"],postprocess:l(t.ReturnStatement)},{name:"Struct",symbols:["TYPE","__","Identifier","_","EQUALS","_","StructDefinition","SEPARATOR"],postprocess:E},{name:"TypeDef",symbols:["TYPE","__","Identifier","_","EQUALS","_","TypeDefinition","_","FATARROW","_","Type","_","SEPARATOR"],postprocess:c(L)},{name:"Assignment",symbols:["AssignmentExpression","_","SEPARATOR"],postprocess:id},{name:"AssignmentExpression",symbols:["Access","_","EQUALS","_","Expression"],postprocess:e=>w(e,"=")},{name:"AssignmentExpression",symbols:["Access","_","PLSEQUALS","_","Expression"],postprocess:e=>w(e,"+=")},{name:"AssignmentExpression",symbols:["Access","_","MINEQUALS","_","Expression"],postprocess:e=>w(e,"-=")},{name:"AssignmentExpression",symbols:["Access","_","EQUALS","_","ObjectLiteral"],postprocess:e=>w(e,"=")},{name:"ExpressionStatement",symbols:["Expression","SEPARATOR"],postprocess:id},{name:"Expression",symbols:["Ternary"],postprocess:id},{name:"Ternary",symbols:["Ternary","_","QUESTION","_","TernaryPair"],postprocess:x},{name:"Ternary",symbols:["Binary"],postprocess:id},{name:"TernaryPair",symbols:["Expression","_","COLON","_","Expression"],postprocess:l(t.Pair)},{name:"Binary",symbols:["Logical"],postprocess:id},{name:"Logical",symbols:["Logical","_",{literal:"||"},"_","Bitwise"],postprocess:m},{name:"Logical",symbols:["Logical","_",{literal:"&&"},"_","Bitwise"],postprocess:m},{name:"Logical",symbols:["Bitwise"],postprocess:id},{name:"Bitwise",symbols:["Bitwise","_",{literal:"|"},"_","Sum"],postprocess:m},{name:"Bitwise",symbols:["Bitwise","_",{literal:"^"},"_","Sum"],postprocess:m},{name:"Bitwise",symbols:["Bitwise","_",{literal:"&"},"_","Sum"],postprocess:m},{name:"Bitwise",symbols:["Equality"],postprocess:id},{name:"Equality",symbols:["Equality","_",{literal:"=="},"_","Comparison"],postprocess:m},{name:"Equality",symbols:["Equality","_",{literal:"!="},"_","Comparison"],postprocess:m},{name:"Equality",symbols:["Comparison"],postprocess:id},{name:"Comparison",symbols:["Comparison","_",{literal:"<"},"_","Shift"],postprocess:m},{name:"Comparison",symbols:["Comparison","_",{literal:">"},"_","Shift"],postprocess:m},{name:"Comparison",symbols:["Comparison","_",{literal:"<="},"_","Shift"],postprocess:m},{name:"Comparison",symbols:["Comparison","_",{literal:">="},"_","Shift"],postprocess:m},{name:"Comparison",symbols:["Shift"],postprocess:id},{name:"Shift",symbols:["Shift","_",{literal:">>"},"_","Sum"],postprocess:m},{name:"Shift",symbols:["Shift","_",{literal:"<<"},"_","Sum"],postprocess:m},{name:"Shift",symbols:["Shift","_",{literal:">>>"},"_","Sum"],postprocess:m},{name:"Shift",symbols:["Sum"],postprocess:id},{name:"Sum",symbols:["Sum","_",{literal:"+"},"_","Product"],postprocess:m},{name:"Sum",symbols:["Sum","_",{literal:"-"},"_","Product"],postprocess:m},{name:"Sum",symbols:["Product"],postprocess:id},{name:"Product",symbols:["Product","_",{literal:"*"},"_","Typecast"],postprocess:m},{name:"Product",symbols:["Product","_",{literal:"/"},"_","Typecast"],postprocess:m},{name:"Product",symbols:["Product","_",{literal:"%"},"_","Typecast"],postprocess:m},{name:"Product",symbols:["Typecast"],postprocess:id},{name:"Typecast",symbols:["Expression","_","COLON","_","Type"],postprocess:l(t.Pair)},{name:"Typecast",symbols:["Expression","_","AS","_","Type"],postprocess:l(t.Pair)},{name:"Typecast",symbols:["Unary"],postprocess:id},{name:"Unary",symbols:[{literal:"!"},"Call"],postprocess:y},{name:"Unary",symbols:[{literal:"~"},"Call"],postprocess:y},{name:"Unary",symbols:[{literal:"-"},"Call"],postprocess:y},{name:"Unary",symbols:[{literal:"+"},"Call"],postprocess:y},{name:"Unary",symbols:[{literal:"++"},"Call"],postprocess:y},{name:"Unary",symbols:[{literal:"--"},"Call"],postprocess:y},{name:"Unary",symbols:["Call"],postprocess:id},{name:"Call",symbols:["Access","_","LB","_","ArgumentList","_","RB"],postprocess:c(T,a)},{name:"Call",symbols:["Access","_","LB","_","RB"],postprocess:T},{name:"Call",symbols:["Access"],postprocess:id},{name:"ArgumentList",symbols:["Expression"],postprocess:id},{name:"ArgumentList",symbols:["Expression","_","COMMA","_","ArgumentList"],postprocess:a},{name:"Access",symbols:["Identifier","DOT","Identifier"],postprocess:h},{name:"Access",symbols:["NativeType","DOT","Identifier"],postprocess:h},{name:"Access",symbols:["Identifier","LSB","_","Ternary","_","RSB"],postprocess:h},{name:"Access",symbols:["Grouping"],postprocess:id},{name:"Grouping",symbols:["LB","_","Expression","_","RB"],postprocess:r(2)},{name:"Grouping",symbols:["Atom"],postprocess:id},{name:"Atom",symbols:["Identifier"],postprocess:id},{name:"Atom",symbols:["StringLiteral"],postprocess:id},{name:"Atom",symbols:["CharacterLiteral"],postprocess:id},{name:"Atom",symbols:["Number"],postprocess:id},{name:"Type",symbols:["_Type"],postprocess:id},{name:"Type",symbols:["_Type","_","LSB","_","RSB"],postprocess:e=>_extends({},e[0],{value:e[0].value+"[]",type:e[0].type+"[]"})},{name:"_Type",symbols:["NativeType"],postprocess:id},{name:"_Type",symbols:["GenericType"],postprocess:id},{name:"_Type",symbols:["Identifier"],postprocess:id},{name:"NativeType",symbols:[p.has("type")?{type:"type"}:O],postprocess:O},{name:"GenericType",symbols:["Identifier","LT","_","StaticObjectLiteral","_","GT"],postprocess:k},{name:"Identifier",symbols:[p.has("identifier")?{type:"identifier"}:_],postprocess:_},{name:"Number",symbols:[p.has("number")?{type:"number"}:number],postprocess:d},{name:"StringLiteral",symbols:[p.has("string")?{type:"string"}:v],postprocess:v},{name:"CharacterLiteral",symbols:[p.has("char")?{type:"char"}:A],postprocess:A},{name:"Boolean",symbols:[{literal:"true"}],postprocess:C},{name:"Boolean",symbols:[{literal:"false"}],postprocess:C},{name:"word",symbols:[/[a-zA-Z_]/],postprocess:id},{name:"word",symbols:["word",/[a-zA-Z0-9_]/],postprocess:i},{name:"digit",symbols:[/[0-9]/],postprocess:id},{name:"digit",symbols:["digit",/[0-9]/],postprocess:i},{name:"Comment",symbols:[p.has("comment")?{type:"comment"}:I],postprocess:I},{name:"Comment",symbols:[p.has("comment")?{type:"comment"}:I,"_","Comment"],postprocess:I},{name:"SEPARATOR",symbols:["_",{literal:";"}],postprocess:o},{name:"QUESTION",symbols:[{literal:"?"}],postprocess:o},{name:"COMMA",symbols:[{literal:","}],postprocess:o},{name:"DOT",symbols:[{literal:"."}],postprocess:o},{name:"LB",symbols:[{literal:"("}],postprocess:o},{name:"RB",symbols:[{literal:")"}],postprocess:o},{name:"LSB",symbols:[{literal:"["}],postprocess:o},{name:"RSB",symbols:[{literal:"]"}],postprocess:o},{name:"LCB",symbols:[{literal:"{"}],postprocess:o},{name:"RCB",symbols:[{literal:"}"}],postprocess:o},{name:"COLON",symbols:[{literal:":"}],postprocess:o},{name:"EQUALS",symbols:[{literal:"="}],postprocess:o},{name:"PLSEQUALS",symbols:[{literal:"+="}],postprocess:o},{name:"MINEQUALS",symbols:[{literal:"-="}],postprocess:o},{name:"GT",symbols:[{literal:">"}],postprocess:o},{name:"LT",symbols:[{literal:"<"}],postprocess:o},{name:"FATARROW",symbols:[{literal:"=>"}],postprocess:o},{name:"SPREAD",symbols:[{literal:"..."}],postprocess:o},{name:"FUNCTION",symbols:[{literal:"function"}],postprocess:o},{name:"LET",symbols:[{literal:"let"}],postprocess:o},{name:"CONST",symbols:[{literal:"const"}],postprocess:o},{name:"EXPORT",symbols:[{literal:"export"}],postprocess:o},{name:"IMPORT",symbols:[{literal:"import"}],postprocess:o},{name:"AS",symbols:[{literal:"as"}],postprocess:o},{name:"FROM",symbols:[{literal:"from"}],postprocess:o},{name:"RETURN",symbols:[{literal:"return"}],postprocess:o},{name:"TYPE",symbols:[{literal:"type"}],postprocess:o},{name:"IF",symbols:[{literal:"if"}],postprocess:o},{name:"ELSE",symbols:[{literal:"else"}],postprocess:o},{name:"FOR",symbols:[{literal:"for"}],postprocess:o},{name:"WHILE",symbols:[{literal:"while"}],postprocess:o},{name:"SWITCH",symbols:[{literal:"switch"}],postprocess:o},{name:"DO",symbols:[{literal:"do"}],postprocess:o},{name:"BREAK",symbols:[{literal:"break"}],postprocess:o}],ParserStart:"Program"}}function id$1(e){return e[0]}function grammar$1(){const e=require("walt-syntax"),{flatten:t}=require("../parser/grammar/helpers"),{node:n}=require("../parser/grammar/nodes")(this.lexer);return{Lexer:void 0,ParserRules:[{name:"TypeList",symbols:["DefaultArgument"],postprocess:id$1},{name:"TypeList",symbols:["DefaultArgument","_","COMMA","_","TypeList"],postprocess:t},{name:"DefaultArgument",symbols:["Type","_","EQUALS","_","Atom"],postprocess:n(e.Assignment)},{name:"ParameterList",symbols:["DefaultFunctionArgument"],postprocess:id$1},{name:"ParameterList",symbols:["DefaultFunctionArgument","_","COMMA","_","ParameterList"],postprocess:t},{name:"DefaultFunctionArgument",symbols:["PropertyNameAndType","_","EQUALS","_","Atom"],postprocess:n(e.Assignment)}],ParserStart:"TypeList"}}function makeLexer(){const e=moo.compile(waltSyntax_8);return{current:null,lines:[],get line(){return e.line},get col(){return e.col},save(){return e.save()},reset(t,n){return this.lines=t.split("\n"),e.reset(t,n)},next(){let t=e.next();for(;t&&"comment"===t.type;)t=e.next();return this.current=t,this.current},formatError(t){return e.formatError(t)},has(t){return e.has(t)}}}function parse(e,t=[grammar,grammar$1]){const n={lexer:makeLexer()},r=t.slice(1).reduce((e,t)=>{const r=t.call(n);return _extends({},e,{ParserRules:e.ParserRules.concat(r.ParserRules)})},t[0].call(n)),o=new nearley_1(nearley_2.fromCompiled(r));return o.feed(e),invariant_1(1===o.results.length,`Ambiguous syntax number of productions: ${o.results.length}`),o.results[0]}function enter$1(e,t){return[...e,{[namespace$1]:t}]}function exit$1(e){return e.slice(0,-1)}function current$1(e){return e[e.length-1]}function add$1(e,t,n){const r=current$1(e);return r&&(r[t]=n),r}function find$1(e,t){let n=e.length-1;for(n;n>=0;n--){const r=e[n][t];if(r)return r}return null}function index$1(e,t){const n=Object.keys(e).indexOf(t);return n>-1?n:Object.keys(e).length}function Core(){return{semantics(){const e=e=>([t,n])=>{const r=scope_3(n.scopes);const o=scope_6(r,t.value);r[t.value]=extendNode({params:t.params.map(extendNode({type:t.type})),meta:_extends({},t.meta,{[r[scope_7]]:o,[TYPE_CONST]:t.Type===Syntax.ImmutableDeclaration}),Type:Syntax.Declaration},t);return e([r[t.value],n])};return{Declaration:e,ImmutableDeclaration:e,Select:e=>([e,t],n)=>balanceTypesInMathExpression(_extends({},e,{params:e.params.map(e=>n([e,t]))})),BinaryExpression:e=>([e,t],n)=>balanceTypesInMathExpression(_extends({},e,{params:e.params.map(e=>n([e,t]))})),Pair:e=>(e,t)=>{const[n,r]=e;const o=n.params.map(e=>t([e,r]));const[s,i]=o;const{type:a}=s;const{value:c}=i;if(i.Type===Syntax.Type&&a&&c)return _extends({},n,{type:c,value:s.value,Type:Syntax.TypeCast,meta:_extends({},n.meta,{[TYPE_CAST]:{to:c,from:a}}),params:[s]});return _extends({},n,{params:o})},Identifier:e=>t=>{const[n,r]=t;let o=scope_4(r.scopes,n.value);if(o)return _extends({},n,{meta:_extends({},n.meta,o.meta),type:o.type});return e(t)},MemoryAssignment:e=>(e,t)=>{const[n,r]=e;const o=n.params.map(e=>t([e,r]));const{type:s}=o[0];return _extends({},n,{params:o,type:s})},TernaryExpression:e=>([t,n])=>e([balanceTypesInMathExpression(t),n])}}}}function base(){return{semantics(){return{"*":e=>(function([e,...t],n){return _extends({},e,{params:e.params.map(e=>n([e,...t]))})})}}}}function typePlugin(){return{semantics(){return{Typedef:e=>([e])=>e,Program:e=>t=>{const[n,r]=t;const{types:o}=r;const s=mapNode_2({[Syntax.Export]:(e,t)=>{const[n]=e.params;if(null!=n&&[Syntax.Typedef,Syntax.Struct].includes(n.Type))return t(_extends({},n,{meta:_extends({},n.meta,{EXPORTED:!0})}));return e},[Syntax.Typedef]:(e,t)=>{let n=0;const[r]=e.params;const s=[];walkNode({Assignment(e){const t=e.params[1];s.push(t)},Type(){n+=1}})(r);const i=_extends({},e,{meta:_extends({},e.meta,{FUNCTION_METADATA:{argumentsCount:n},DEFAULT_ARGUMENTS:s})});o[e.value]=i;return i},[Syntax.GenericType]:mapGeneric({types:o})})(n);return e([s,r])}}}}}function unary(){return{semantics(){return{UnaryExpression:e=>(e,t)=>{const[n,r]=e;const[o,s]=n.params.map(e=>t([e,r]));switch(n.value){case"!":const e=shifts[o.type];return t([fragment(`(((${String(o.value)} >> ${e}) | ((~${String(o.value)} + 1) >> ${e})) + 1)`),r]);case"~":const i=["i64","f64"].includes(t([o,r]).type)?"0xffffffffffff":"0xffffff";return t([fragment(`(${String(o.value)} ^ ${i})`),r]);default:return t([_extends({},n,{type:s.type,params:[_extends({},o,{type:s.type}),s],Type:Syntax.BinaryExpression}),r])}},MemoryAssignment:e=>t=>{const[n,r]=t;if(!["-=","+="].includes(n.value))return e(t);const o=n.value[0];const[s,i]=n.params;return e([_extends({},n,{value:"=",params:[s,_extends({},s,{Type:Syntax.BinaryExpression,value:o,params:[s,i]})]}),r])}}}}}function coreFunctionPlugin(){return{semantics(){return{FunctionDeclaration:e=>([e,t],n)=>{t=_extends({},t,{result:e.result,locals:{},arguments:[],scopes:scope_1(t.scopes,LOCAL_INDEX)});const[r,o,...s]=e.params;const[i,a]=[r,o].map(e=>n([e,t]));const c=_extends({},e,{type:t.result,meta:_extends({},e.meta,{[FUNCTION_INDEX]:Object.keys(t.functions).length,[FUNCTION_METADATA]:{argumentsCount:t.arguments.length,locals:scope_3(t.scopes)}})});t.functions[e.value]=c;const u=s.map(e=>n([e,t]));c.params=[i,a,...u];t.scopes=scope_2(t.scopes);return c},FunctionResult:e=>([e,t])=>{t.result=e.type;return e},FunctionArguments:e=>([t,n])=>e([_extends({},t,{params:t.params.filter(Boolean)}),_extends({},n,{isParsingArguments:!0})]),Pair:e=>(t,n)=>{const[r,o]=t;if(o.isParsingArguments){const[e,t]=r.params;return o.arguments.push(r),n([_extends({},r,{value:e.value,type:t.value,params:[],Type:Syntax.Declaration}),o]),r}return e(t)},FunctionCall:e=>([t,n])=>{const{functions:r}=n;const o=Object.keys(r).indexOf(t.value);return e([_extends({},t,{type:null!=r[t.value]?r[t.value].type:null,meta:{[FUNCTION_INDEX]:o},params:t.params.slice(1)}),n])},ReturnStatement:e=>([e,t],n)=>{const[r]=e.params.map(e=>n([e,t]));const{result:o}=t;if(null!=r&&r.Type===Syntax.Constant&&typeWeight(r.type)!==typeWeight(o))return _extends({},e,{type:o,params:[_extends({},r,{type:o})]});const s=r?r.type:null;return _extends({},e,{params:[r],type:s})}}}}}function Imports(){return{semantics:()=>({Import:e=>e=>{const[t,n]=e;return mapNode_2({[Syntax.BinaryExpression]:(e,t)=>{const[n,r]=e.params;if(n.Type!==Syntax.Pair)return e;const[o,s]=n.params;return t(_extends({},n,{params:[_extends({},r,{meta:_extends({},o.meta,{AS:o.value})}),s]}))},[Syntax.Pair]:(e,t)=>{const{types:r,functions:o}=n;const[s,i]=e.params;if(null!=r[i.value]){const t=Object.keys(o).length,n=Object.keys(r).indexOf(i.value),a=_extends({},s,{id:s.value,type:r[i.value].type,meta:_extends({},s.meta,{[FUNCTION_INDEX]:t,[TYPE_INDEX]:n,FUNCTION_METADATA:r[i.value].meta.FUNCTION_METADATA,DEFAULT_ARGUMENTS:r[i.value].meta.DEFAULT_ARGUMENTS})});return o[s.value]=a,_extends({},e,{params:[a,r[i.value]]})}if(!["Table","Memory"].includes(i.value)){const e=scope_3(n.scopes),t=scope_6(e,s.value);scope_5(n.scopes,s.value,_extends({},s,{meta:{[e[scope_7]]:t,[TYPE_CONST]:!0},type:i.type}))}return e}})(t)}})}}function booleanPlugin(){return{semantics(){const e=e=>([t,n])=>{if("bool"===t.type)return e([_extends({},t,{type:"i32"}),n]);return e([t,n])};return{Identifier:e=>(t,n)=>{const[r,o]=t;if("true"!==r.value&&"false"!==r.value)return e(t);return n([_extends({},r,{Type:Syntax.Constant,value:"true"===r.value?"1":"0",type:"i32"}),o])},FunctionResult:e=>([t,n])=>{if("bool"===t.type)return e([_extends({},t,{type:"i32"}),n]);return e([t,n])},Constant:e=>([t,...n])=>{if("bool"===t.type)return e([_extends({},t,{type:"i32"})]);return e([t,...n])},Declaration:e,ImmutableDeclaration:e}}}}function arrayPlugin(){return{semantics(){const e=e=>t=>{const[n,r]=t;if(n.type&&n.type.endsWith("[]"))return e([_extends({},n,{type:"i32",meta:_extends({},n.meta,{[TYPE_ARRAY]:n.type.slice(0,-2)})}),r]);return e(t)};return{Declaration:e,ImmutableDeclaration:e,Identifier:e=>t=>{const[n,r]=t;const o=scope_4(r.scopes,n.value);if(o&&o.meta[TYPE_ARRAY])return e([_extends({},n,{type:o.type,meta:_extends({},n.meta,o.meta)}),r]);return e(t)},ArraySubscript:e=>(e,t)=>{const[n,r]=e;const o=n.params.map(e=>t([e,r]));const[s]=o;return _extends({},n,{params:o,type:s.meta[TYPE_ARRAY]})}}}}}function memoryPlugin(){return{semantics(){return{Identifier:e=>t=>{const[n]=t;if("__DATA_LENGTH__"===n.value)return _extends({},n,{type:"i32",Type:Syntax.ArraySubscript,params:[_extends({},n,{type:"i32",value:"0",Type:Syntax.Constant}),_extends({},n,{type:"i32",value:"0",Type:Syntax.Constant})]});return e(t)},ImmutableDeclaration:e=>t=>{const[n,r]=t;if(!r.locals&&"Memory"===n.type)return _extends({},n,{meta:_extends({},n.meta,{[GLOBAL_INDEX]:-1})});return e(t)}}}}}function Strings(){return{semantics:()=>({CharacterLiteral:e=>([e,t],n)=>{const r=e.value.codePointAt(0);return n([_extends({},e,{Type:"Constant",type:"i32",value:String(r)}),t])},StringLiteral:e=>e=>{const[t,n]=e;const{statics:r}=n;const{value:o}=t;o in r||(r[o]=null);return t}})}}function functionPointer(){return{semantics(){return{ImmutableDeclaration:e=>(function(t){const[n,r]=t;return r.locals||"Table"!==n.type?e(t):_extends({},n,{meta:_extends({},n.meta,{[GLOBAL_INDEX]:-1})})}),Identifier:e=>(function(t){const[n,r]=t,{functions:o,table:s,scopes:i}=r;return scope_4(i,n.value)||!o[n.value]?e(t):(null==s[n.value]&&(s[n.value]=o[n.value]),_extends({},n,{type:"i32",meta:{[FUNCTION_INDEX]:o[n.value].meta[FUNCTION_INDEX]},value:Object.keys(s).indexOf(n.value),Type:Syntax.FunctionPointer}))}),FunctionCall:e=>(function(t,n){const[r,o]=t,{scopes:s,types:i}=o,a=scope_4(s,r.value);if(!a)return e(t);const c=i[a.type],u=Object.keys(i).indexOf(a.type),p=[...r.params.slice(1),_extends({},a,{Type:Syntax.Identifier})].map(e=>n([e,o]));return _extends({},r,{meta:_extends({},r.meta,a.meta,{[TYPE_INDEX]:u}),type:null!=c?c.type:r.type,params:p,Type:Syntax.IndirectFunctionCall})})}}}}function Struct(){return{semantics(){return{Struct:e=>([e,{userTypes:t}])=>{const[n,r,o]=getByteOffsetsAndSize(e.params[0]);const s=_extends({},e,{meta:_extends({},e.meta,{[TYPE_OBJECT]:n,OBJECT_SIZE:r,[OBJECT_KEY_TYPES]:o})});t[s.value]=s;return s},FunctionResult:e=>(t,n)=>{const[r,o]=t;const{userTypes:s}=o;if(!s[r.type])return e(t);return e([extendNode({type:"i32",meta:{ALIAS:r.type},params:r.params.map(e=>n([e,o]))},r),o])},Identifier:e=>t=>{const[n,r]=t;const{userTypes:o,scopes:s}=r;const i=scope_4(s,n.value);if(!i||!o[i.type])return e(t);return _extends({},n,{meta:_extends({},n.meta,i.meta,{ALIAS:i.type}),type:"i32"})},ArraySubscript:e=>(t,n)=>{const[r,o]=t;const{userTypes:s,scopes:i}=o;const a=r.params.map(e=>n([e,o]));const[c,u]=a;const p=scope_4(i,c.value);const l=p&&s[p.type];if(null!=l){const e=l.meta[TYPE_OBJECT],t=l.meta[OBJECT_KEY_TYPES];return _extends({},r,{type:t[u.value],params:patchStringSubscript(e,a)})}return e(t)},Assignment:e=>(t,n)=>{const[r,o]=t;const[s,i]=r.params;if(!i||i.Type!==Syntax.ObjectLiteral)return e(t);const a={};const c={};walkNode({[Syntax.Identifier]:(e,t)=>{a[e.value]=_extends({},s,{Type:Syntax.MemoryAssignment,params:[_extends({},s,{Type:Syntax.ArraySubscript,params:[s,e]}),e]})},[Syntax.Pair]:(e,t)=>{const[n,r]=e.params;a[n.value]=_extends({},s,{Type:Syntax.MemoryAssignment,params:[_extends({},s,{Type:Syntax.ArraySubscript,params:[s,n]}),r]})},[Syntax.Spread]:(e,t)=>{const{scopes:n,userTypes:r}=o;const[i]=e.params;const a=r[scope_4(n,i.value).type];const u=a.meta[TYPE_OBJECT];Object.keys(u).forEach(e=>{const t=_extends({},i,{Type:Syntax.Identifier,value:e,params:[]});c[e]=_extends({},s,{Type:Syntax.MemoryAssignment,params:[_extends({},s,{Type:Syntax.ArraySubscript,params:[s,_extends({},t)]}),_extends({},i,{Type:Syntax.ArraySubscript,params:[i,_extends({},t)]})]})})}})(i);const u=Object.values(_extends({},c,a));return _extends({},s,{Type:Syntax.Block,params:u.map(e=>n([e,o]))})}}}}}function nativePlugin(){return{semantics(){return{ArraySubscripts:e=>(t,n)=>{const[r,o]=t;const[s,i]=r.params;if(s.Type===Syntax.Type&&i.Type===Syntax.FunctionCall)return _extends({},r,{Type:Syntax.NativeMethod,type:s.value,value:s.value+"."+i.value,params:i.params.map(e=>n([e,o]))});return e(t)},FunctionCall:e=>(t,n)=>{const[r,o]=t;const[s,...i]=r.params;if(s.Type===Syntax.ArraySubscript&&s.params[0]&&s.params[0].Type===Syntax.Type){const[e,t]=s.params;return extendNode({value:`${e.value}.${t.value}`,type:e.value,params:i.map(e=>n([e,o])),Type:Syntax.NativeMethod},r)}return e(t)}}}}}function defaultArguments(){return{grammar:grammar$1,semantics(){return{FunctionDeclaration:e=>t=>{const[n,r]=t;const[o]=n.params;const s=[];walkNode({Assignment:e=>{const[,t]=e.params;s.push(t)}})(o);return e([_extends({},n,{meta:_extends({},n.meta,{DEFAULT_ARGUMENTS:s})}),r])},Assignment:e=>(t,n)=>{const[r,o]=t;if(!o.isParsingArguments)return e(t);const[s]=r.params;return n([s,o])},FunctionCall:e=>t=>{const[n,r]=t;const{functions:o}=r;const[s,...i]=n.params;const a=o[s.value];if(!a)return e(t);const c=a.meta.FUNCTION_METADATA.argumentsCount;const u=i.length;const p=c-u;if(p>0)return e([_extends({},n,{params:[...n.params,...a.meta.DEFAULT_ARGUMENTS.slice(p-1)]}),r]);return e(t)}}}}}function sizeofPlugin(){return{semantics(){return{FunctionCall:e=>t=>{const[n,r]=t;if("sizeof"!==n.value)return e(t);const{scopes:o,userTypes:s,functions:i}=r;const[,a]=n.params;const c=scope_4(o,a.value);const{type:u=""}=c||{};const p=s[a.value]||s[u];const l=i[a.value];if(null!=p){const e=p.meta[OBJECT_SIZE];return invariant_1(e,"Object size information is missing"),_extends({},n,{value:e,params:[],type:"i32",Type:Syntax.Constant})}const m=c||l;return _extends({},n,{value:sizes$1[m?m.type:a.value]||4,type:"i32",params:[],Type:Syntax.Constant})}}}}}function hasNode(e,t){const n=t=>t&&t.Type===e,r=e=>{if(null==e)return!1;return n(e)||e.params.some(r)};return r(t)}function closures(){return{semantics:()=>{const e=e=>(t,n)=>{const[r,o]=t;const{environment:s,types:i}=o;if(!o.isParsingClosure||!s[r.value])return e(i[r.type]&&i[r.type].meta.CLOSURE_TYPE?[_extends({},r,{type:"i64",meta:_extends({},r.meta,{CLOSURE_INSTANCE:!0,ALIAS:r.type})}),o]:t);const a=e(t);s[a.value]=_extends({},a,{meta:_extends({},a.meta,{ENV_OFFSET:Object.values(o.envSize).reduce(sum,0)})});o.envSize[a.value]=sizes[a.type]||4;if(!a.params.length)return null;const[c]=a.params;const u=s[a.value];const p=fragment(`__closure_set_${u.type}(__env_ptr + ${u.meta.ENV_OFFSET})`);return n([_extends({},p,{params:[...p.params,c]}),o])};return{Program:e=>t=>{const[n,r]=t;if(!hasNode(Syntax.Closure,n))return e(t);const o=parse(`\n      // Start Closure Imports Header\n      import {\n        __closure_malloc: ClosureGeti32,\n        __closure_free: ClosureFree,\n        __closure_get_i32: ClosureGeti32,\n        __closure_get_f32: ClosureGetf32,\n        __closure_get_i64: ClosureGeti64,\n        __closure_get_f64: ClosureGetf64,\n        __closure_set_i32: ClosureSeti32,\n        __closure_set_f32: ClosureSetf32,\n        __closure_set_i64: ClosureSeti64,\n        __closure_set_f64: ClosureSetf64\n      } from 'walt-plugin-closure';\n      type ClosureFree = (i32) => void;\n      type ClosureGeti32 = (i32) => i32;\n      type ClosureGetf32 = (i32) => f32;\n      type ClosureGeti64 = (i32) => i64;\n      type ClosureGetf64 = (i32) => f64; type ClosureSeti32 = (i32, i32) => void;\n      type ClosureSetf32 = (i32, f32) => void;\n      type ClosureSeti64 = (i32, i64) => void;\n      type ClosureSetf64 = (i32, f64) => void;\n      // End Closure Imports Header\n    `).params;const s=[];const i=e([_extends({},n,{params:[...o,...n.params]}),_extends({},r,{closures:s})]);const a=_extends({},i,{params:[...i.params,...s]});return a},Closure:e=>(e,t)=>{const[n,r]=e;const[o]=n.params;const[s,i,...a]=o.params;const c=t([_extends({},o,{value:`__closure_${r.isParsingClosure}_0`,params:[_extends({},s,{params:[fragment("(__env_ptr : i32)"),...s.params]}),i,...a]}),r]);r.closures.push(c);return t([fragment(`(${c.value} | ((__env_ptr : i64) << 32))`),r])},FunctionDeclaration:e=>(t,n)=>{const[r,o]=t;const{globals:s}=o;if(o.isParsingClosure||!hasNode(Syntax.Closure,r))return e(t);const i={};const a={};walkNode({Closure(e,t){const n={__env_ptr:!0};walkNode({FunctionArguments(e,t){walkNode({Pair(e){const[t]=e.params;n[t.value]=t}})(e)},Declaration(e,t){n[e.value]=e},Identifier(e){n[e.value]||s[e.value]||(i[e.value]=e)}})(e)}})(r);const c=fragment("const __env_ptr : i32 = 0");const[u,p,...l]=r.params;const m=_extends({},o,{environment:i,envSize:a,isParsingClosure:r.value});const d=e([_extends({},r,{params:[u,p,c,...l]}),m]);d.params=d.params.map(e=>{if(e.Type===Syntax.Declaration&&"__env_ptr"===e.value){const e=Object.values(a).reduce(sum,0);return n([fragment(`const __env_ptr : i32 = __closure_malloc(${e})`),_extends({},o,{scopes:scope_1(o.scopes,LOCAL_INDEX)})])}return e});return d},Declaration:e,ImmutableDeclaration:e,FunctionResult:e=>t=>{const[n,r]=t;const{types:o}=r;if(o[n.type]&&o[n.type].meta.CLOSURE_TYPE)return e([_extends({},n,{type:"i64",value:"i64",meta:_extends({},n.meta,{ALIAS:n.type})}),r]);return e(t)},Assignment:e=>(t,n)=>{const[r,o]=t;const{scopes:s,environment:i}=o;const[a,c]=r.params;if(!o.isParsingClosure)return e(t);if(scope_3(s)[a.value])return e(t);const{type:u,meta:{ENV_OFFSET:p}}=i[a.value];const l=fragment(`__closure_set_${u}(__env_ptr + ${p})`);return n([_extends({},l,{params:[...l.params,c]}),o])},Identifier:e=>(t,n)=>{const[r,o]=t;const{environment:s}=o;if(!o.isParsingClosure||!s[r.value])return e(t);const{type:i,meta:{ENV_OFFSET:a}}=s[r.value];return n([fragment(`__closure_get_${i}(__env_ptr + ${a})`),o])},FunctionCall:e=>(t,n)=>{const[r,o]=t;const{scopes:s,types:i}=o;const a=scope_4(s,r.value);if(a&&a.meta.CLOSURE_INSTANCE){const e=[fragment(`((${a.value} >> 32) : i32)`),...r.params.slice(1),fragment(`(${a.value} : i32)`)].map(e=>n([e,o])),t=i[a.meta.ALIAS],s=Object.keys(i).indexOf(t.value),c=_extends({},r,{meta:_extends({},a.meta,r.meta,{TYPE_INDEX:s}),type:null!=t?t.type:r.type,params:e,Type:Syntax.IndirectFunctionCall});return c}return e(t)}}}}}function semantics(e,t=getBuiltInParsers()){const n={},r={},o={},s={},i={},a=[],c={},u=scope_1([],GLOBAL_INDEX),p={functions:n,globals:r,types:o,userTypes:s,table:i,hoist:a,statics:c,path:[],scopes:u},l=combineParsers(t.map(e=>e(p))),m=mapNode_1(l)([e,p]);return _extends({},m,{meta:_extends({},m.meta,{[AST_METADATA]:{functions:n,globals:u[0],types:o,userTypes:s,statics:c}}),params:[...m.params,...a]})}function generateErrorString(e,t,n,r,o){let s,i,a;return n.start.line!==n.end.line?(a=n.start.col+1,i=n.start.col,s=n.start.line):(s=n.start.line,i=n.start.col,a=n.end.col),"\n"+(()=>{if(n.start.sourceLine!==n.end.sourceLine)return n.start.sourceLine+"\n"+n.end.sourceLine;return n.end.sourceLine})()+"\n"+new Array(a-i+2).join("^").padStart(n.start.col-2," ")+` ${t}`+"\n"+e+"\n"+`  at ${o} (${r}:${s}:${i})`}function validate(e,{filename:t}){const n=e.meta[AST_METADATA];if(null==n)throw new Error("Missing AST metadata!");const{types:r,functions:o,userTypes:s}=n,i=[];walkNode({[Syntax.Export]:e=>{const n=e.params[0];const[r,o]=n.range;const s=n.meta[GLOBAL_INDEX];null==s||n.params.length||i.push(generateErrorString("Global exports must have a value","",{start:r,end:o},t,GLOBAL_LABEL))},[Syntax.Import]:(e,n)=>{walkNode({[Syntax.BinaryExpression]:(e,n)=>{const[r,o]=e.range;i.push(generateErrorString("Using an 'as' import without a type.","A type for original import "+e.params[0].value+" is not defined nor could it be inferred.",{start:r,end:o},t,GLOBAL_LABEL))},[Syntax.Identifier]:(e,n)=>{const[r,o]=e.range;i.push(generateErrorString("Infered type not supplied.","Looks like you'd like to infer a type, but it was never provided by a linker. Non-concrete types cannot be compiled.",{start:r,end:o},t,GLOBAL_LABEL))},[Syntax.Pair]:(e,n)=>{const o=e.params[1];if(!isBuiltinType(o.value)&&null==r[o.value]){const[e,n]=o.range;i.push(generateErrorString(`Undefined Type ${o.value}`,`Invalid Import. ${o.value} type does not exist`,{start:e,end:n},t,GLOBAL_LABEL))}}})(e)},[Syntax.Struct]:(e,t)=>{},[Syntax.ImmutableDeclaration]:(e,t)=>{},[Syntax.Declaration]:(e,n)=>{const[o,a]=e.range;const[c]=e.params;if(e.meta[TYPE_CONST]){const e=[Syntax.Constant,Syntax.StringLiteral];null==c||e.includes(c.Type)||i.push(generateErrorString("Global Constants must be initialized with a Number literal.","WebAssembly does not allow for non number literal constant initializers.",{start:o,end:a},t,GLOBAL_LABEL)),null==c&&i.push(generateErrorString("Constant declaration without an initializer.","Global constants must be initialized with a Number literal.",{start:o,end:a},t,GLOBAL_LABEL))}isBuiltinType(e.type)||r[e.type]||s[e.type]||i.push(generateErrorString("Unknown type used in a declaration, "+`"${String(e.type)}"`,"Variables must be assigned with a known type.",{start:o,end:a},t,GLOBAL_LABEL))},[Syntax.FunctionDeclaration]:(e,n)=>{const a=`${e.value}()`;walkNode({[Syntax.Declaration]:(e,n)=>{const[o,c]=e.range;const[u]=e.params;null!=u&&null!=waltSyntax_3[u.Type]&&i.push(generateErrorString(`Unexpected statement ${u.Type}`,"Attempting to assign a statement to a variable. Did you miss a semicolon(;)?",{start:o,end:c},t,a));e.meta[TYPE_CONST]&&null==u&&i.push(generateErrorString("Constant declaration without an initializer.","Local Constants must be initialized with an expression.",{start:o,end:c},t,a));isBuiltinType(e.type)||r[e.type]||s[e.type]||i.push(generateErrorString("Unknown type used in a declartion, "+`"${String(e.type)}"`,"Variables must be assigned with a known type.",{start:o,end:c},t,a))},[Syntax.Assignment]:e=>{const[n]=e.params;const[r,o]=e.range;const s=e.params.find(e=>null!=waltSyntax_3[e.Type]);null!=s&&i.push(generateErrorString("Unexpected statement in assignment","Statments cannot be used in assignment expressions. Did you miss a semicolon?",{start:s.range[0],end:s.range[1]},t,a));const c=n.meta[TYPE_CONST];c&&i.push(generateErrorString(`Cannot reassign a const variable ${n.value}`,"const variables cannot be reassigned, use let instead.",{start:r,end:o},t,a))},[Syntax.ArraySubscript]:(e,n)=>{const[r,o]=e.params;const[s,c]=e.range;if(null==o.value){const e=o.meta[ALIAS];i.push(generateErrorString("Cannot generate memory offset",`Undefined key ${null!=e?e:o.value} for type ${String(r.meta.ALIAS)}`,{start:s,end:c},t,a))}},[Syntax.ReturnStatement]:(n,r)=>{n.params.map(r);if(null==e.type)return;const[o]=n.params;const[s]=n.range;const c=null!=o?o.range[1]:n.range[1];const u=n.type;typeWeight(u)!==typeWeight(e.type)&&i.push(generateErrorString("Missing return value","Inconsistent return value. Expected "+e.type+" received "+String(u),{start:s,end:c},t,a))},[Syntax.FunctionCall]:(e,n)=>{if(null==o[e.value]){const[n,r]=e.range;i.push(generateErrorString("Undefined function reference",`${e.value} is not defined.`,{start:n,end:r},t,a))}},[Syntax.IndirectFunctionCall]:(e,n)=>{const o=e.params[e.params.length-1];const s=r[o.type];if(!isBuiltinType(o.type)&&null==s){const[n,r]=e.range;i.push(generateErrorString("Cannot make an indirect call without a valid function type",`${o.value} has type ${String(o.type)} which is not defined. Indirect calls must have pre-defined types.`,{start:n,end:r},t,a))}}})(e)}})(e);const a=i.length;if(a>0){const e=i.reduce((e,t)=>e+"\n"+`${t}\n`,`Cannot generate WebAssembly for ${t}. ${a} problems.\n`);throw new Error(e)}}function generateNoop(){return[]}function generateExport(e){const t=e.meta[FUNCTION_INDEX],n=e.meta[GLOBAL_INDEX];if(null!=n){const t=externaKindMap[String(e.type)]||EXTERN_GLOBAL,r=[EXTERN_MEMORY,EXTERN_TABLE].includes(t)?0:n;return{index:r,kind:t,field:e.value}}return{index:t,kind:EXTERN_FUNCTION,field:e.value}}function generateMemory$2(e){const t={max:0,initial:0,type:""};return walkNode({[Syntax.Pair]:({params:e})=>{const[{value:n},{value:r}]=e;"initial"===n?t.initial=parseInt(r):"element"===n?t.type=r:"max"===n&&(t.max=parseInt(r))}})(e),t}function generateImportFromNode(e){const[t,n]=e.params,{value:r}=n,o=[];return walkNode({[Syntax.Pair]:(e,t)=>{const[n,s]=e.params;const i=getFieldName(n);const{value:a}=s;const c=getKindConstant(a);const u=(()=>{const e=s.meta[TYPE_INDEX];if(e)return e;return null})();const p="Memory"===a?parseBounds(s):{};o.push(_extends({module:r,field:i,global:c===EXTERN_GLOBAL,kind:c,type:stringToType[a],typeIndex:u},p))}})(t),o}function generateType(e){const t=e.value;invariant_1("string"==typeof t,`Generator: A type must have a valid string identifier, node: ${JSON.stringify(e)}`);const[n,r]=e.params,o=[];return walkNode({[Syntax.Type]:(e,t)=>{o.push(getType$1(e.value))},[Syntax.Identifier]:(e,t)=>{o.push(getType$1(e.value))}})(n),{id:t,params:o,result:r.type&&"void"!==r.type?getType$1(r.type):null}}function*stringDecoder(e,t){let n=0,r=0,o=0,s=t;for(;;){const t=e.getUint8(s,!0);if(n|=(127&t)<<o,s+=1,0==(128&t))break;o+=7}let i=0;for(;r<n;){for(i=0,o=0;;){const t=e.getUint8(s,!0);if(i|=(127&t)<<o,s+=1,0==(128&t))break;o+=7}r+=1,yield i}}function stringEncoder(e){const t=new OutputStream,n=new OutputStream;n.push("varuint32",e.length,e);let r=0;for(r=0;r<e.length;r++)n.push("varuint32",e.codePointAt(r),e[r]);return t.write(n),t}function generateData(e,t){let n=t;const r={},o=Object.keys(e).reduce((e,t)=>{const o=stringEncoder(t);e.push({offset:Number(n),data:o});r[t]=n;n+=o.size;return e},[]),s=new OutputStream;return s.push(index_12,n,String(n)),{data:[{offset:0,data:s},...o],map:r}}function generator(e,t){const n={Version:t.version,Types:[],Start:[],Element:[],Code:[],Exports:[],Imports:[],Globals:[],Functions:[],Memory:[],Table:[],Artifacts:[],Data:[],Name:{module:t.filename,functions:[],locals:[]}};let{statics:r}=e.meta[AST_METADATA];null!=t.linker&&(r=_extends({},t.linker.statics,r));const{map:o,data:s}=generateData(r,DATA_SECTION_HEADER_SIZE);Object.keys(r).length>0&&(n.Data=s);const i=e=>{const t=generateImplicitFunctionType(e);return n.Types.findIndex(e=>{const n=e.params.length===t.params.length&&e.params.reduce((e,n,r)=>e&&n===t.params[r],!0);const r=e.result===t.result;return n&&r})},a=e=>n.Element.findIndex(t=>t.functionIndex===e),c={},u=mapNode_2({[Syntax.Typedef]:(e,t)=>{let r=n.Types.findIndex(({id:t})=>t===e.value);let o=n.Types[r];null==o&&(r=n.Types.length,n.Types.push(generateType(e)));o=_extends({},e,{meta:_extends({},e.meta,{[TYPE_INDEX]:r})});c[e.value]={typeIndex:r,typeNode:o};return o}})(mapNode_2({[Syntax.Import]:(e,t)=>e,[Syntax.StringLiteral]:(e,t)=>{if(0===Object.keys(r).length)return e;const{value:n}=e;return _extends({},e,{value:String(o[n]),Type:Syntax.Constant})}})(e));return walkNode({[Syntax.Typedef]:(e,t)=>e,[Syntax.Export]:e=>{const[t]=e.params;n.Exports.push(generateExport(t))},[Syntax.ImmutableDeclaration]:e=>{const t=e.meta[GLOBAL_INDEX];if(null!=t)switch(e.type){case"Memory":n.Memory.push(generateMemory(e));break;case"Table":n.Table.push(generateMemory$2(e))}},[Syntax.Declaration]:e=>{const t=e.meta[GLOBAL_INDEX];null!=t&&n.Globals.push(generateInit(e))},[Syntax.Import]:e=>{n.Imports.push(...generateImportFromNode(e))},[Syntax.FunctionDeclaration]:e=>{const r=(()=>{const t=i(e);if(-1===t)return n.Types.push(generateImplicitFunctionType(e)),n.Types.length-1;return t})();const o=mapNode_2({FunctionPointer(e){const t=e.meta[FUNCTION_INDEX];let r=a(t);return r<0&&(r=n.Element.length,n.Element.push(generateElement(t))),e}})(e);const s=e.meta[FUNCTION_INDEX];invariant_1(null!=s,"Function index must be set");n.Functions[s]=r;n.Code[s]=generateCode(o);"start"===o.value&&n.Start.push(s);if(t.encodeNames){n.Name.functions.push({index:s,name:e.value});const t=e.meta[FUNCTION_METADATA];null!=t&&Object.keys(t.locals).length&&(n.Name.locals[s]={index:s,locals:Object.entries(t.locals).map(([e,t])=>({name:e,index:Number(t.meta["local/index"])}))})}}})(u),n.Code=n.Code.filter(Boolean),n}function write(e){return(new OutputStream).push(index_12,MAGIC,"\\0asm").push(index_12,e,`version ${e}`)}function emitString(e,t,n){e.push(varuint32,t.length,n);for(let n=0;n<t.length;n++)e.push(index_9,t.charCodeAt(n),t[n]);return e}function emitTables(e){const t=new OutputStream;return e.length&&t.push(varuint32,e[0],"start function"),t}function emitTables$1(e){const t=new OutputStream;return t.push(varuint32,e.length,"count"),e.forEach(e=>emitEntry$1(t,e)),t}function emit$9(e){const t=new OutputStream;t.push(varuint32,e.length,"entries");for(let n=0,r=e.length;n<r;n++){const r=e[n];emitDataSegment(t,r)}return t}function emit(e,t){const n=(new OutputStream).write(write(e.Version)).write(section.type(e)).write(section.imports(e)).write(section.function(e)).write(section.table(e)).write(section.memory(e)).write(section.globals(e)).write(section.exports(e)).write(section.start(e)).write(section.element(e)).write(section.code(e)).write(section.data(e));return t.encodeNames?n.write(section.name(e)):n}function closurePlugin$$1(){return compileWalt(source,{version:1,encodeNames:!1,filename:"walt-closure-plugin",lines:source.split("\n")})}function compileWalt(e,t){const n=getIR(e,t);return console.log(_debug(n)),n.buffer()}var immutable=extend,hasOwnProperty=Object.prototype.hasOwnProperty;const identity=e=>e;var mapNode_1$1={map:map,mapNode:mapNode$2},mapNode=mapNode_1$1,mapNode_1=mapNode.map,mapNode_2=mapNode.mapNode,NODE_ENV="production",invariant=function(e,t,n,r,o,s,i,a){if("production"!==NODE_ENV&&void 0===t)throw new Error("invariant requires an error message argument");if(!e){var c;if(void 0===t)c=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var u=[n,r,o,s,i,a],p=0;(c=new Error(t.replace(/%s/g,function(){return u[p++]}))).name="Invariant Violation"}throw c.framesToPop=1,c}},invariant_1=invariant,commonjsGlobal="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},waltSyntax=createCommonjsModule(function(e,t){!function(e,n){n(t)}(0,function(e){const t={whitespace:/[ \t]+/,comment:[{match:/\/\/.*?$/},{match:/\/\*.*?\*\//}],number:[{match:/0[xX][0-9a-fA-F]+/},{match:/0[oO][0-9]+/},{match:/0[bB][01]+/},{match:/(?:[0-9]+(?:\.[0-9]+)?e-?[0-9]+)/},{match:/[0-9]+\.[0-9]+|[0-9]+/}],char:[{match:/'(?:\\['\\bfnrtv0]|[^'\\\n])'/,value:e=>e.slice(1,-1)}],string:[{match:/"(?:\\["\\rn]|[^"\\\n])*?"/,value:e=>e.slice(1,-1)},{match:/'(?:\\['\\bfnrtv0]|[^'\\\n])*?'/,value:e=>e.slice(1,-1)},{match:/`(?:\\['\\bfnrtv0]|[^'\\])*?`/,value:e=>e.slice(1,-1)}],identifier:{match:/[A-Za-z_$][A-Za-z0-9_$]*/,keywords:{keyword:["break","if","else","import","as","from","export","return","switch","case","default","const","let","for","continue","do","while","function","global","module","type","lambda"],type:["i32","i64","f32","f64","bool"]}},punctuator:["+","++","-","--",">>",">>>","<<","=","==","+=","-=","=>","<=",">=","!=","%","*","/","^","&","~","|","!","**",":","(",")",".","{","}",",","[","]",";",">","<","?","||","&&","{","}","..."],newline:{match:/\n/,lineBreaks:!0}},n={i32:"i32",f32:"f32",i64:"i64",f64:"f64",Memory:"Memory",Table:"Table",bool:"bool"},r={Program:"Program",Export:"Export",Import:"Import",IfThenElse:"IfThenElse",Else:"Else",Declaration:"Declaration",ImmutableDeclaration:"ImmutableDeclaration",FunctionDeclaration:"FunctionDeclaration",ArrayDeclaration:"ArrayDeclaration",Loop:"Loop",MemoryAssignment:"MemoryAssignment",Assignment:"Assignment",Typedef:"Typedef",Struct:"Struct",ReturnStatement:"ReturnStatement",Sequence:"Sequence",ObjectLiteral:"ObjectLiteral",Pair:"Pair",Break:"Break",Comment:"Comment",Sizeof:"Sizeof",Spread:"Spread",Noop:"Noop",Block:"Block"};var o={Program:"Program",Keyword:"Keyword",Export:"Export",Import:"Import",Statement:"Statement",IfThenElse:"IfThenElse",Select:"Select",Else:"Else",UnaryExpression:"UnaryExpression",BinaryExpression:"BinaryExpression",TernaryExpression:"TernaryExpression",NumberLiteral:"NumberLiteral",StringLiteral:"StringLiteral",CharacterLiteral:"CharacterLiteral",Punctuator:"Punctuator",Identifier:"Identifier",ArraySubscript:"ArraySubscript",Constant:"Constant",Type:"Type",GenericType:"GenericType",UserType:"UserType",FunctionType:"FunctionType",Declaration:"Declaration",ImmutableDeclaration:"ImmutableDeclaration",FunctionDeclaration:"FunctionDeclaration",ArrayDeclaration:"ArrayDeclaration",IndirectFunctionCall:"IndirectFunctionCall",FunctionCall:"FunctionCall",Loop:"Loop",MemoryAssignment:"MemoryAssignment",Assignment:"Assignment",Param:"Param",Typedef:"Typedef",Struct:"Struct",ReturnStatement:"ReturnStatement",Sequence:"Sequence",ObjectLiteral:"ObjectLiteral",Pair:"Pair",TypeCast:"TypeCast",Break:"Break",Comment:"Comment",Sizeof:"Sizeof",Spread:"Spread",Closure:"Closure",Noop:"Noop",ClosureType:"ClosureType",Block:"Block",ObjectField:"ObjectField",FunctionIndex:"FunctionIndex",FunctionIdentifier:"FunctionIdentifier",FunctionPointer:"FunctionPointer",FunctionArguments:"FunctionArguments",FunctionResult:"FunctionResult",FunctionLocals:"FunctionLocals",NativeMethod:"NativeMethod"};e.Program="Program",e.Keyword="Keyword",e.Export="Export",e.Import="Import",e.Statement="Statement",e.IfThenElse="IfThenElse",e.Select="Select",e.Else="Else",e.UnaryExpression="UnaryExpression",e.BinaryExpression="BinaryExpression",e.TernaryExpression="TernaryExpression",e.NumberLiteral="NumberLiteral",e.StringLiteral="StringLiteral",e.CharacterLiteral="CharacterLiteral",e.Punctuator="Punctuator",e.Identifier="Identifier",e.ArraySubscript="ArraySubscript",e.Constant="Constant",e.Type="Type",e.GenericType="GenericType",e.UserType="UserType",e.FunctionType="FunctionType",e.Declaration="Declaration",e.ImmutableDeclaration="ImmutableDeclaration",e.FunctionDeclaration="FunctionDeclaration",e.ArrayDeclaration="ArrayDeclaration",e.IndirectFunctionCall="IndirectFunctionCall",e.FunctionCall="FunctionCall",e.Loop="Loop",e.MemoryAssignment="MemoryAssignment",e.Assignment="Assignment",e.Param="Param",e.Typedef="Typedef",e.Struct="Struct",e.ReturnStatement="ReturnStatement",e.Sequence="Sequence",e.ObjectLiteral="ObjectLiteral",e.Pair="Pair",e.TypeCast="TypeCast",e.Break="Break",e.Comment="Comment",e.Sizeof="Sizeof",e.Spread="Spread",e.Closure="Closure",e.Noop="Noop",e.ClosureType="ClosureType",e.Block="Block",e.ObjectField="ObjectField",e.FunctionIndex="FunctionIndex",e.FunctionIdentifier="FunctionIdentifier",e.FunctionPointer="FunctionPointer",e.FunctionArguments="FunctionArguments",e.FunctionResult="FunctionResult",e.FunctionLocals="FunctionLocals",e.NativeMethod="NativeMethod",e.i32="i32",e.f32="f32",e.i64="i64",e.f64="f64",e.Memory="Memory",e.Table="Table",e.bool="bool",e.builtinTypes=n,e.statements=r,e.default=o,e.tokens=t,Object.defineProperty(e,"__esModule",{value:!0})})}),Syntax=unwrapExports(waltSyntax),waltSyntax_1=waltSyntax.semantics,waltSyntax_2=waltSyntax.builtinTypes,waltSyntax_3=waltSyntax.statements,waltSyntax_4=waltSyntax.i32,waltSyntax_5=waltSyntax.f32,waltSyntax_6=waltSyntax.i64,waltSyntax_7=waltSyntax.f64,waltSyntax_8=waltSyntax.tokens,moo=createCommonjsModule(function(module){!function(e,t){module.exports?module.exports=t():e.moo=t()}(commonjsGlobal,function(){function isRegExp(e){return e&&e.constructor===RegExp}function isObject(e){return e&&"object"==typeof e&&e.constructor!==RegExp&&!Array.isArray(e)}function reEscape(e){return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}function reGroups(e){return new RegExp("|"+e).exec("").length-1}function reCapture(e){return"("+e+")"}function reUnion(e){return"(?:"+e.map(function(e){return"(?:"+e+")"}).join("|")+")"}function regexpOrLiteral(e){if("string"==typeof e)return"(?:"+reEscape(e)+")";if(isRegExp(e)){if(e.ignoreCase)throw new Error("RegExp /i flag not allowed");if(e.global)throw new Error("RegExp /g flag is implied");if(e.sticky)throw new Error("RegExp /y flag is implied");if(e.multiline)throw new Error("RegExp /m flag is implied");return e.source}throw new Error("not a pattern: "+e)}function objectToRules(e){for(var t=Object.getOwnPropertyNames(e),n=[],r=0;r<t.length;r++){var o=t[r],s=e[o],i=[];(Array.isArray(s)?s:[s]).forEach(function(e){isObject(e)?(i.length&&n.push(ruleOptions(o,i)),n.push(ruleOptions(o,e)),i=[]):i.push(e)}),i.length&&n.push(ruleOptions(o,i))}return n}function arrayToRules(e){for(var t=[],n=0;n<e.length;n++){var r=e[n];if(!r.name)throw new Error("Rule has no name: "+JSON.stringify(r));t.push(ruleOptions(r.name,r))}return t}function ruleOptions(e,t){("object"!=typeof t||Array.isArray(t)||isRegExp(t))&&(t={match:t});var n=assign({tokenType:e,lineBreaks:!!t.error,pop:!1,next:null,push:null,error:!1,value:null,getType:null},t),r=n.match;return n.match=Array.isArray(r)?r:r?[r]:[],n.match.sort(function(e,t){return isRegExp(e)&&isRegExp(t)?0:isRegExp(t)?-1:isRegExp(e)?1:t.length-e.length}),n.keywords&&(n.getType=keywordTransform(n.keywords)),n}function compileRules(e,t){e=Array.isArray(e)?arrayToRules(e):objectToRules(e);for(var n=null,r=[],o=[],s=0;s<e.length;s++){var i=e[s];if(i.error){if(n)throw new Error("Multiple error rules not allowed: (for token '"+i.tokenType+"')");n=i}if(0!==i.match.length){r.push(i);var a=reUnion(i.match.map(regexpOrLiteral)),c=new RegExp(a);if(c.test(""))throw new Error("RegExp matches empty string: "+c);if(reGroups(a)>0)throw new Error("RegExp has capture groups: "+c+"\nUse (?: … ) instead");if(!t&&(i.pop||i.push||i.next))throw new Error("State-switching options are not allowed in stateless lexers (for token '"+i.tokenType+"')");if(!i.lineBreaks&&c.test("\n"))throw new Error("Rule should declare lineBreaks: "+c);o.push(reCapture(a))}}var u=hasSticky?"":"|(?:)",p=hasSticky?"ym":"gm";return{regexp:new RegExp(reUnion(o)+u,p),groups:r,error:n}}function compile(e){var t=compileRules(e);return new Lexer({start:t},"start")}function compileStates(e,t){var n=Object.getOwnPropertyNames(e);t||(t=n[0]);for(var r=Object.create(null),o=0;o<n.length;o++){var s=n[o];r[s]=compileRules(e[s],!0)}for(o=0;o<n.length;o++)for(var i=r[n[o]].groups,a=0;a<i.length;a++){var c=i[a],u=c&&(c.push||c.next);if(u&&!r[u])throw new Error("Missing state '"+u+"' (in token '"+c.tokenType+"' of state '"+n[o]+"')");if(c&&c.pop&&1!=+c.pop)throw new Error("pop must be 1 (in token '"+c.tokenType+"' of state '"+n[o]+"')")}return new Lexer(r,t)}function keywordTransform(map){function str(e){return JSON.stringify(e)}for(var reverseMap=Object.create(null),byLength=Object.create(null),types=Object.getOwnPropertyNames(map),i=0;i<types.length;i++){var tokenType=types[i],item=map[tokenType],keywordList=Array.isArray(item)?item:[item];keywordList.forEach(function(e){if((byLength[e.length]=byLength[e.length]||[]).push(e),"string"!=typeof e)throw new Error("keyword must be string (in keyword '"+tokenType+"')");reverseMap[e]=tokenType})}var source="";source+="(function(value) {\n",source+="switch (value.length) {\n";for(var length in byLength){var keywords=byLength[length];source+="case "+length+":\n",source+="switch (value) {\n",keywords.forEach(function(e){var t=reverseMap[e];source+="case "+str(e)+": return "+str(t)+"\n"}),source+="}\n"}return source+="}\n",source+="})",eval(source)}function tokenToString(){return this.value}var hasOwnProperty=Object.prototype.hasOwnProperty,assign="function"==typeof Object.assign?Object.assign:function(e,t){if(null==e)throw new TypeError("Target cannot be null or undefined");e=Object(e);for(var n=1;n<arguments.length;n++){var r=arguments[n];if(null!=r)for(var o in r)hasOwnProperty.call(r,o)&&(e[o]=r[o])}return e},hasSticky="boolean"==typeof(new RegExp).sticky,Lexer=function(e,t){this.startState=t,this.states=e,this.buffer="",this.stack=[],this.reset()};if(Lexer.prototype.reset=function(e,t){return this.buffer=e||"",this.index=0,this.line=t?t.line:1,this.col=t?t.col:1,this.setState(t?t.state:this.startState),this},Lexer.prototype.save=function(){return{line:this.line,col:this.col,state:this.state}},Lexer.prototype.setState=function(e){if(e&&this.state!==e){this.state=e;var t=this.states[e];this.groups=t.groups,this.error=t.error||{lineBreaks:!0,shouldThrow:!0},this.re=t.regexp}},Lexer.prototype.popState=function(){this.setState(this.stack.pop())},Lexer.prototype.pushState=function(e){this.stack.push(this.state),this.setState(e)},Lexer.prototype._eat=hasSticky?function(e){return e.exec(this.buffer)}:function(e){var t=e.exec(this.buffer);return 0===t[0].length?null:t},Lexer.prototype._getGroup=function(e){if(null===e)return-1;for(var t=this.groups.length,n=0;n<t;n++)if(void 0!==e[n+1])return n;throw new Error("oops")},Lexer.prototype.next=function(){var e=this.re,t=this.buffer,n=e.lastIndex=this.index;if(n!==t.length){var r,o,s=this._eat(e),i=this._getGroup(s);-1===i?(r=this.error,o=t.slice(n)):(o=s[0],r=this.groups[i]);var a=0;if(r.lineBreaks){var c=/\n/g,u=1;if("\n"===o)a=1;else for(;c.exec(o);)a++,u=c.lastIndex}var p={type:r.getType&&r.getType(o)||r.tokenType,value:r.value?r.value(o):o,text:o,toString:tokenToString,offset:n,lineBreaks:a,line:this.line,col:this.col},l=o.length;if(this.index+=l,this.line+=a,0!==a?this.col=l-u+1:this.col+=l,r.shouldThrow)throw new Error(this.formatError(p,"invalid syntax"));return r.pop?this.popState():r.push?this.pushState(r.push):r.next&&this.setState(r.next),p}},"undefined"!=typeof Symbol&&Symbol.iterator){var LexerIterator=function(e){this.lexer=e};LexerIterator.prototype.next=function(){var e=this.lexer.next();return{value:e,done:!e}},LexerIterator.prototype[Symbol.iterator]=function(){return this},Lexer.prototype[Symbol.iterator]=function(){return new LexerIterator(this)}}return Lexer.prototype.formatError=function(e,t){var n=e.value,r=e.offset,o=e.lineBreaks?n.indexOf("\n"):n.length,s=Math.max(0,r-e.col+1),i=this.buffer.substring(s,r+o);return t+=" at line "+e.line+" col "+e.col+":\n\n",t+="  "+i+"\n",t+="  "+Array(e.col).join(" ")+"^"},Lexer.prototype.clone=function(){return new Lexer(this.states,this.state)},Lexer.prototype.has=function(e){for(var t in this.states)for(var n=this.states[t].groups,r=0;r<n.length;r++){var o=n[r];if(o.tokenType===e)return!0;if(o.keywords&&hasOwnProperty.call(o.keywords,e))return!0}return!1},{compile:compile,states:compileStates,error:Object.freeze({error:!0})}})}),_extends=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},objectWithoutProperties=function(e,t){var n={};for(var r in e)t.indexOf(r)>=0||Object.prototype.hasOwnProperty.call(e,r)&&(n[r]=e[r]);return n},nearley=createCommonjsModule(function(e){!function(t,n){e.exports?e.exports=n():t.nearley=n()}(commonjsGlobal,function(){function e(t,n,r){return this.id=++e.highestId,this.name=t,this.symbols=n,this.postprocess=r,this}function t(e,t,n,r){this.rule=e,this.dot=t,this.reference=n,this.data=[],this.wantedBy=r,this.isComplete=this.dot===e.symbols.length}function n(e,t){this.grammar=e,this.index=t,this.states=[],this.wants={},this.scannable=[],this.completed={}}function r(e,t){this.rules=e,this.start=t||this.rules[0].name;var n=this.byName={};this.rules.forEach(function(e){n.hasOwnProperty(e.name)||(n[e.name]=[]),n[e.name].push(e)})}function o(){this.reset("")}function s(e,t,s){if(e instanceof r)var i=e,s=t;else i=r.fromCompiled(e,t);this.grammar=i,this.options={keepHistory:!1,lexer:i.lexer||new o};for(var a in s||{})this.options[a]=s[a];this.lexer=this.options.lexer,this.lexerState=void 0;var c=new n(i,0);this.table=[c];c.wants[i.start]=[],c.predict(i.start),c.process(),this.current=0}return e.highestId=0,e.prototype.toString=function(e){function t(e){return e.literal?JSON.stringify(e.literal):e.type?"%"+e.type:e.toString()}var n=void 0===e?this.symbols.map(t).join(" "):this.symbols.slice(0,e).map(t).join(" ")+" ● "+this.symbols.slice(e).map(t).join(" ");return this.name+" → "+n},t.prototype.toString=function(){return"{"+this.rule.toString(this.dot)+"}, from: "+(this.reference||0)},t.prototype.nextState=function(e){var n=new t(this.rule,this.dot+1,this.reference,this.wantedBy);return n.left=this,n.right=e,n.isComplete&&(n.data=n.build()),n},t.prototype.build=function(){var e=[],t=this;do{e.push(t.right.data),t=t.left}while(t.left);return e.reverse(),e},t.prototype.finish=function(){this.rule.postprocess&&(this.data=this.rule.postprocess(this.data,this.reference,s.fail))},n.prototype.process=function(e){for(var t=this.states,n=this.wants,r=this.completed,o=0;o<t.length;o++){var i=t[o];if(i.isComplete){if(i.finish(),i.data!==s.fail){for(var a=i.wantedBy,c=a.length;c--;){var u=a[c];this.complete(u,i)}if(i.reference===this.index){var p=i.rule.name;(this.completed[p]=this.completed[p]||[]).push(i)}}}else{if("string"!=typeof(p=i.rule.symbols[i.dot])){this.scannable.push(i);continue}if(n[p]){if(n[p].push(i),r.hasOwnProperty(p))for(var l=r[p],c=0;c<l.length;c++){var m=l[c];this.complete(i,m)}}else n[p]=[i],this.predict(p)}}},n.prototype.predict=function(e){for(var n=this.grammar.byName[e]||[],r=0;r<n.length;r++){var o=n[r],s=this.wants[e],i=new t(o,0,this.index,s);this.states.push(i)}},n.prototype.complete=function(e,t){var n=e.nextState(t);this.states.push(n)},r.fromCompiled=function(t,n){var o=t.Lexer;t.ParserStart&&(n=t.ParserStart,t=t.ParserRules);var s=new r(t=t.map(function(t){return new e(t.name,t.symbols,t.postprocess)}),n);return s.lexer=o,s},o.prototype.reset=function(e,t){this.buffer=e,this.index=0,this.line=t?t.line:1,this.lastLineBreak=t?-t.col:0},o.prototype.next=function(){if(this.index<this.buffer.length){var e=this.buffer[this.index++];return"\n"===e&&(this.line+=1,this.lastLineBreak=this.index),{value:e}}},o.prototype.save=function(){return{line:this.line,col:this.index-this.lastLineBreak}},o.prototype.formatError=function(e,t){var n=this.buffer;if("string"==typeof n){var r=n.indexOf("\n",this.index);-1===r&&(r=n.length);var o=n.substring(this.lastLineBreak,r),s=this.index-this.lastLineBreak;return t+=" at line "+this.line+" col "+s+":\n\n",t+="  "+o+"\n",t+="  "+Array(s).join(" ")+"^"}return t+" at index "+(this.index-1)},s.fail={},s.prototype.feed=function(e){var t=this.lexer;t.reset(e,this.lexerState);for(var r;r=t.next();){var s=this.table[this.current];this.options.keepHistory||delete this.table[this.current-1];var i=this.current+1,a=new n(this.grammar,i);this.table.push(a);for(var c=void 0!==r.text?r.text:r.value,u=t.constructor===o?r.value:r,p=s.scannable,l=p.length;l--;){var m=p[l],d=m.rule.symbols[m.dot];if(d.test?d.test(u):d.type?d.type===r.type:d.literal===c){var _=m.nextState({data:u,token:r,isToken:!0,reference:i-1});a.states.push(_)}}if(a.process(),0===a.states.length){var f=this.lexer.formatError(r,"invalid syntax")+"\n";f+="Unexpected "+(r.type?r.type+" token: ":""),f+=JSON.stringify(void 0!==r.value?r.value:r)+"\n";var y=new Error(f);throw y.offset=this.current,y.token=r,y}this.options.keepHistory&&(s.lexerState=t.save()),this.current++}return s&&(this.lexerState=t.save()),this.results=this.finish(),this},s.prototype.save=function(){var e=this.table[this.current];return e.lexerState=this.lexerState,e},s.prototype.restore=function(e){var t=e.index;this.current=t,this.table[t]=e,this.table.splice(t+1),this.lexerState=e.lexerState,this.results=this.finish()},s.prototype.rewind=function(e){if(!this.options.keepHistory)throw new Error("set option `keepHistory` to enable rewinding");this.restore(this.table[e])},s.prototype.finish=function(){var e=[],t=this.grammar.start;return this.table[this.table.length-1].states.forEach(function(n){n.rule.name===t&&n.dot===n.rule.symbols.length&&0===n.reference&&n.data!==s.fail&&e.push(n)}),e.map(function(e){return e.data})},{Parser:s,Grammar:r,Rule:e}})}),nearley_1=nearley.Parser,nearley_2=nearley.Grammar;const combineMiddleware=e=>{let t;const n=e.reduce((e,n)=>n(n=>e(n,t)),([e])=>e);return(e,r)=>{t=r;return n(e,t)}},combineParsers=(e=[])=>{const t=[];const n=e.reduce((e,n)=>{Object.entries(n).forEach(([n,r])=>{if("*"===n)return void t.push(r);null==e[n]&&(e[n]=[...t]);e[n].push(r)});return e},{});return Object.entries(n).reduce((e,[t,n])=>{e[t]=combineMiddleware(n);return e},{})},namespace$1=Symbol("scope namespace");var scope$2={enter:enter$1,exit:exit$1,add:add$1,find:find$1,current:current$1,index:index$1,namespace:namespace$1};const{enter:enter,exit:exit,add:add,find:find,current:current,namespace:namespace,index:index}=scope$2;var scope={enter:enter,exit:exit,add:add,find:find,current:current,namespace:namespace,index:index},scope_1=scope.enter,scope_2=scope.exit,scope_3=scope.current,scope_4=scope.find,scope_5=scope.add,scope_6=scope.index,scope_7=scope.namespace;const FUNCTION_INDEX="function/index",LOCAL_INDEX="local/index",GLOBAL_INDEX="global/index",TYPE_CONST="type/const",TYPE_ARRAY="type/array",TYPE_OBJECT="type/object",TYPE_INDEX="TYPE_INDEX",OBJECT_SIZE="OBJECT_SIZE",TYPE_CAST="type/cast",OBJECT_KEY_TYPES="object/key-types",AST_METADATA="AST_METADATA",FUNCTION_METADATA="FUNCTION_METADATA",ALIAS="alias";var slice=Array.prototype.slice,toArray$1=function(e){return slice.call(e)},tail=function(e){return slice.call(e,1)},createFn=function(e,t,n){var r=n-t.length;switch(r){case 0:return function(){return processInvocation(e,concatArgs(t,arguments),n)};case 1:return function(r){return processInvocation(e,concatArgs(t,arguments),n)};case 2:return function(r,o){return processInvocation(e,concatArgs(t,arguments),n)};case 3:return function(r,o,s){return processInvocation(e,concatArgs(t,arguments),n)};case 4:return function(r,o,s,i){return processInvocation(e,concatArgs(t,arguments),n)};case 5:return function(r,o,s,i,a){return processInvocation(e,concatArgs(t,arguments),n)};case 6:return function(r,o,s,i,a,c){return processInvocation(e,concatArgs(t,arguments),n)};case 7:return function(r,o,s,i,a,c,u){return processInvocation(e,concatArgs(t,arguments),n)};case 8:return function(r,o,s,i,a,c,u,p){return processInvocation(e,concatArgs(t,arguments),n)};case 9:return function(r,o,s,i,a,c,u,p,l){return processInvocation(e,concatArgs(t,arguments),n)};case 10:return function(r,o,s,i,a,c,u,p,l,m){return processInvocation(e,concatArgs(t,arguments),n)};default:return createEvalFn(e,t,r)}},concatArgs=function(e,t){return e.concat(toArray$1(t))},createEvalFn=function(fn,args,arity){var argList=makeArgList(arity),fnStr="false||function("+argList+"){ return processInvocation(fn, concatArgs(args, arguments)); }";return eval(fnStr)},makeArgList=function(e){for(var t=[],n=0;n<e;n+=1)t.push("a"+n.toString());return t.join(",")},trimArrLength=function(e,t){return e.length>t?e.slice(0,t):e},processInvocation=function(e,t,n){return t=trimArrLength(t,n),t.length===n?e.apply(null,t):createFn(e,t,n)},curry=function(e){return createFn(e,[],e.length)};curry.to=curry(function(e,t){return createFn(t,[],e)}),curry.adaptTo=curry(function(e,t){return curry.to(e,function(e){var n=tail(arguments).concat(e);return t.apply(this,n)})}),curry.adapt=function(e){return curry.adaptTo(e.length,e)};var curry_1=curry;const extendNode=curry_1((e,t)=>{let{meta:n}=e,r=objectWithoutProperties(e,["meta"]);return _extends({},t,{meta:_extends({},t.meta,n)},r)}),sizes={i64:8,f64:8,i32:4,f32:4},typeWeight=e=>{switch(e){case"i32":case"bool":return 0;case"i64":return 1;case"f32":return 2;case"f64":return 3;default:return-1}},balanceTypesInMathExpression=e=>{const t=e.params.reduce((e,{type:t})=>{if(typeWeight(e)<typeWeight(t))return t;return e},e.type);const n=e.params.map(e=>{if(null!=e.type&&typeWeight(e.type)!==typeWeight(t))return _extends({},e,{type:t,value:e.value,Type:Syntax.TypeCast,meta:_extends({},e.meta,{[TYPE_CAST]:{to:t,from:e.type}}),params:[e]});return e});return _extends({},e,{params:n,type:t})};var walkNode$2=function(e){const t=n=>{if(null==n)return n;const{params:r}=n;const o=(()=>{if("*"in e&&"function"==typeof e["*"])return e["*"];if(n.Type in e&&"function"==typeof e[n.Type])return e[n.Type];return()=>n})();if(2===o.length)return o(n,t),n;o(n);r.forEach(t);return n};return t},walkNode=walkNode$2;const mapGeneric=curry_1((e,t,n)=>{const{types:r}=e;const[o]=t.params;const[s]=o.params;const i=r[s.value];const[a,c]=i.params;const u=_extends({},i,{range:o.range,value:t.value,meta:_extends({},i.meta,{CLOSURE_TYPE:"Lambda"===o.value}),params:[_extends({},a,{params:[_extends({},a,{params:[],type:"i32",value:"i32",Type:Syntax.Type}),...a.params]}),c]});r[u.value]=u;return u}),fragment=e=>{const t=parse(`function fragment() {\n    ${e};\n  }`);return t.params[0].params[2].params[0]},shifts={i64:63,f64:63,i32:31,f32:32},getByteOffsetsAndSize=e=>{const t={};const n={};let r=0;walkNode({[Syntax.Pair]:e=>{const{value:o}=e.params[0];const{value:s}=e.params[1];invariant_1(null==t[o],`Duplicate key ${o} not allowed in object type`);n[o]=s;t[o]=r;switch(s){case"i64":case"f64":r+=8;break;case"i32":case"f32":default:r+=4}}})(e);return[t,r,n]},patchStringSubscript=(e,t)=>{const n=t[1];const r=e[n.value];return[t[0],_extends({},n,{meta:{[ALIAS]:n.value},value:r,type:"i32",Type:Syntax.Constant})]},sizes$1={i64:8,f64:8,i32:4,f32:4},sum=(e,t)=>e+t,getBuiltInParsers=()=>[base().semantics,Core().semantics,Imports().semantics,typePlugin().semantics,unary().semantics,coreFunctionPlugin().semantics,booleanPlugin().semantics,arrayPlugin().semantics,memoryPlugin().semantics,Strings().semantics,functionPointer().semantics,Struct().semantics,nativePlugin().semantics,sizeofPlugin().semantics,defaultArguments().semantics,closures().semantics],i32=1,i64=2,f32=4,f64=8,anyfunc=16,func=32,block_type=64,i8=128,u8=256,i16=512,u16=1024,u32=2048,u64=4096,word=4,sizeof={[i32]:word,[i64]:2*word,[f32]:word,[f64]:2*word,[u32]:word,[u16]:word>>1,[u8]:word>>2,[i8]:word>>2,[i16]:word>>1,[anyfunc]:word,[func]:word,[block_type]:word},LITTLE_ENDIAN=!0,get$1=(e,t,n)=>{switch(e){case i32:return n.getInt32(t,LITTLE_ENDIAN);case i64:return n.getInt64(t,LITTLE_ENDIAN);case f32:return n.getFloat32(t,LITTLE_ENDIAN);case f64:return n.getFloat64(t,LITTLE_ENDIAN);case anyfunc:case func:return n.getUint32(t,LITTLE_ENDIAN);case i8:return n.getInt8(t,LITTLE_ENDIAN);case u8:return n.getUint8(t,LITTLE_ENDIAN);case i16:return n.getInt16(t,LITTLE_ENDIAN);case u16:return n.getUint16(t,LITTLE_ENDIAN);case u32:return n.getUint32(t,LITTLE_ENDIAN);case u64:return n.getUint64(t,LITTLE_ENDIAN);default:return n.getUint8(t,LITTLE_ENDIAN)}},set$1=(e,t,n,r)=>{switch(e){case i32:return n.setInt32(t,r,LITTLE_ENDIAN);case i64:return n.setInt64(t,r,LITTLE_ENDIAN);case f32:return n.setFloat32(t,r,LITTLE_ENDIAN);case f64:return n.setFloat64(t,r,LITTLE_ENDIAN);case anyfunc:case func:return n.setUint32(t,r,LITTLE_ENDIAN);case i8:return n.setInt8(t,r,LITTLE_ENDIAN);case u8:return n.setUint8(t,r,LITTLE_ENDIAN);case i16:return n.setInt16(t,r,LITTLE_ENDIAN);case u16:return n.setUint16(t,r,LITTLE_ENDIAN);case u32:return n.setUint32(t,r,LITTLE_ENDIAN);case u64:return n.setUint64(t,r,LITTLE_ENDIAN);default:return n.setUint8(t,r,LITTLE_ENDIAN)}};var index$2={i32:i32,i64:i64,f32:f32,f64:f64,anyfunc:anyfunc,func:func,block_type:block_type,i8:i8,u8:u8,i16:i16,u16:u16,u32:u32,u64:u64,set:set$1,get:get$1,sizeof:sizeof},index_1=index$2.i32,index_2=index$2.i64,index_3=index$2.f32,index_4=index$2.f64,index_9=index$2.u8,index_12=index$2.u32,index_14=index$2.set,index_16=index$2.sizeof;const def={},opcodeMap=[],textMap={},___=null,opcode=(e,t,n,r,o,s,i)=>{const a={result:e,first:t,second:n,size:r,code:o,name:s,text:i};def[s]=a;opcodeMap[o]=a;textMap[i]=a;return a};opcode(___,___,___,0,0,"Unreachable","unreachable"),opcode(___,___,___,0,1,"Nop","nop"),opcode(___,___,___,0,2,"Block","block"),opcode(___,___,___,0,3,"Loop","loop"),opcode(___,___,___,0,4,"If","if"),opcode(___,___,___,0,5,"Else","else"),opcode(___,___,___,0,6,"Try","try"),opcode(___,___,___,0,7,"Catch","catch"),opcode(___,___,___,0,8,"Throw","throw"),opcode(___,___,___,0,9,"Rethrow","rethrow"),opcode(___,___,___,0,10,"CatchAll","catch_all"),opcode(___,___,___,0,11,"End","end"),opcode(___,___,___,0,12,"Br","br"),opcode(___,___,___,0,13,"BrIf","br_if"),opcode(___,___,___,0,14,"BrTable","br_table"),opcode(___,___,___,0,15,"Return","return"),opcode(___,___,___,0,16,"Call","call"),opcode(___,___,___,0,17,"CallIndirect","call_indirect"),opcode(___,___,___,0,26,"Drop","drop"),opcode(___,___,___,0,27,"Select","select"),opcode(___,___,___,0,32,"GetLocal","get_local"),opcode(___,___,___,0,33,"SetLocal","set_local"),opcode(___,___,___,0,34,"TeeLocal","tee_local"),opcode(___,___,___,0,35,"GetGlobal","get_global"),opcode(___,___,___,0,36,"SetGlobal","set_global"),opcode(index_1,index_1,___,4,40,"i32Load","i32.load"),opcode(index_2,index_1,___,8,41,"i64Load","i64.load"),opcode(index_3,index_1,___,4,42,"f32Load","f32.load"),opcode(index_4,index_1,___,8,43,"f64Load","f64.load"),opcode(index_1,index_1,___,1,44,"i32Load8S","i32.load8_s"),opcode(index_1,index_1,___,1,45,"i32Load8U","i32.load8_u"),opcode(index_1,index_1,___,2,46,"i32Load16S","i32.load16_s"),opcode(index_1,index_1,___,2,47,"i32Load16U","i32.load16_u"),opcode(index_2,index_1,___,1,48,"i64Load8S","i64.load8_s"),opcode(index_2,index_1,___,1,49,"i64Load8U","i64.load8_u"),opcode(index_2,index_1,___,2,50,"i64Load16S","i64.load16_s"),opcode(index_2,index_1,___,2,51,"i64Load16U","i64.load16_u"),opcode(index_2,index_1,___,4,52,"i64Load32S","i64.load32_s"),opcode(index_2,index_1,___,4,53,"i64Load32U","i64.load32_u"),opcode(___,index_1,index_1,4,54,"i32Store","i32.store"),opcode(___,index_1,index_2,8,55,"i64Store","i64.store"),opcode(___,index_1,index_3,4,56,"f32Store","f32.store"),opcode(___,index_1,index_3,8,57,"f64Store","f64.store"),opcode(___,index_1,index_1,1,58,"i32Store8","i32.store8"),opcode(___,index_1,index_1,2,59,"i32Store16","i32.store16"),opcode(___,index_1,index_2,1,60,"i64Store8","i64.store8"),opcode(___,index_1,index_2,2,61,"i64Store16","i64.store16"),opcode(___,index_1,index_2,4,62,"i64Store32","i64.store32"),opcode(index_1,___,___,0,63,"CurrentMemory","current_memory"),opcode(index_1,index_1,___,0,64,"GrowMemory","grow_memory"),opcode(index_1,___,___,0,65,"i32Const","i32.const"),opcode(index_2,___,___,0,66,"i64Const","i64.const"),opcode(index_3,___,___,0,67,"f32Const","f32.const"),opcode(index_4,___,___,0,68,"f64Const","f64.const"),opcode(index_1,index_1,___,0,69,"i32Eqz","i32.eqz"),opcode(index_1,index_1,index_1,0,70,"i32Eq","i32.eq"),opcode(index_1,index_1,index_1,0,71,"i32Ne","i32.ne"),opcode(index_1,index_1,index_1,0,72,"i32LtS","i32.lt_s"),opcode(index_1,index_1,index_1,0,73,"i32LtU","i32.lt_u"),opcode(index_1,index_1,index_1,0,74,"i32GtS","i32.gt_s"),opcode(index_1,index_1,index_1,0,75,"i32GtU","i32.gt_u"),opcode(index_1,index_1,index_1,0,76,"i32LeS","i32.le_s"),opcode(index_1,index_1,index_1,0,77,"i32LeU","i32.le_u"),opcode(index_1,index_1,index_1,0,78,"i32GeS","i32.ge_s"),opcode(index_1,index_1,index_1,0,79,"i32GeU","i32.ge_u"),opcode(index_1,index_2,___,0,80,"i64Eqz","i64.eqz"),opcode(index_1,index_2,index_2,0,81,"i64Eq","i64.eq"),opcode(index_1,index_2,index_2,0,82,"i64Ne","i64.ne"),opcode(index_1,index_2,index_2,0,83,"i64LtS","i64.lt_s"),opcode(index_1,index_2,index_2,0,84,"i64LtU","i64.lt_u"),opcode(index_1,index_2,index_2,0,85,"i64GtS","i64.gt_s"),opcode(index_1,index_2,index_2,0,86,"i64GtU","i64.gt_u"),opcode(index_1,index_2,index_2,0,87,"i64LeS","i64.le_s"),opcode(index_1,index_2,index_2,0,88,"i64LeU","i64.le_u"),opcode(index_1,index_2,index_2,0,89,"i64GeS","i64.ge_s"),opcode(index_1,index_2,index_2,0,90,"i64GeU","i64.ge_u"),opcode(index_1,index_3,index_3,0,91,"f32Eq","f32.eq"),opcode(index_1,index_3,index_3,0,92,"f32Ne","f32.ne"),opcode(index_1,index_3,index_3,0,93,"f32Lt","f32.lt"),opcode(index_1,index_3,index_3,0,94,"f32Gt","f32.gt"),opcode(index_1,index_3,index_3,0,95,"f32Le","f32.le"),opcode(index_1,index_3,index_3,0,96,"f32Ge","f32.ge"),opcode(index_1,index_3,index_3,0,97,"f64Eq","f64.eq"),opcode(index_1,index_3,index_3,0,98,"f64Ne","f64.ne"),opcode(index_1,index_3,index_3,0,99,"f64Lt","f64.lt"),opcode(index_1,index_3,index_3,0,100,"f64Gt","f64.gt"),opcode(index_1,index_3,index_3,0,101,"f64Le","f64.le"),opcode(index_1,index_3,index_3,0,102,"f64Ge","f64.ge"),opcode(index_1,index_1,___,0,103,"i32Clz","i32.clz"),opcode(index_1,index_1,___,0,104,"i32Ctz","i32.ctz"),opcode(index_1,index_1,___,0,105,"i32Popcnt","i32.popcnt"),opcode(index_1,index_1,index_1,0,106,"i32Add","i32.add"),opcode(index_1,index_1,index_1,0,107,"i32Sub","i32.sub"),opcode(index_1,index_1,index_1,0,108,"i32Mul","i32.mul"),opcode(index_1,index_1,index_1,0,109,"i32DivS","i32.div_s"),opcode(index_1,index_1,index_1,0,110,"i32DivU","i32.div_u"),opcode(index_1,index_1,index_1,0,111,"i32RemS","i32.rem_s"),opcode(index_1,index_1,index_1,0,112,"i32RemU","i32.rem_u"),opcode(index_1,index_1,index_1,0,113,"i32And","i32.and"),opcode(index_1,index_1,index_1,0,114,"i32Or","i32.or"),opcode(index_1,index_1,index_1,0,115,"i32Xor","i32.xor"),opcode(index_1,index_1,index_1,0,116,"i32Shl","i32.shl"),opcode(index_1,index_1,index_1,0,117,"i32ShrS","i32.shr_s"),opcode(index_1,index_1,index_1,0,118,"i32ShrU","i32.shr_u"),opcode(index_1,index_1,index_1,0,119,"i32Rotl","i32.rotl"),opcode(index_1,index_1,index_1,0,120,"i32Rotr","i32.rotr"),opcode(index_2,index_2,___,0,121,"i64Clz","i64.clz"),opcode(index_2,index_2,___,0,122,"i64Ctz","i64.ctz"),opcode(index_2,index_2,___,0,123,"i64Popcnt","i64.popcnt"),opcode(index_2,index_2,index_2,0,124,"i64Add","i64.add"),opcode(index_2,index_2,index_2,0,125,"i64Sub","i64.sub"),opcode(index_2,index_2,index_2,0,126,"i64Mul","i64.mul"),opcode(index_2,index_2,index_2,0,127,"i64DivS","i64.div_s"),opcode(index_2,index_2,index_2,0,128,"i64DivU","i64.div_u"),opcode(index_2,index_2,index_2,0,129,"i64RemS","i64.rem_s"),opcode(index_2,index_2,index_2,0,130,"i64RemU","i64.rem_u"),opcode(index_2,index_2,index_2,0,131,"i64And","i64.and"),opcode(index_2,index_2,index_2,0,132,"i64Or","i64.or"),opcode(index_2,index_2,index_2,0,133,"i64Xor","i64.xor"),opcode(index_2,index_2,index_2,0,134,"i64Shl","i64.shl"),opcode(index_2,index_2,index_2,0,135,"i64ShrS","i64.shr_s"),opcode(index_2,index_2,index_2,0,136,"i64ShrU","i64.shr_u"),opcode(index_2,index_2,index_2,0,137,"i64Rotl","i64.rotl"),opcode(index_2,index_2,index_2,0,138,"i64Rotr","i64.rotr"),opcode(index_3,index_3,index_3,0,139,"f32Abs","f32.abs"),opcode(index_3,index_3,index_3,0,140,"f32Neg","f32.neg"),opcode(index_3,index_3,index_3,0,141,"f32Ceil","f32.ceil"),opcode(index_3,index_3,index_3,0,142,"f32Floor","f32.floor"),opcode(index_3,index_3,index_3,0,143,"f32Trunc","f32.trunc"),opcode(index_3,index_3,index_3,0,144,"f32Nearest","f32.nearest"),opcode(index_3,index_3,index_3,0,145,"f32Sqrt","f32.sqrt"),opcode(index_3,index_3,index_3,0,146,"f32Add","f32.add"),opcode(index_3,index_3,index_3,0,147,"f32Sub","f32.sub"),opcode(index_3,index_3,index_3,0,148,"f32Mul","f32.mul"),opcode(index_3,index_3,index_3,0,149,"f32Div","f32.div"),opcode(index_3,index_3,index_3,0,150,"f32Min","f32.min"),opcode(index_3,index_3,index_3,0,151,"f32Max","f32.max"),opcode(index_3,index_3,index_3,0,152,"f32Copysign","f32.copysign"),opcode(index_3,index_3,index_3,0,153,"f32Abs","f64.abs"),opcode(index_3,index_3,index_3,0,154,"f32Neg","f64.neg"),opcode(index_3,index_3,index_3,0,155,"f32Ceil","f64.ceil"),opcode(index_3,index_3,index_3,0,156,"f32Floor","f64.floor"),opcode(index_3,index_3,index_3,0,157,"f32Trunc","f64.trunc"),opcode(index_3,index_3,index_3,0,158,"f32Nearest","f64.nearest"),opcode(index_3,index_3,index_3,0,159,"f32Sqrt","f64.sqrt"),opcode(index_4,index_4,index_4,0,160,"f64Add","f64.add"),opcode(index_4,index_4,index_4,0,161,"f64Sub","f64.sub"),opcode(index_4,index_4,index_4,0,162,"f64Mul","f64.mul"),opcode(index_4,index_4,index_4,0,163,"f64Div","f64.div"),opcode(index_4,index_4,index_4,0,164,"f64Min","f64.min"),opcode(index_4,index_4,index_4,0,165,"f64Max","f64.max"),opcode(index_4,index_4,index_4,0,166,"f64Copysign","f64.copysign"),opcode(index_1,index_2,___,0,167,"i32Wrapi64","i32.wrap/i64"),opcode(index_1,index_3,___,0,168,"i32TruncSf32","i32.trunc_s/f32"),opcode(index_1,index_3,___,0,169,"i32TruncUf32","i32.trunc_u/f32"),opcode(index_1,index_3,___,0,170,"i32TruncSf64","i32.trunc_s/f64"),opcode(index_1,index_3,___,0,171,"i32TruncUf64","i32.trunc_u/f64"),opcode(index_2,index_1,___,0,172,"i64ExtendSi32","i64.extend_s/i32"),opcode(index_2,index_1,___,0,173,"i64ExtendUi32","i64.extend_u/i32"),opcode(index_2,index_3,___,0,174,"i64TruncSf32","i64.trunc_s/f32"),opcode(index_2,index_3,___,0,175,"i64TruncUf32","i64.trunc_u/f32"),opcode(index_2,index_3,___,0,176,"i64TruncSf64","i64.trunc_s/f64"),opcode(index_2,index_3,___,0,177,"i64TruncUf64","i64.trunc_u/f64"),opcode(index_3,index_1,___,0,178,"f32ConvertSi32","f32.convert_s/i32"),opcode(index_3,index_1,___,0,179,"f32ConvertUi32","f32.convert_u/i32"),opcode(index_3,index_2,___,0,180,"f32ConvertSi64","f32.convert_s/i64"),opcode(index_3,index_2,___,0,181,"f32ConvertUi64","f32.convert_u/i64"),opcode(index_3,index_3,___,0,182,"f32Demotef64","f32.demote/f64"),opcode(index_3,index_1,___,0,183,"f64ConvertSi32","f64.convert_s/i32"),opcode(index_3,index_1,___,0,184,"f64ConvertUi32","f64.convert_u/i32"),opcode(index_3,index_2,___,0,185,"f64ConvertSi64","f64.convert_s/i64"),opcode(index_3,index_2,___,0,186,"f64ConvertUi64","f64.convert_u/i64"),opcode(index_3,index_3,___,0,187,"f64Promotef32","f64.promote/f32"),opcode(index_1,index_3,___,0,188,"i32Reinterpretf32","i32.reinterpret/f32"),opcode(index_2,index_3,___,0,189,"i64Reinterpretf64","i64.reinterpret/f64"),opcode(index_3,index_1,___,0,190,"f32Reinterpreti32","f32.reinterpret/i32"),opcode(index_3,index_2,___,0,191,"f32Reinterpreti64","f64.reinterpret/i64");const getTypecastOpcode=(e,t)=>{const n=e[0];if(["i32","bool"].includes(e)&&"i64"===t)return def.i32Wrapi64;if("i64"===e&&["i32","bool"].includes(t))return def.i64ExtendSi32;if("f32"===e&&"f64"===t)return def.f32Demotef64;if("f64"===e&&"f32"===t)return def.f64Promotef32;const r="f"===n?"ConvertS":"TruncS";return def[e+r+t]},opcodeFromOperator=({type:e,value:t})=>{const n={"+":def[String(e)+"Add"],"-":def[String(e)+"Sub"],"*":def[String(e)+"Mul"],"/":def[String(e)+"DivS"]||def[String(e)+"Div"],"%":def[String(e)+"RemS"]||def[String(e)+"RemU"],"==":def[String(e)+"Eq"],"!=":def[String(e)+"Ne"],">":def[String(e)+"Gt"]||def[String(e)+"GtS"],"<":def[String(e)+"Lt"]||def[String(e)+"LtS"],"<=":def[String(e)+"Le"]||def[String(e)+"LeS"],">=":def[String(e)+"Ge"]||def[String(e)+"GeS"],"?":def.If,":":def.Else,"&":def[String(e)+"And"],"|":def[String(e)+"Or"],"^":def[String(e)+"Xor"],">>":def[String(e)+"ShrS"],">>>":def[String(e)+"ShrU"],"<<":def[String(e)+"Shl"]};return n[t]},I32=127,I64=126,F32=125,F64=124,ANYFUNC=112,FUNC=96,stringToType={i32:I32,i64:I64,f32:F32,f64:F64},getTypeString=e=>{switch(e){case I64:return"i64";case F32:return"f32";case F64:return"f64";case FUNC:return"func";case ANYFUNC:return"anyfunc";case I32:default:return"i32"}},scopeOperation=curry_1((e,t)=>{const n=t.meta[LOCAL_INDEX];const r=t.meta[GLOBAL_INDEX];const o=null!=n?n:r;invariant_1(null!=o,`Unefined index for scope Operation. Possibly missing metadata. op: ${JSON.stringify(e)} node: ${JSON.stringify(t,null,2)}`);const s=null!=n?e+"Local":e+"Global";const i=[Number(o)];return{kind:def[s],params:i,debug:`${t.value}<${t.meta.ALIAS||t.type}>`}}),getConstOpcode=e=>{const t=e.type||waltSyntax_2.i32;const n=def[t+"Const"];const r=[Number(e.value)];return[{kind:n,params:r}]},getType=e=>{switch(e){case waltSyntax_2.f32:return F32;case waltSyntax_2.f64:return F64;case waltSyntax_2.i64:return I64;case waltSyntax_2.i32:default:return I32}},isBuiltinType=e=>"string"==typeof e&&null!=waltSyntax_2[e],generateValueType=e=>({mutable:e.meta[TYPE_CONST]?0:1,type:getType(e.type)}),setInScope=scopeOperation("Set"),getInScope=scopeOperation("Get"),GLOBAL_LABEL="global",mergeBlock=(e,t)=>{Array.isArray(t)?e=[...e,...t]:e.push(t);return e},generateFunctionCall=(e,t)=>{const n=e.params.map(mapSyntax(t)).reduce(mergeBlock,[]);const r=e.meta[FUNCTION_INDEX];n.push({kind:def.Call,params:[r],debug:`${e.value}<${e.type?e.type:"void"}>`});return n},generateIndirectFunctionCall=(e,t)=>{const n=e.params.map(mapSyntax(t)).reduce(mergeBlock,[]);const r=e.meta[LOCAL_INDEX];const o=e.meta[TYPE_INDEX];invariant_1(null!=r,"Undefined local index, not a valid function pointer");invariant_1(null!=o,"Variable is not of a valid function pointer type");return[...n,{kind:def.CallIndirect,params:[o,0]}]},generateBinaryExpression=(e,t)=>{const n=e.params.map(mapSyntax(t)).reduce(mergeBlock,[]);n.push({kind:opcodeFromOperator(_extends({},e,{type:e.type})),params:[]});return n},generateTernary=(e,t)=>{const n=mapSyntax(t);const r=e.params[1];const o=e.params.slice(0,1).map(n).reduce(mergeBlock,[]);o.push({kind:opcodeFromOperator(e),valueType:generateValueType(e),params:[]});o.push.apply(o,r.params.slice(0,1).map(n).reduce(mergeBlock,[]));o.push({kind:opcodeFromOperator({value:":",type:"i32"}),params:[]});o.push.apply(o,r.params.slice(-1).map(n).reduce(mergeBlock,[]));o.push({kind:def.End,params:[]});return o},generateIf=(e,t)=>{const n=mapSyntax(t);const[r,o,...s]=e.params;return[...[r].map(n).reduce(mergeBlock,[]),{kind:def.If,params:[64]},...[o].map(n).reduce(mergeBlock,[]),...s.map(n).reduce(mergeBlock,[]),{kind:def.End,params:[]}]},generateFunctionPointer=e=>[{kind:def.i32Const,params:[Number(e.value)]}],generateReturn=e=>{const t=e.params.map(mapSyntax(null)).reduce(mergeBlock,[]);t.push({kind:def.Return,params:[]});return t},generateExpression=(e,t)=>[e].map(mapSyntax(t)).reduce(mergeBlock,[]),generateDeclaration=(e,t)=>{const n=e.params[0];if(n){const r=e.meta[LOCAL_INDEX],o=isBuiltinType(e.type)?e.type:waltSyntax_4;return[...generateExpression(_extends({},n,{type:o}),t),{kind:def.SetLocal,params:[r],debug:`${e.value}<${String(e.type)}>`}]}return[]},generateArraySubscript=(e,t)=>{const n=e.params[0];const r=n.meta[TYPE_ARRAY];const o=e.params.map(mapSyntax(t)).reduce(mergeBlock,[]);let s=e.type;null!=r&&(o.push.apply(o,[{kind:def.i32Const,params:[2]},{kind:def.i32Shl,params:[]}]),s=r);o.push({kind:def.i32Add,params:[]});o.push({kind:def[String(s)+"Load"],params:[2,0]});return o},generateAssignment=e=>{const[t,n]=e.params;const r=[n].map(mapSyntax(null)).reduce(mergeBlock,[]);r.push(setInScope(t));return r},generateMemoryAssignment=(e,t)=>{const n=e.params[0];const r=n.params[0].meta[TYPE_ARRAY];let o=e.type;const s=e.params[0].params.map(mapSyntax(t)).reduce(mergeBlock,[]);null!=r&&(s.push.apply(s,[{kind:def.i32Const,params:[2]},{kind:def.i32Shl,params:[]}]),o=r);s.push({kind:def.i32Add,params:[]});s.push.apply(s,e.params.slice(1).map(mapSyntax(t)).reduce(mergeBlock,[]));s.push({kind:def[String(o)+"Store"],params:[2,0]});return s},generateLoop=(e,t)=>{const n=[];const r=mapSyntax(t);const[o,s,...i]=e.params;n.push.apply(n,[o].map(r).reduce(mergeBlock,[]));n.push({kind:def.Block,params:[64]});n.push({kind:def.Loop,params:[64]});n.push.apply(n,[s].map(r).reduce(mergeBlock,[]));n.push({kind:def.i32Eqz,params:[]});n.push({kind:def.BrIf,params:[1]});n.push.apply(n,i.map(r).reduce(mergeBlock,[]));n.push({kind:def.Br,params:[0]});n.push({kind:def.End,params:[]});n.push({kind:def.End,params:[]});return n},generateSequence=(e,t)=>e.params.map(mapSyntax(t)).reduce(mergeBlock,[]),generateTypecast=(e,t)=>{const n=e.meta[TYPE_CAST];invariant_1(n,`Cannot generate typecast for node: ${JSON.stringify(e)}`);const{to:r,from:o}=n;const s=e.params.map(mapSyntax(t)).reduce(mergeBlock,[]);return[...s,{kind:getTypecastOpcode(r,o),params:[]}]},generateTypecast$2=()=>[{kind:def.Br,params:[2]}],generateBlock=(e,t)=>e.params.map(mapSyntax(t)).reduce(mergeBlock,[]),generateElse=(e,t)=>[{kind:def.Else,params:[]},...e.params.map(mapSyntax(t)).reduce(mergeBlock,[])],generateSelect=(e,t)=>{const[n,r]=e.params;const o={kind:def.Select,params:[]};const s=[n].map(mapSyntax(t)).reduce(mergeBlock,[]);if("&&"===e.value)return[...[r].map(mapSyntax(t)).reduce(mergeBlock,[]),{kind:def.i32Const,params:[0]},...s,o];return[...s,...[r].map(mapSyntax(t)).reduce(mergeBlock,[]),...s,o]},alignCodes={load8_s:0,load8_u:0,store8:0,load16_s:1,load16_u:1,store16:1,store32:2,load32_s:2,load32_u:2,store:2,load:2},generateNative=(e,t)=>{const n=e.params.map(mapSyntax(t)).reduce(mergeBlock,[]);const r=e.value.split(".").pop();if(null==alignCodes[r])n.push({kind:textMap[e.value],params:[]});else{const t=alignCodes[r],o=[t,0];n.push({kind:textMap[e.value],params:o})}return n},syntaxMap={[Syntax.FunctionCall]:generateFunctionCall,[Syntax.IndirectFunctionCall]:generateIndirectFunctionCall,[Syntax.Constant]:getConstOpcode,[Syntax.BinaryExpression]:generateBinaryExpression,[Syntax.TernaryExpression]:generateTernary,[Syntax.IfThenElse]:generateIf,[Syntax.Else]:generateElse,[Syntax.Select]:generateSelect,[Syntax.Block]:generateBlock,[Syntax.Identifier]:getInScope,[Syntax.FunctionIdentifier]:getInScope,[Syntax.FunctionPointer]:generateFunctionPointer,[Syntax.ReturnStatement]:generateReturn,[Syntax.Declaration]:generateDeclaration,[Syntax.ArraySubscript]:generateArraySubscript,[Syntax.Assignment]:generateAssignment,[Syntax.MemoryAssignment]:generateMemoryAssignment,[Syntax.Loop]:generateLoop,[Syntax.Break]:generateTypecast$2,[Syntax.Sequence]:generateSequence,[Syntax.TypeCast]:generateTypecast,[Syntax.Noop]:generateNoop,[Syntax.NativeMethod]:generateNative},mapSyntax=curry_1((e,t)=>{const n=syntaxMap[t.Type];invariant_1(n,`Unexpected Syntax Token. ${t.Type} "${t.value}"`);return n(t,e)}),generateElement=e=>({functionIndex:e}),EXTERN_FUNCTION=0,EXTERN_TABLE=1,EXTERN_MEMORY=2,EXTERN_GLOBAL=3,externaKindMap={Memory:EXTERN_MEMORY,Table:EXTERN_TABLE},generateMemory=e=>{const t={max:0,initial:0};walkNode({[Syntax.Pair]:({params:e})=>{const[{value:n},{value:r}]=e;t[n]=parseInt(r)}})(e);return t},generateInit=e=>{const t=generateValueType(e);const[n]=e.params;if(null!=n){const{value:e}=n;switch(t.type){case F32:case F64:t.init=parseFloat(e);break;case I32:case I64:default:t.init=parseInt(e)}}return t},parseBounds=e=>{const t={};walkNode({[Syntax.Pair]:({params:e})=>{const[{value:n},{value:r}]=e;t[n]=parseInt(r)}})(e);return t},getKindConstant=e=>{switch(e){case"Memory":return EXTERN_MEMORY;case"Table":return EXTERN_TABLE;case"i32":case"f32":case"i64":case"f64":return EXTERN_GLOBAL;default:return EXTERN_FUNCTION}},getFieldName=e=>{let t=e.value;if(null!=e.meta.AS)return e.meta.AS;return t},getType$1=e=>{switch(e){case"f32":return F32;case"f64":return F64;case"i64":return I64;case"i32":case"Function":default:return I32}},generateImplicitFunctionType=e=>{const[t]=e.params;const n=e.type?getType$1(e.type):null;const r=[];walkNode({[Syntax.Pair]:e=>{const t=e.params[1];invariant_1(t,"Undefined type in a argument expression");r.push(getType$1(t.value))}})(t);return{params:r,result:n,id:e.value}},encodeSigned=e=>{const t=[];for(;;){const n=127&e,r=64&n;if(0===(e>>=7)&&!r||-1===e&&r){t.push(n);break}t.push(128|n)}return t},encodeUnsigned=e=>{const t=[];for(;;){const n=127&e;if(0==(e>>>=7)){t.push(n);break}t.push(128|n)}return t};class OutputStream{constructor(){this.data=[],this.size=0}push(e,t,n){let r=0;switch(e){case"varuint7":case"varuint32":case"varint7":case"varint1":r=(t=encodeUnsigned(t)).length,invariant_1(r,`Cannot write a value of size ${r}`);break;case"varint32":case"varint64":r=(t=encodeSigned(t)).length,invariant_1(r,`Cannot write a value of size ${r}`);break;default:r=index_16[e],invariant_1(r,`Cannot write a value of size ${r}, type ${e}`)}return this.data.push({type:e,value:t,debug:n}),this.size+=r,this}buffer(e=new ArrayBuffer(this.size)){const t=new DataView(e);let n=0;return this.data.forEach(({type:e,value:r})=>{Array.isArray(r)?r.forEach(e=>index_14(index_9,n++,t,e)):(index_14(e,n,t,r),n+=index_16[e])}),e}write(e){return e&&(this.data=this.data.concat(e.data),this.size+=e.size),this}}const DATA_SECTION_HEADER_SIZE=4,generateCode=e=>{const[t,n,...r]=e.params;const o=e.meta[FUNCTION_METADATA];invariant_1(r,"Cannot generate code for function without body");invariant_1(o,"Cannot generate code for function without metadata");const{locals:s,argumentsCount:i}=o;const a={code:[],locals:Object.keys(s).slice(i).map(e=>generateValueType(s[e])),debug:`Function ${e.value}`};a.code=r.map(mapSyntax(a)).reduce(mergeBlock,[]);return a},VERSION_1=1,MAGIC=1836278016,varuint7="varuint7",varuint32="varuint32",varint7="varint7",varint1="varint1",varint32="varint32",varint64="varint64",emit$1=e=>{const t=(new OutputStream).push(varuint32,e.length,"entry count");e.forEach(e=>{emitString(t,e.module,"module");emitString(t,e.field,"field");switch(e.kind){case EXTERN_GLOBAL:t.push(index_9,EXTERN_GLOBAL,"Global"),t.push(index_9,e.type,getTypeString(e.type)),t.push(index_9,0,"immutable");break;case EXTERN_FUNCTION:t.push(index_9,e.kind,"Function"),t.push(varuint32,e.typeIndex,"type index");break;case EXTERN_TABLE:t.push(index_9,e.kind,"Table"),t.push(index_9,ANYFUNC,"function table types"),t.push(varint1,0,"has max value"),t.push(varuint32,0,"iniital table size");break;case EXTERN_MEMORY:t.push(index_9,e.kind,"Memory"),t.push(varint1,!!e.max,"has no max"),t.push(varuint32,e.initial,"initial memory size(PAGES)"),e.max&&t.push(varuint32,e.max,"max memory size(PAGES)")}});return t},emit$2=e=>{const t=new OutputStream;t.push(varuint32,e.length,"count");e.forEach(({field:e,kind:n,index:r})=>{emitString(t,e,"field");t.push(index_9,n,"Global");t.push(varuint32,r,"index")});return t},encode=(e,{type:t,init:n,mutable:r})=>{e.push(index_9,t,getTypeString(t));e.push(index_9,r,"mutable");switch(t){case I32:e.push(index_9,def.i32Const.code,def.i32Const.text),e.push(varint32,n,`value (${n})`);break;case F32:e.push(index_9,def.f32Const.code,def.f32Const.text),e.push(index_3,n,`value (${n})`);break;case F64:e.push(index_9,def.f64Const.code,def.f64Const.text),e.push(index_4,n,`value (${n})`);break;case I64:e.push(index_9,def.i64Const.code,def.i64Const.text),e.push(varint64,n,`value (${n})`)}e.push(index_9,def.End.code,"end")},emit$3=e=>{const t=new OutputStream;t.push(varuint32,e.length,"count");e.forEach(e=>encode(t,e));return t},emit$4=e=>{e=e.filter(e=>null!==e);const t=new OutputStream;t.push(varuint32,e.length,"count");e.forEach(e=>t.push(varuint32,e,"type index"));return t},emitElement=e=>({functionIndex:t},n)=>{e.push(varuint32,0,"table index");e.push(index_9,def.i32Const.code,"offset");e.push(varuint32,n,n.toString());e.push(index_9,def.End.code,"end");e.push(varuint32,1,"number of elements");e.push(varuint32,t,"function index")},emit$5=e=>{const t=new OutputStream;t.push(varuint32,e.length,"count");e.forEach(emitElement(t));return t},emitType=(e,{params:t,result:n},r)=>{e.push(varint7,FUNC,`func type (${r})`);e.push(varuint32,t.length,"parameter count");t.forEach(t=>e.push(varint7,t,"param"));n?(e.push(varint1,1,"result count"),e.push(varint7,n,`result type ${getTypeString(n)}`)):e.push(varint1,0,"result count")},emit$6=e=>{const t=new OutputStream;t.push(varuint32,e.length,"count");e.forEach((e,n)=>emitType(t,e,n));return t},emitLocal=(e,t)=>{null==t.isParam&&(e.push(varuint32,1,"number of locals of following type"),e.push(varint7,t.type,`${getTypeString(t.type)}`))},emitFunctionBody=(e,{locals:t,code:n,debug:r})=>{const o=new OutputStream;n.forEach(({kind:e,params:t,valueType:n,debug:r})=>{o.push(index_9,e.code,`${e.text}  ${r||""}`);n&&(o.push(index_9,n.type,"result type"),o.push(index_9,n.mutable,"mutable"));t.forEach(t=>{let n=varuint32;let r="i32.literal";if(e.code>=40&&e.code<=62)n=varuint32,r="memory_immediate";else switch(e.result){case index_4:n=index_4,r="f64.literal";break;case index_3:n=index_3,r="f32.literal";break;case index_1:n=varint32,r="i32.literal";break;case index_2:n=varint64,r="i64.literal";break;default:n=varuint32}o.push(n,t,`${r}`)})});const s=new OutputStream;t.forEach(e=>emitLocal(s,e));e.push(varuint32,o.size+s.size+2,r);e.push(varuint32,t.length,"locals count");e.write(s);e.write(o);e.push(index_9,def.End.code,"end")},emit$7=e=>{const t=new OutputStream;t.push(varuint32,e.length,"function count");e.forEach(e=>emitFunctionBody(t,e));return t},emitEntry=(e,t)=>{e.push(varint1,t.max?1:0,"has no max");e.push(varuint32,t.initial,"initial memory size(PAGES)");t.max&&e.push(varuint32,t.max,"max memory size(PAGES)")},emit$8=e=>{const t=new OutputStream;t.push(varuint32,e.length,"count");e.forEach(e=>emitEntry(t,e));return t},typeBytecodes={anyfunc:112},emitEntry$1=(e,t)=>{e.push(varint7,typeBytecodes[t.type],t.type);e.push(varint1,t.max?1:0,"has max");e.push(varuint32,t.initial,"initial table size");t.max&&e.push(varuint32,t.max,"max table size")},emitDataSegment=(e,t)=>{e.push(varuint32,0,"memory index");const{offset:n,data:r}=t;e.push(index_9,def.i32Const.code,def.i32Const.text);e.push(varint32,n,`segment offset (${n})`);e.push(index_9,def.End.code,"end");e.push(varuint32,r.size,"segment size");e.write(r)},emitModuleName=e=>{const t=new OutputStream;emitString(t,e,`name_len: ${e}`);return t},emitFunctionNames=e=>{const t=new OutputStream;t.push(varuint32,e.length,`count: ${String(e.length)}`);e.forEach(({index:e,name:n})=>{t.push(varuint32,e,`index: ${String(e)}`);emitString(t,n,`name_len: ${n}`)});return t},emitLocals=e=>{const t=new OutputStream;t.push(varuint32,e.length,`count: ${String(e.length)}`);e.forEach(({index:e,locals:n})=>{t.push(varuint32,e,`function index: ${String(e)}`);t.push(varuint32,n.length,`number of params and locals ${n.length}`);n.forEach(({index:e,name:n})=>{t.push(varuint32,e,`index: ${String(e)}`);emitString(t,n,`name_len: ${n}`)})});return t},emit$10=e=>{const t=new OutputStream;emitString(t,"name","name_len: name");const n=emitModuleName(e.module);t.push(varuint7,0,"name_type: Module");t.push(varuint32,n.size,"name_payload_len");t.write(n);const r=emitFunctionNames(e.functions);t.push(varuint7,1,"name_type: Function");t.push(varuint32,r.size,"name_payload_len");t.write(r);const o=emitLocals(e.locals);t.push(varuint7,2,"name_type: Locals");t.push(varuint32,o.size,"name_payload_len");t.write(o);return t},SECTION_TYPE=1,SECTION_IMPORT=2,SECTION_FUNCTION=3,SECTION_TABLE=4,SECTION_MEMORY=5,SECTION_GLOBAL=6,SECTION_EXPORT=7,SECTION_START=8,SECTION_ELEMENT=9,SECTION_CODE=10,SECTION_DATA=11,SECTION_NAME=0,writer=({type:e,label:t,emitter:n})=>r=>{const o=r[t];if(!o||Array.isArray(o)&&!o.length)return null;const s=(new OutputStream).push(index_9,e,t+" section");const i=n(o);s.push(varuint32,i.size,"size");s.write(i);return s};var section={type:writer({type:SECTION_TYPE,label:"Types",emitter:emit$6}),imports:writer({type:SECTION_IMPORT,label:"Imports",emitter:emit$1}),function:writer({type:SECTION_FUNCTION,label:"Functions",emitter:emit$4}),table:writer({type:SECTION_TABLE,label:"Table",emitter:emitTables$1}),memory:writer({type:SECTION_MEMORY,label:"Memory",emitter:emit$8}),exports:writer({type:SECTION_EXPORT,label:"Exports",emitter:emit$2}),globals:writer({type:SECTION_GLOBAL,label:"Globals",emitter:emit$3}),start:writer({type:SECTION_START,label:"Start",emitter:emitTables}),element:writer({type:SECTION_ELEMENT,label:"Element",emitter:emit$5}),code:writer({type:SECTION_CODE,label:"Code",emitter:emit$7}),data:writer({type:SECTION_DATA,label:"Data",emitter:emit$9}),name:writer({type:SECTION_NAME,label:"Name",emitter:emit$10})};const _debug=(e,t=0,n)=>{let r=0;return e.data.slice(t,n).map(({type:t,value:n,debug:o})=>{const s=r.toString(16).padStart(8,"0").padEnd(e.data.length.toString().length+1);let i;i=Array.isArray(n)?n.map(e=>e.toString(16)).join().padStart(16):n.toString(16).padStart(16);const a=`${s}: ${i} ; ${o}`;r+=index_16[t]||n.length;return a}).join("\n")+"\n ============ fin ============="},getText$1=e=>{const t=e.value||"??";const n=e.type;const r=n||"i32";const o=opcodeFromOperator({value:t,type:r});if(!n)return o.text.replace("i32","??");return o.text},parseParams=e=>{const t=[];walkNode({[Syntax.Pair]:(e,n)=>{t.push(`${e.params[0].value} ${e.params[1].value}`)},[Syntax.Type]:e=>{t.push(e.value)}})(e);return t.length?" param("+t.join(" ")+")":""},parseResult=e=>{if(null==e)return"";return" (result "+(e.type||"??")+")"},typedefString=e=>{const[t,n]=e.params;return"(type "+e.value+` (func${parseParams(t)}${parseResult(n)}))`},getPrinters=e=>({[Syntax.Import]:(t,n)=>{const[r,o]=t.params;walkNode({[Syntax.Pair]:({params:t},n)=>{const{value:r}=t[0];const s=t[1];if("Memory"===s.value){const t=parseBounds(s);e(`(import "${o.value}" "${r}" (memory ${t.initial}${t.max?t.max:""}))`)}else e(`(import "${o.value}" "${r}" ${typedefString(s)})`)},[Syntax.Identifier]:(t,n)=>{const{value:r}=t;e(`(import "${o.value}" "${r}" (type ??))`)}})(r)},[Syntax.Export]:(t,n)=>{e("(export",2);t.params.forEach(n);e(")",0,-2)},[Syntax.GenericType]:(t,n)=>{e("(type-generic "+t.value+")",0,0," pseudo type")},[Syntax.FunctionCall]:(t,n)=>{t.params.length>0?(e(`(call ${t.value}`,2),t.params.forEach(n),e(")",0,-2)):e(`(call ${t.value})`)},[Syntax.BinaryExpression]:(t,n)=>{const r=getText$1(t);e("("+r,2);t.params.forEach(n);e(")",0,-2)},[Syntax.ArraySubscript]:(t,n)=>{e("(i32.add",2);t.params.forEach(n);e(")",0,-2)},[Syntax.Typedef]:(t,n)=>{e(typedefString(t))},[Syntax.Identifier]:t=>{const n=null!=t.meta[GLOBAL_INDEX]?"global":"local";e(`(get_${n} ${t.value})`)},[Syntax.Constant]:t=>{e(`(${String(t.type)}.const ${t.value})`)},[Syntax.FunctionPointer]:t=>{e(`(${String(t.type)}.table_pointer ${t.value})`)},[Syntax.FunctionDeclaration]:(t,n)=>{const[r,o,...s]=t.params;e(`(func ${t.value}${parseParams(r)}${parseResult(o)}`,2);s.forEach(n);e(")",0,-2)},[Syntax.ReturnStatement]:(t,n)=>{e("(return",2);t.params.forEach(n);e(")",0,-2)},[Syntax.Declaration]:(t,n)=>{const r=null!=t.meta[TYPE_CONST]?"immutable":"mutable";e("(local "+t.value+" "+String(t.type),2,0,` ${r}`);t.params.forEach(n);e(")",0,-2)},[Syntax.ImmutableDeclaration]:(t,n)=>{const r=null!=t.meta[GLOBAL_INDEX]?"global":"local";if("Memory"===t.type){const n=parseBounds(t);e(`(memory ${n.initial}${n.max?` ${n.max}`:""})`)}else e(`(${r} `+t.value+" "+String(t.type),2,0," immutable"),t.params.forEach(n),e(")",0,-2)},[Syntax.StringLiteral]:t=>{e("(i32.const ??)",0,0,` string "${t.value}"`)},[Syntax.Type]:t=>{e(t.value)},[Syntax.TypeCast]:(t,n)=>{const r=t.params[0];const o=getTypecastOpcode(String(t.type),r.type);e("("+o.text,2);t.params.forEach(n);e(")",0,-2)},[Syntax.ArraySubscript]:(t,n)=>{e("("+String(t.type)+".load",2,0);t.params.forEach(n);e(")",0,-2)},[Syntax.MemoryAssignment]:(t,n)=>{e("("+String(t.type)+".store",2,0);t.params.forEach(n);e(")",0,-2)},[Syntax.Assignment]:(t,n)=>{const[r,...o]=t.params;const s=null!=r.meta[GLOBAL_INDEX]?"global":"local";e(`(set_${s} ${r.value}`,2);o.forEach(n);e(")",0,-2)},[Syntax.TernaryExpression]:(t,n)=>{const[r,o]=t.params;e("(select",2);n(o);n(r);e(")",0,-2)},[Syntax.IfThenElse]:(t,n)=>{const[r,o,...s]=t.params;e("(if",2);n(r);e("(then",2);n(o);e(")",0,-2);s.length>0&&(e("(else",2),s.forEach(n),e(")",0,-2));e(")",0,-2)},[Syntax.ObjectLiteral]:(e,t)=>{}}),printNode=e=>{if(null==e)return"";let t=0;const n=[];const r=[];const o=[];const s=(e,s=0,i=0,a="")=>{t+=i;o.push(a);r.push(e);n.push(t+e.length);t+=s};walkNode(getPrinters(s))(e);const i=Math.max(...n);const a=i+4;const c=r.reduce((e,t,r)=>{e+=t.padStart(n[r]," ").padEnd(a," ")+";"+o[r]+"\n";return e},"");return c},source=`\n  const memory: Memory = { initial: 1 };\n  let heapPointer: i32 = 0;\n  export function __closure_malloc(size: i32): i32 {\n    const ptr: i32 = heapPointer;\n    heapPointer += size;\n    return ptr;\n  }\n\n  export function __closure_free(ptr: i32) {\n  }\n\n  // Getters\n  export function __closure_get_i32(ptr: i32): i32 {\n    const view: i32[] = ptr;\n    return view[0];\n  }\n\n  export function __closure_get_f32(ptr: i32): f32 {\n    const view: f32[] = ptr;\n    return view[0];\n  }\n\n  export function __closure_get_i64(ptr: i32): i64 {\n    const view: i64[] = ptr;\n    return view[0];\n  }\n\n  export function __closure_get_f64(ptr: i32): f64 {\n    const view: f64[] = ptr;\n    return view[0];\n  }\n\n  // Setters\n  export function __closure_set_i32(ptr: i32, value: i32) {\n    const view: i32[] = ptr;\n    view[0] = value;\n  }\n\n  export function __closure_set_f32(ptr: i32, value: f32) {\n    const view: f32[] = ptr;\n    view[0] = value;\n  }\n\n  export function __closure_set_i64(ptr: i32, value: i64) {\n    const view: i64[] = ptr;\n    view[0] = value;\n  }\n\n  export function __closure_set_f64(ptr: i32, value: f64) {\n    const view: f64[] = ptr;\n    view[0] = value;\n  }\n`,mapToImports=e=>e.instance.exports,emitter=(...e)=>{const t=emit(...e);console.log(_debug(t));return t},VERSION="0.10.0",getIR=(e,{version:t=VERSION_1,encodeNames:n=!1,lines:r=(e?e.split("\n"):[]),filename:o="unknown"}={})=>{const s=parse(e);const i=semantics(s);validate(i,{lines:r,filename:o});const a=generator(i,{version:t,encodeNames:n,lines:r,filename:o});const c=emitter(a,{version:t,encodeNames:n,filename:o,lines:r});return c},withPlugins=(e,t)=>{const n={closure:(e,t)=>{t["walt-plugin-closure"]=mapToImports(e)}};const r=Object.entries(e).reduce((e,[t,r])=>{n[t](r,e);return e},{});return _extends({},r,t)};exports.parser=parse,exports.semantics=semantics,exports.validate=validate,exports.generator=generator,exports.prettyPrintNode=printNode,exports.debug=_debug,exports.closurePlugin=closurePlugin$$1,exports.stringEncoder=stringEncoder,exports.stringDecoder=stringDecoder,exports.walkNode=walkNode,exports.mapNode=mapNode_2,exports.emitter=emitter,exports.VERSION=VERSION,exports.getIR=getIR,exports.withPlugins=withPlugins,exports.default=compileWalt,Object.defineProperty(exports,"__esModule",{value:!0})});
