!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n(e.Walt={})}(this,function(exports){"use strict";function blockParser(e){const n=e.startNode(),t=[];if(e.eat(["{"])){let n;for(;e.token&&"}"!==e.token.value;)(n=statement(e))&&t.push(n);e.expect(["}"])}return e.endNode(_extends({},n,{params:t}),Syntax.Block)}function parselambda(e,n,t){const r=t[0],a=t[1],i=t[2]||a||r;t.splice(-3);let o=[];const s=_extends({},n,{type:"i32",range:[e.token.start,e.token.end],meta:{},Type:Syntax.Closure,params:[]}),[u,c]=r.params;return o=r.Type===Syntax.Pair?null!=u&&null!=c?u.Type===Syntax.Pair?[makeArgs(u),makeResult(c)]:[makeArgs(u.Type===Syntax.Sequence?u:r),makeResult(c.Type===Syntax.Type?c:null)]:[makeArgs(null),makeResult(u)]:r.Type===Syntax.Sequence?[makeArgs(r),makeResult(a.Type===Syntax.Type?a:null)]:[makeArgs(null),makeResult(null)],_extends({},s,{params:[_extends({},s,{Type:Syntax.FunctionDeclaration,params:[...o,i]})]})}function binary(e,n,t){const r=_extends({},t[0]);r.value=n.value,r.params=t;let a=Syntax.BinaryExpression;if("="===r.value)a=Syntax.Assignment;else if("-="===r.value||"+="===r.value){a=Syntax.Assignment;const t=r.value[0];r.value="=",r.params=[r.params[0],binary(e,_extends({},n,{value:t}),[r.params[0],r.params[1]])]}else{if("["===r.value||"."===r.value)return subscriptFromNode(e,r);":"===r.value?a=Syntax.Pair:"||"!==r.value&&"&&"!==r.value||(a=Syntax.Select)}return e.endNode(r,a)}function objectLiteral(e,n,t){const r=e.startNode(n);return r.params=t,e.endNode(r,Syntax.ObjectLiteral)}function parseConstant(e){const n=e.startNode(),t=e.token.value,r=-1!==t.toString().indexOf(".")?"f32":"i32";return e.endNode(_extends({},n,{type:r,value:t}),Syntax.Constant)}function stringLiteral(e){const n=e.startNode();return n.value=e.token.value.substring(1,e.token.value.length-1),e.endNode(n,Syntax.StringLiteral)}function builtInType(e){if("<"===e.stream.peek().value){const n=e.token.value;e.eat(["Memory","Table"]),e.eat(["<"]),e.eat(["{"]);const t=e.makeNode({value:n,type:n,params:[expression(e)]},Syntax.Type);return e.eat(["}"]),t}return e.makeNode({value:e.token.value,type:e.token.value},Syntax.Type)}function maybeFunctionDeclaration(e){if(!e.eat(["function"]))return declaration(e);const n=e.startNode(),t=e.expect(null,Syntax.Identifier).value,r=parseArguments(e),a=parseFunctionResult(e);e.expect(["{"]);const i=[];for(;e.token&&"}"!==e.token.value;){const n=statement(e);n&&i.push(n)}return e.expect(["}"]),e.endNode(_extends({},n,{value:t,params:[r,a,...i]}),Syntax.FunctionDeclaration)}function parseExport(e){const n=e.startNode();e.eat(["export"]);const t=[maybeFunctionDeclaration(e)];return e.endNode(_extends({},n,{params:t}),Syntax.Export)}function parseImport(e){const n=e.startNode();if(e.eat(["import"]),!e.eat(["{"]))throw e.syntaxError("expected {");const t=expression(e);e.expect(["}"]),e.expect(["from"]);const r=expression(e);return e.endNode(_extends({},n,{params:[t,r]}),Syntax.Import)}function breakParser(e){const n=e.startNode();return e.expect(["break"]),e.endNode(n,Syntax.Break)}function generateErrorString(e,n,t,r,a){const{line:i,col:o}=t.start,{col:s}=t.end;return"\n"+(()=>{if(t.start.sourceLine!==t.end.sourceLine)return t.start.sourceLine+"\n"+t.end.sourceLine;return t.end.sourceLine})()+"\n"+new Array(s-o+1).join("^").padStart(s," ")+` ${n}`+"\n"+e+"\n"+`  at ${a} (${r}:${i}:${o})`}function typeParser(e){const n=e.startNode();e.eat(["type"]);const t=e.expect(null,Syntax.Identifier).value;e.expect(["="]);const r=e.token.value;if(e.eat(null,Syntax.Identifier)){e.expect(["<"]);const a=e.makeNode(_extends({},e.token,{type:null}),Syntax.Identifier);e.expect(null,Syntax.Identifier),e.expect([">"]);const i=e.endNode(_extends({},n,{value:t,params:[_extends({},a,{value:r}),a]}),Syntax.GenericType);return i}if(e.eat(["("])){const r=expression(e),a=null!=r?_extends({},r,{value:"FUNCTION_ARGUMENTS",Type:Syntax.FunctionArguments,params:[r]}):_extends({},n,{value:"FUNCTION_ARGUMENTS",Type:Syntax.FunctionArguments,params:[]});e.expect([")"]),e.expect(["=>"]);const i=_extends({},expression(e),{value:"FUNCTION_RESULT",Type:Syntax.FunctionResult});return e.endNode(_extends({},n,{value:t,type:i.type,params:[a,i]}),Syntax.Typedef)}if("{"!==e.token.value){const t=n.range[0],r=e.token.end;throw new SyntaxError(generateErrorString("Invalid type syntax","A function type must be of form (<type>, ...) <type>",{start:t,end:r},"",""))}return e.endNode(_extends({},n,{value:t,params:[expression(e)],type:"i32"}),Syntax.Struct)}function parseIfStatement(e){const n=_extends({},e.startNode(e.token));e.eat(["if"]);const t=[condition(e)],r=statement(e);for(r&&t.push(r),e.eat([";"]);e.eat(["else"]);){const n=e.makeNode(null,Syntax.Else),r=[],a=statement(e);a&&r.push(a),t.push(_extends({},n,{params:r}))}return e.endNode(_extends({},n,{params:t}),Syntax.IfThenElse)}function maybeAssignment(e){const n=e.stream.peek().value;return"["===n||"."===n?memoryStore(e):expression(e)}function tokenStream(e){const n=e.length;let t=0;return{tokens:e,next:()=>e[t++],peek:()=>e[t],last:()=>e[n-1],length:n}}function parse(e){const n=new Stream(e),t=tokenStream(new Tokenizer(n).parse()),r=new Context({stream:t,token:t.tokens[0],lines:n.lines,filename:"unknown.walt"}),a=r.makeNode({value:"ROOT_NODE"},Syntax.Program);if(!r.stream||!r.stream.length)return a;for(r.token=t.next();r.stream.peek();){const e=statement(r);e&&a.params.push(e)}return a}function write(e){return(new OutputStream).push(index_12,MAGIC,"\\0asm").push(index_12,e,`version ${e}`)}function emitString(e,n,t){e.push(varuint32,n.length,t);for(let t=0;t<n.length;t++)e.push(index_9,n.charCodeAt(t),n[t]);return e}function emitTables(e){const n=new OutputStream;return n.push(varuint32,e.length,"count"),e.forEach(e=>emitEntry$1(n,e)),n}function emit(e,n){const t=(new OutputStream).write(write(e.Version)).write(section.type(e)).write(section.imports(e)).write(section.function(e)).write(section.table(e)).write(section.memory(e)).write(section.globals(e)).write(section.exports(e)).write(section.element(e)).write(section.code(e));return n.encodeNames?t.write(section.name(e)):t}function generateNoop(){return[]}function walker(e){const n=t=>{if(null==t)return t;const{params:r}=t;const a=(()=>{if("*"in e&&"function"==typeof e["*"])return e["*"];if(t.Type in e&&"function"==typeof e[t.Type])return e[t.Type];return()=>t})();if(2===a.length)return a(t,n),t;a(t);r.forEach(n);return t};return n}function mapNode(e){const n=t=>{if(null==t)return t;const r=(()=>{if("*"in e&&"function"==typeof e["*"])return e["*"];if(t.Type in e&&"function"==typeof e[t.Type])return e[t.Type];return e=>e})();if(2===r.length)return r(t,n);const a=r(t);const i=a.params.map(n);return _extends({},a,{params:i})};return n}function generateExport(e){const n=e.meta[FUNCTION_INDEX],t=e.meta[GLOBAL_INDEX];return null!=t?{index:t,kind:EXTERN_GLOBAL,field:e.value}:{index:n,kind:EXTERN_FUNCTION,field:e.value}}function generateMemory$2(e){const n={max:0,initial:0,type:""};return walker({[Syntax.Pair]:({params:e})=>{const[{value:t},{value:r}]=e;"initial"===t?n.initial=parseInt(r):"element"===t?n.type=r:"max"===t&&(n.max=parseInt(r))}})(e),n}function generateImportFromNode(e){const[n,t]=e.params,{value:r}=t,a=[];return walker({[Syntax.Pair]:(e,n)=>{const[t,i]=e.params;const{value:o}=t;const{value:s}=i;const u=getKindConstant(s);const c=(()=>{const e=i.meta[TYPE_INDEX];if(e)return e;return null})();const p="Memory"===s?parseBounds(i):{};a.push(_extends({module:r,field:o,global:u===EXTERN_GLOBAL,kind:u,type:stringToType[s],typeIndex:c},p))}})(n),a}function generateType(e){const n=e.value;invariant_1("string"==typeof n,`Generator: A type must have a valid string identifier, node: ${JSON.stringify(e)}`);const[t,r]=e.params,a=[];return walker({[Syntax.Type]:(e,n)=>{a.push(getType$1(e.value))}})(t),{id:n,params:a,result:r.type&&"void"!==r.type?getType$1(r.type):null}}function generator$1(e,n){const t={Version:n.version,Types:[],Code:[],Exports:[],Imports:[],Globals:[],Element:[],Functions:[],Memory:[],Table:[],Artifacts:[],Name:{module:n.filename,functions:[],locals:[]}},r=e=>{const n=generateImplicitFunctionType(e);return t.Types.findIndex(e=>{const t=e.params.length===n.params.length&&e.params.reduce((e,t,r)=>e&&t===n.params[r],!0);const r=e.result===n.result;return t&&r})},a=e=>t.Element.findIndex(n=>n.functionIndex===e),i={},o=mapNode({[Syntax.Typedef]:(e,n)=>{let r=t.Types.findIndex(({id:n})=>n===e.value);let a=t.Types[r];null==a&&(r=t.Types.length,t.Types.push(generateType(e)));a=_extends({},e,{meta:_extends({},e.meta,{[TYPE_INDEX]:r})});i[e.value]={typeIndex:r,typeNode:a};return a}})(e);return walker({[Syntax.Typedef]:(e,n)=>e,[Syntax.Export]:e=>{const[n]=e.params;t.Exports.push(generateExport(n))},[Syntax.ImmutableDeclaration]:e=>{const n=e.meta[GLOBAL_INDEX];if(null!=n)switch(e.type){case"Memory":t.Memory.push(generateMemory(e));break;case"Table":t.Table.push(generateMemory$2(e));break;default:t.Globals.push(generateInit(e))}},[Syntax.Declaration]:e=>{const n=e.meta[GLOBAL_INDEX];null!=n&&t.Globals.push(generateInit(e))},[Syntax.Import]:e=>{t.Imports.push(...generateImportFromNode(e))},[Syntax.FunctionDeclaration]:e=>{const o=(()=>{const n=r(e);if(-1===n)return t.Types.push(generateImplicitFunctionType(e)),t.Types.length-1;return n})();const s=mapNode({[Syntax.Type]:e=>{const n=i[e.value];if(null!=n)return _extends({},e,{meta:_extends({},e.meta,{[TYPE_INDEX]:n.index})});return e},[Syntax.FunctionPointer]:e=>{const n=e.meta[FUNCTION_INDEX];if(n){const e=n;let r=a(e);r<0&&(r=t.Element.length,t.Element.push(generateElement(e)))}return e}})(e);const u=e.meta[FUNCTION_INDEX];invariant_1(null!=u,"Function index must be set");t.Functions[u]=o;t.Code[u]=generateCode(s);if(n.encodeNames){t.Name.functions.push({index:u,name:e.value});const n=e.meta[FUNCTION_METADATA];null!=n&&Object.keys(n.locals).length&&(t.Name.locals[u]={index:u,locals:Object.entries(n.locals).map(([e,n])=>({name:e,index:Number(n.meta["local/index"])}))})}}})(o),t.Code=t.Code.filter(Boolean),t}function imports$1(){return parse(`\n    import {\n      '${CLOSURE_MALLOC}': ClosureGeti32,\n      '${CLOSURE_FREE}': ClosureFree,\n      '${CLOSURE_GET}-i32': ClosureGeti32,\n      '${CLOSURE_GET}-f32': ClosureGetf32,\n      '${CLOSURE_GET}-i64': ClosureGeti64,\n      '${CLOSURE_GET}-f64': ClosureGetf64,\n      '${CLOSURE_SET}-i32': ClosureSeti32,\n      '${CLOSURE_SET}-f32': ClosureSetf32,\n      '${CLOSURE_SET}-i64': ClosureSeti64,\n      '${CLOSURE_SET}-f64': ClosureSetf64\n    } from 'walt-plugin-closure';\n    type ClosureFree = (i32) => void;\n    type ClosureGeti32 = (i32) => i32;\n    type ClosureGetf32 = (i32) => f32;\n    type ClosureGeti64 = (i32) => i64;\n    type ClosureGetf64 = (i32) => f64;\n    type ClosureSeti32 = (i32, i32) => void;\n    type ClosureSetf32 = (i32, f32) => void;\n    type ClosureSeti64 = (i32, i64) => void;\n    type ClosureSetf64 = (i32, f64) => void;\n  `).params}function hasNode(e,n){const t=n=>n&&n.Type===e,r=e=>{if(null==e)return!1;return t(e)||e.params.some(r)};return r(n)}function semantics$1(e){const n={},t={},r={},a={},i={},o=[],s=[];hasNode(Syntax.Closure,e)&&(e=_extends({},e,{params:[...imports$1(),...e.params]}));const u=mapNode({[Syntax.Typedef]:(e,n)=>{r[e.value]=e;return e},[Syntax.GenericType]:mapGeneric({types:r})})(e),c=mapNode({[Syntax.Typedef]:(e,n)=>e,[Syntax.Import]:mapImport({functions:n,types:r,globals:t}),[Syntax.Declaration]:parseGlobalDeclaration(!1,{globals:t,types:r}),[Syntax.ImmutableDeclaration]:parseGlobalDeclaration(!0,{globals:t,types:r}),[Syntax.Struct]:mapStruct({userTypes:a}),[Syntax.FunctionDeclaration]:mapFunctionNode$1({hoist:o,hoistImports:s,types:r,globals:t,functions:n,userTypes:a,table:i})})(u);return _extends({},c,{meta:_extends({},c.meta,{[AST_METADATA]:{functions:n,globals:t,types:r,userTypes:a}}),params:[...s,...c.params,...o]})}function validate$1(e,{filename:n}){const t=e.meta[AST_METADATA];if(null==t)throw new Error("Missing AST metadata!");const{types:r,functions:a}=t,i=[];walker({[Syntax.Pair]:e=>{const[t,r]=e.range;i.push(generateErrorString(`Unexpected expression ${e.Type}`,"",{start:t,end:r},n,GLOBAL_LABEL))},[Syntax.Export]:e=>{const t=e.params[0];const[r,a]=t.range;const o=t.meta[GLOBAL_INDEX];null==o||t.params.length||i.push(generateErrorString("Global exports must have a value","",{start:r,end:a},n,GLOBAL_LABEL))},[Syntax.Import]:(e,t)=>{walker({[Syntax.Pair]:(e,t)=>{const a=e.params[1];if(!isBuiltinType(a.value)&&null==r[a.value]){const[e,t]=a.range;i.push(generateErrorString(`Undefined Type ${a.value}`,`Invalid Import. ${a.value} type does not exist`,{start:e,end:t},n,GLOBAL_LABEL))}}})(e)},[Syntax.Struct]:(e,n)=>{},[Syntax.ImmutableDeclaration]:(e,n)=>{},[Syntax.Declaration]:(e,t)=>{const[r]=e.params;if(null!=e.meta[TYPE_CONST]){const[t,a]=e.range;null!=r&&r.Type!==Syntax.Constant&&i.push(generateErrorString("Global Constants must be initialized with a Number literal.","WebAssembly does not allow for non number literal constant initializers.",{start:t,end:a},n,GLOBAL_LABEL)),null==r&&i.push(generateErrorString("Constant declaration without an initializer.","Global constants must be initialized with a Number literal.",{start:t,end:a},n,GLOBAL_LABEL))}},[Syntax.FunctionDeclaration]:(e,t)=>{const o=`${e.value}()`;walker({[Syntax.Declaration]:(e,t)=>{const[r]=e.params;if(null!=r&&null!=statements[r.Type]){const[t,a]=e.range;i.push(generateErrorString(`Unexpected statement ${r.Type}`,"Attempting to assign a statement to a variable. Did you miss a semicolon(;)?",{start:t,end:a},n,o))}if(null!=e.meta[TYPE_CONST]){const[t,a]=e.range;null==r&&i.push(generateErrorString("Constant declaration without an initializer.","Local Constants must be initialized with an expression.",{start:t,end:a},n,GLOBAL_LABEL))}},[Syntax.Assignment]:e=>{const[t]=e.params;const[r,a]=e.range;const s=e.params.find(e=>null!=statements[e.Type]);null!=s&&i.push(generateErrorString("Unexpected statement in assignment","Statments cannot be used in assignment expressions. Did you miss a semicolon?",{start:s.range[0],end:s.range[1]},n,o));const u=t.meta[TYPE_CONST];null!=u&&i.push(generateErrorString(`Cannot reassign a const variable ${t.value}`,"const variables cannot be reassigned, use let instead.",{start:r,end:a},n,o))},[Syntax.ArraySubscript]:(e,t)=>{const[r,a]=e.params;const[s,u]=e.range;if(null==a.value){const e=a.meta[ALIAS];i.push(generateErrorString("Cannot generate memory offset",`Undefined key ${null!=e?e:a.value} for type ${String(r.type)}`,{start:s,end:u},n,o))}},[Syntax.ReturnStatement]:(t,r)=>{t.params.map(r);if(null==e.type)return;const[a]=t.params;const[s]=t.range;const u=null!=a?a.range[1]:t.range[1];const c=(()=>{if(null==a)return null;return[">","<",">=","<=","==","!="].includes(a.value)?"i32":a.type})();c!==e.type&&i.push(generateErrorString("Missing return value","Inconsistent return value. Expected "+e.type+" received "+String(c),{start:s,end:u},n,o))},[Syntax.FunctionCall]:(e,t)=>{if(null==a[e.value]){const[t,r]=e.range;i.push(generateErrorString("Undefined function reference",`${e.value} is not defined.`,{start:t,end:r},n,o))}},[Syntax.IndirectFunctionCall]:(e,t)=>{const a=e.params[e.params.length-1];const s=r[a.type];if(!isBuiltinType(a.type)&&null==s){const[t,r]=e.range;i.push(generateErrorString("Cannot make an indirect call without a valid function type",`${a.value} has type ${String(a.type)} which is not defined. Inidrect calls must have pre-defined types.`,{start:t,end:r},n,o))}}})(e)}})(e);const o=i.length;if(o>0){const e=i.reduce((e,n)=>e+"\n"+`${n}\n`,`Cannot generate WebAssembly for ${n}. ${o} problems.\n`);throw new Error(e)}}function closurePlugin$$1(){return compileWalt(source,{version:1,encodeNames:!1,filename:"walt-closure-plugin",lines:source.split("\n")})}function compileWalt(e,n){return getIR(e,n).buffer()}const Program="Program",Keyword="Keyword",Export="Export",Import="Import",Statement="Statement",IfThenElse="IfThenElse",Select="Select",Else="Else",UnaryExpression="UnaryExpression",BinaryExpression="BinaryExpression",TernaryExpression="TernaryExpression",NumberLiteral="NumberLiteral",StringLiteral="StringLiteral",Punctuator="Punctuator",Identifier="Identifier",ArraySubscript="ArraySubscript",Constant="Constant",Type="Type",GenericType="GenericType",UserType="UserType",FunctionType="FunctionType",Declaration="Declaration",ImmutableDeclaration="ImmutableDeclaration",FunctionDeclaration="FunctionDeclaration",ArrayDeclaration="ArrayDeclaration",IndirectFunctionCall="IndirectFunctionCall",FunctionCall="FunctionCall",Loop="Loop",MemoryAssignment="MemoryAssignment",Assignment="Assignment",Param="Param",Typedef="Typedef",Struct="Struct",ReturnStatement="ReturnStatement",Sequence="Sequence",ObjectLiteral="ObjectLiteral",Pair="Pair",TypeCast="TypeCast",Break="Break",Comment="Comment",Sizeof="Sizeof",Spread="Spread",Closure="Closure",Noop="Noop",ClosureType="ClosureType",Block="Block",ObjectField="ObjectField",FunctionIndex="FunctionIndex",FunctionIdentifier="FunctionIdentifier",FunctionPointer="FunctionPointer",FunctionArguments="FunctionArguments",FunctionResult="FunctionResult",FunctionLocals="FunctionLocals",i32="i32",f32="f32",i64="i64",f64="f64",Memory="Memory",Table="Table",builtinTypes={i32:i32,f32:f32,i64:i64,f64:f64,Memory:Memory,Table:Table},statements={Program:Program,Export:Export,Import:Import,IfThenElse:IfThenElse,Else:Else,Declaration:Declaration,ImmutableDeclaration:ImmutableDeclaration,FunctionDeclaration:FunctionDeclaration,ArrayDeclaration:ArrayDeclaration,Loop:Loop,MemoryAssignment:MemoryAssignment,Assignment:Assignment,Typedef:Typedef,Struct:Struct,ReturnStatement:ReturnStatement,Sequence:Sequence,ObjectLiteral:ObjectLiteral,Pair:Pair,Break:Break,Comment:Comment,Sizeof:Sizeof,Spread:Spread,Noop:Noop,Block:Block};var Syntax={Program:Program,Keyword:Keyword,Export:Export,Import:Import,Statement:Statement,IfThenElse:IfThenElse,Select:Select,Else:Else,UnaryExpression:UnaryExpression,BinaryExpression:BinaryExpression,TernaryExpression:TernaryExpression,NumberLiteral:NumberLiteral,StringLiteral:StringLiteral,Punctuator:Punctuator,Identifier:Identifier,ArraySubscript:ArraySubscript,Constant:Constant,Type:Type,GenericType:GenericType,UserType:UserType,FunctionType:FunctionType,Declaration:Declaration,ImmutableDeclaration:ImmutableDeclaration,FunctionDeclaration:FunctionDeclaration,ArrayDeclaration:ArrayDeclaration,IndirectFunctionCall:IndirectFunctionCall,FunctionCall:FunctionCall,Loop:Loop,MemoryAssignment:MemoryAssignment,Assignment:Assignment,Param:Param,Typedef:Typedef,Struct:Struct,ReturnStatement:ReturnStatement,Sequence:Sequence,ObjectLiteral:ObjectLiteral,Pair:Pair,TypeCast:TypeCast,Break:Break,Comment:Comment,Sizeof:Sizeof,Spread:Spread,Closure:Closure,Noop:Noop,ClosureType:ClosureType,Block:Block,ObjectField:ObjectField,FunctionIndex:FunctionIndex,FunctionIdentifier:FunctionIdentifier,FunctionPointer:FunctionPointer,FunctionArguments:FunctionArguments,FunctionResult:FunctionResult,FunctionLocals:FunctionLocals},_extends=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e};const makeResult=e=>_extends({range:[]},e,{meta:{},params:[],Type:Syntax.FunctionResult,value:"FUNCTION_RESULT"}),makeArgs=e=>_extends({range:[]},e,{params:(()=>{if(null==e)return[];return e.Type===Syntax.Sequence?e.params:[e]})(),type:null,meta:{},value:"FUNCTION_ARGUMENTS",Type:Syntax.FunctionArguments}),subscriptFromNode=(e,n)=>{const[t]=n.params;return e.endNode(_extends({},n,{value:t.value}),Syntax.ArraySubscript)},unary=(e,n,t)=>{const[r]=t;if("--"===n.value)return _extends({},r,{Type:Syntax.UnaryExpression,value:"-",meta:{},params:[_extends({},r,{value:"0",Type:Syntax.Constant,params:[],meta:{}}),r]});return _extends({},n,{range:[n.start,r.range[1]],meta:{},Type:Syntax.Spread,params:[r]})},ternary=(e,n,t)=>{const r=e.startNode(t[0]);r.params=t;r.value=n.value;r.type=t[t.length-1].type;return e.endNode(r,Syntax.TernaryExpression)},flattenSequence=e=>e.reduce((e,n)=>{n.Type===Syntax.Sequence?e.push.apply(e,flattenSequence(n.params)):e.push(n);return e},[]),sequence=(e,n,t)=>{const r=e.startNode(t[0]);r.value=n.value;r.params=flattenSequence(t);return e.endNode(r,Syntax.Sequence)},operator=(e,n,t)=>{const r=n.pop();switch(r.value){case"=>":return parselambda(e,r,t);case"?":return ternary(e,r,t.splice(-2));case",":return sequence(e,r,t.splice(-2));case"{":return objectLiteral(e,r,t.splice(-1));case"--":case"...":case"sizeof":return unary(e,r,t.splice(-1));default:return binary(e,r,t.splice(-2))}},PRECEDENCE_MEMBER_ACCESS=19,PRECEDENCE_ASSIGNMENT=3,PRECEDENCE_DIVIDE=1,PRECEDENCE_MULTIPLY=1,PRECEDENCE_ADDITION=0,PRECEDENCE_SUBTRACTION=0,PRECEDENCE_COMMA=-2,PRECEDENCE_BITWISE_XOR=-2,PRECEDENCE_SPREAD=-1,PRECEDENCE_BITWISE_AND=-1,PRECEDENCE_BITWISE_OR=-3,PRECEDENCE_LOGICAL_AND=-4,PRECEDENCE_LOGICAL_OR=-5,PRECEDENCE_KEY_VALUE_PAIR=-1,PRECEDENCE_PARAMS=-99,precedence={"=>":PRECEDENCE_PARAMS,"(":PRECEDENCE_PARAMS,",":PRECEDENCE_COMMA,"+":PRECEDENCE_ADDITION,"-":PRECEDENCE_SUBTRACTION,"*":PRECEDENCE_MULTIPLY,"/":PRECEDENCE_DIVIDE,"==":2,"!=":2,".":PRECEDENCE_MEMBER_ACCESS,"=":PRECEDENCE_ASSIGNMENT,"-=":PRECEDENCE_ASSIGNMENT,"+=":PRECEDENCE_ASSIGNMENT,"?":4,">":5,"<":5,":":PRECEDENCE_KEY_VALUE_PAIR,"^":PRECEDENCE_BITWISE_XOR,"&":PRECEDENCE_BITWISE_AND,"|":PRECEDENCE_BITWISE_OR,"&&":PRECEDENCE_LOGICAL_AND,"||":PRECEDENCE_LOGICAL_OR,"...":PRECEDENCE_SPREAD},getPrecedence=e=>precedence[e.value],getAssociativty=e=>{switch(e.value){case"=":case"-=":case"+=":case"--":case"++":case"?":return"right";case"+":case"-":case"/":case"*":case":":default:return"left"}},maybeIdentifier=e=>{const n=e.startNode();e.eat(null,Syntax.Identifier);if(e.eat(["("])){const t=[expression(e)],r=e.endNode(_extends({},n,{params:t.filter(Boolean)}),Syntax.FunctionCall);return e.expect([")"]),r}return e.endNode(n,Syntax.Identifier)},last=e=>e[e.length-1],isPunctuatorAndNotBracket=e=>e&&e.type===Syntax.Punctuator&&"]"!==e.value&&")"!==e.value,predicate=(e,n)=>";"!==e.value&&n>0,expression=(e,n=predicate)=>{const t=[];const r=[];let a=1;let i=null;const o=()=>r.push(operator(e,t,r));const s=e=>{let n=last(t);for(;n&&n.value!==e;)o(),n=last(t)};const u=e=>{let n=null;for(;(n=last(t))&&n.Type!==Syntax.Sequence&&getPrecedence(n)>=e&&"left"===getAssociativty(n);)o()};const c=()=>{switch(e.token.value){case"=>":return u(getPrecedence(e.token)),t.push(e.token),e.next(),"{"===e.token.value&&r.push(blockParser(e)),!1;case"(":case"[":a++,t.push(e.token);break;case"]":a--,s("["),o();break;case")":if(--a<1)return!1;s("("),t.pop();break;case"{":a++,t.push(e.token);break;case"}":if(--a<1)return!1;s("{"),o();break;default:{const n=(e=>{if("-"===e.value&&null==i||"-"===e.value&&isPunctuatorAndNotBracket(i))return _extends({},e,{value:"--"});return e})(e.token);u(getPrecedence(n)),t.push(n)}}};const p=()=>{switch(e.token.type){case Syntax.Constant:r.push(parseConstant(e));break;case Syntax.Identifier:return i=e.token,r.push(maybeIdentifier(e)),!1;case Syntax.StringLiteral:r.push(stringLiteral(e));break;case Syntax.Type:r.push(builtInType(e));break;case Syntax.Punctuator:const n=c();if(null!=n)return n}return!0};for(;e.token&&n(e.token,a);)p()&&(i=e.token,e.next());for(;t.length;)o();return r.pop()},declaration=e=>{const n=e.startNode();let t=Syntax.Declaration;"const"===e.token.value&&(t=Syntax.ImmutableDeclaration);e.eat(["const","let","function"]);n.value=e.expect(null,Syntax.Identifier).value;e.expect([":"]);let r=e.token.value;e.eat(null,Syntax.Type)||e.expect(null,Syntax.Identifier);const a=[];e.eat(["<"])?(e.eat(["{"]),a.push(expression(e)),e.eat(["}"]),e.eat([">"])):e.eat(["="])&&a.push(expression(e));return e.endNode(_extends({},n,{params:a,type:r}),t)},parseArguments=e=>{e.expect(["("]);const n=e.makeNode({params:[expression(e)],value:"FUNCTION_ARGUMENTS"},Syntax.FunctionArguments);e.expect([")"]);return n},parseFunctionResult=e=>{const n=e.startNode();if(e.eat([":"]))return e.endNode(_extends({},n,{value:e.token.value,type:(()=>{const n=e.token.value;if(e.eat(null,Syntax.Type))return"void"===n?null:n;if(e.eat(null,Syntax.Identifier))return"i32";return"i32"})()}),Syntax.FunctionResult);return e.endNode(_extends({},n,{value:"FUNCTION_RESULT"}),Syntax.FunctionResult)},reverse={">":"<=","<":">=",">=":"<","<=":">","==":"!=","!=":"=="},paramList=e=>{e.expect(["("]);const n=[];let t=null;for(;e.token.value&&")"!==e.token.value;)(t=expression(e))&&(n.push(t),e.eat([";"]));e.expect([")"]);return n},forLoop=e=>{const n=e.startNode();e.eat(["for"]);const[t,r,a]=paramList(e);reverse[r.value]&&(r.value=reverse[r.value]);const i=[];e.expect(["{"]);let o=null;for(;e.token&&"}"!==e.token.value;)(o=statement(e))&&i.push(o);e.expect(["}"]);return e.endNode(_extends({},n,{params:[t,r,...i,a]}),Syntax.Loop)},reverse$1={">":"<=","<":">=",">=":"<","<=":">","==":"!=","!=":"=="},whileLoop=e=>{const n=e.startNode();e.eat(["while"]);e.expect(["("]);const t=e.makeNode({},Syntax.Noop);const r=expression(e);reverse$1[r.value]&&(r.value=reverse$1[r.value]);const a=[];e.expect([")"]);e.expect(["{"]);let i=null;for(;e.token&&"}"!==e.token.value;)(i=statement(e))&&a.push(i);e.expect(["}"]);return e.endNode(_extends({},n,{params:[t,r,...a]}),Syntax.Loop)};class Context{constructor({stream:e,token:n,lines:t}){this.token=n,this.stream=e,this.lines=t}syntaxError(e,n){return new SyntaxError(generateErrorString(e,n||"",this.token,this.filename||"unknown","unknown"))}unexpectedValue(e){return this.syntaxError(`Expected: ${Array.isArray(e)?e.join("|"):e}`,"Unexpected value")}unexpected(e){return this.syntaxError(`Expected: ${Array.isArray(e)?e.join(" | "):JSON.stringify(e)}`,`Unexpected token ${this.token.type}`)}unknown({value:e}){return this.syntaxError("Unknown token",e)}unsupported(){return this.syntaxError("Language feature not supported",this.token.value)}expect(e,n){const t=this.token;if(!this.eat(e,n))throw e?this.unexpectedValue(e):this.unexpected(n);return t}next(){this.token=this.stream.next()}eat(e,n){return null!=this.token&&(e?!!e.includes(this.token.value)&&(this.next(),!0):this.token.type===n&&(this.next(),!0))}startNode(e=this.token||{}){return{Type:"",value:e.value,range:[e.start],meta:{},params:[],type:null}}endNode(e,n){const t=this.token||this.stream.last()||{};return _extends({},e,{Type:n,range:e.range.concat(t.end)})}makeNode(e,n){return this.endNode(_extends({},this.startNode(),e),n)}}const returnStatement=e=>{const n=e.startNode();e.expect(["return"]);const t=expression(e);n.params.push(t);return e.endNode(n,Syntax.ReturnStatement)},condition=e=>{e.expect(["("]);const n=expression(e);e.expect([")"]);return n},keyword=e=>{switch(e.token.value){case"let":case"const":return declaration(e);case"function":return maybeFunctionDeclaration(e);case"export":return parseExport(e);case"import":return parseImport(e);case"type":return typeParser(e);case"if":return parseIfStatement(e);case"for":return forLoop(e);case"while":return whileLoop(e);case"return":return returnStatement(e);case"break":return breakParser(e);default:throw e.unsupported()}};var NODE_ENV="production",invariant=function(e,n,t,r,a,i,o,s){if("production"!==NODE_ENV&&void 0===n)throw new Error("invariant requires an error message argument");if(!e){var u;if(void 0===n)u=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var c=[t,r,a,i,o,s],p=0;(u=new Error(n.replace(/%s/g,function(){return c[p++]}))).name="Invariant Violation"}throw u.framesToPop=1,u}},invariant_1=invariant;const memoryStore=e=>{const n=expression(e);invariant_1(n.params.length>0,"Memory Store expression could not be parsed");const t=n.params[0].type;return e.endNode(_extends({},n,{type:t}),Syntax.MemoryAssignment)},statement=e=>{switch(e.token.type){case Syntax.Keyword:return keyword(e);case Syntax.Identifier:return maybeAssignment(e);case Syntax.Punctuator:default:if(e.eat([";"]))return null;if("{"===e.token.value)return blockParser(e);throw e.syntaxError("Unexpected expression")}};class Stream{constructor(e){this.pos=this.line=this.col=0,this.input=e,this.lines=e.split("\n"),this.newLine()}peek(){return this.input.charAt(this.pos)}next(){const e=this.input.charAt(this.pos++);return Stream.eol(e)?this.newLine():this.col++,e}newLine(){this.line++,this.col=0}static eol(e){return"\n"===e}static eof(e){return""===e}static whitespace(e){return"\n"===e||" "===e||"\t"===e||"\v"===e||"\r"===e||"\f"===e}}const fsearch=e=>{const n=n=>{if(e&&e.children[n])return fsearch(e.children[n]);return null};n.leaf=e.leaf;return n};class Trie{constructor(e){this.root={char:"",children:{},leaf:!1},e.map(e=>this.add(e)),this.fsearch=fsearch(this.root)}add(e){let n=this.root,t=e.slice(0,1);for(e=e.slice(1);void 0!==n.children[t]&&t.length>0;)n=n.children[t],t=e.slice(0,1),e=e.slice(1);for(;t.length>0;){const r={char:t,children:{},leaf:!1};n.children[t]=r,n=r,t=e.slice(0,1),e=e.slice(1)}n.leaf=!0}}var trie$1=Trie;const wrap=(e,n,t)=>{const r=r=>{const a=e(r);return"function"==typeof a?wrap(a,n,t):a};r.type=n;r.supported=t;r.strict=!!t;r.leaf=e.leaf;return r};var token=wrap;const supported=["+","++","-","--",">>",">>>","<<","=","==","+=","-=","=>","<=",">=","!=","%","/","^","&","|","!","**",":","(",")",".","{","}",",","[","]",";",">","<","?","||","&&","{","}","..."],trie=new trie$1(supported);var punctuator=token(trie.fsearch,Syntax.Punctuator,supported);const{isNaN:isNaN,parseInt:parseInt$1}=Number,isNumber=e=>!isNaN(parseInt$1(e)),isDot=e=>"."===e,number=e=>isNumber(e)?number:null,numberOrDot=e=>{if(isDot(e))return number;if(isNumber(e))return numberOrDot;return null},hex=e=>{if(/[0-9a-fA-F]/.test(e))return hex;return null},maybeExponent=e=>{switch(e){case"e":case"E":return number;default:return numberOrDot(e)}},maybeModifier=e=>{switch(e){case"b":case"B":case"o":return number;case"x":case"X":return hex;default:return numberOrDot(e)}},root=e=>{if("-"===e)return root;if(isDot(e))return number;if("0"===e)return maybeModifier;if(isNumber(e))return maybeExponent;return null};var constant=token(root,Syntax.Constant);const quoteOK=e=>()=>e,nextFails=()=>null,endsInSingleQuote=e=>{if(/\\/.test(e))return quoteOK(endsInSingleQuote);if("'"===e)return nextFails;return endsInSingleQuote},endsInDoubleQuote=e=>{if(/\\/.test(e))return quoteOK(endsInDoubleQuote);if('"'===e)return nextFails;return endsInDoubleQuote},maybeQuote=e=>{if("'"===e)return endsInSingleQuote;if('"'===e)return endsInDoubleQuote;return null},stringParser=token(maybeQuote,Syntax.StringLiteral),isValidIdentifier=e=>!stringParser(e)&&!punctuator(e)&&!Stream.eol(e)&&" "!==e,supportAny=e=>isValidIdentifier(e)?supportAny:null,parse$1=e=>isValidIdentifier(e)&&!constant(e)?supportAny:null,tokenParser=token(parse$1,Syntax.Identifier),supported$1=["break","if","else","import","from","export","return","switch","case","default","const","let","for","continue","do","while","function","global","module","type","lambda"],trie$2=new trie$1(supported$1),root$1=trie$2.fsearch;var keyword$2=token(root$1,Syntax.Keyword,supported$1);const SLASH="/",ASTERIX="*",SINGLE_LINE=`${SLASH}${SLASH}`,MULTI_LINE_START=`${SLASH}${ASTERIX}`,MULTI_LINE_END=`${ASTERIX}${SLASH}`,COMMENT_IDENTIFIERS=[SINGLE_LINE,MULTI_LINE_START,MULTI_LINE_END],parser=e=>{let n=!1;let t=!1;let r;const a=e=>{Stream.eol(e)&&(t=!1);switch(`${r}${e}`){case MULTI_LINE_END:return n=!1,a;case MULTI_LINE_START:return n=!0,a;case SINGLE_LINE:return t=!0,a;default:if(n||t)return r=e,a}};const i=e=>{const t=r;r=e;if(e===SLASH||n||COMMENT_IDENTIFIERS.indexOf(`${t}${e}`)>-1)return a;return null};return i(e)};var comments=token(parser,Syntax.Comment);const supported$2=["i32","i64","f32","f64","i32[]","i64[]","f32[]","f64[]","Function","Memory","Table","void"],trie$3=new trie$1(supported$2);var type=token(trie$3.fsearch,Syntax.Type,supported$2);class Tokenizer{constructor(e,n=[punctuator,constant,tokenParser,keyword$2,stringParser,type,comments]){this.stream=e,this.tokens=[],this.pos=0,this.parsers=n}next(){let e="";this.seekNonWhitespace();let n,t="",r=this.parsers,a=this.match(t,r),i={sourceLine:this.stream.lines[this.stream.line-1],line:this.stream.line,col:this.stream.col};do{t=this.stream.peek(),r=this.match(t,r),e+=t,this.stream.next(),n=this.stream.peek(),a=this.match(n,r)}while(!Stream.eof(n)&&a.length>0);if(Stream.eof(e))return null;const o=this.token(e,r);return o.start=i,o.end={sourceLine:this.stream.lines[this.stream.line-1],line:this.stream.line,col:this.stream.col},o.type!==comments.type&&this.tokens.push(o),this.tokens[this.pos++]}match(e,n){return n.map(n=>n(e)).filter(e=>e)}token(e,n,t={type:"unknown",value:e,start:{},end:{}}){return n.length>1&&(n=n.filter(e=>!e.strict||e.leaf)).length>1&&(n=n.filter(e=>e.strict)),1===n.length&&(t.type=n[0].type),t}seekNonWhitespace(){for(;this.stream.peek()&&Stream.whitespace(this.stream.peek());)this.stream.next()}parse(){for(;!Stream.eof(this.stream.peek());)this.next();return this.tokens}}const i32$1=1,i64$1=2,f32$1=4,f64$1=8,anyfunc=16,func=32,block_type=64,i8=128,u8=256,i16=512,u16=1024,u32=2048,u64=4096,word=4,sizeof={[i32$1]:word,[i64$1]:2*word,[f32$1]:word,[f64$1]:2*word,[u32]:word,[u16]:word>>1,[u8]:word>>2,[i8]:word>>2,[i16]:word>>1,[anyfunc]:word,[func]:word,[block_type]:word},LITTLE_ENDIAN=!0,get$1=(e,n,t)=>{switch(e){case i32$1:return t.getInt32(n,LITTLE_ENDIAN);case i64$1:return t.getInt64(n,LITTLE_ENDIAN);case f32$1:return t.getFloat32(n,LITTLE_ENDIAN);case f64$1:return t.getFloat64(n,LITTLE_ENDIAN);case anyfunc:case func:return t.getUint32(n,LITTLE_ENDIAN);case i8:return t.getInt8(n,LITTLE_ENDIAN);case u8:return t.getUint8(n,LITTLE_ENDIAN);case i16:return t.getInt16(n,LITTLE_ENDIAN);case u16:return t.getUint16(n,LITTLE_ENDIAN);case u32:return t.getUint32(n,LITTLE_ENDIAN);case u64:return t.getUint64(n,LITTLE_ENDIAN);default:return t.getUint8(n,LITTLE_ENDIAN)}},set$1=(e,n,t,r)=>{switch(e){case i32$1:return t.setInt32(n,r,LITTLE_ENDIAN);case i64$1:return t.setInt64(n,r,LITTLE_ENDIAN);case f32$1:return t.setFloat32(n,r,LITTLE_ENDIAN);case f64$1:return t.setFloat64(n,r,LITTLE_ENDIAN);case anyfunc:case func:return t.setUint32(n,r,LITTLE_ENDIAN);case i8:return t.setInt8(n,r,LITTLE_ENDIAN);case u8:return t.setUint8(n,r,LITTLE_ENDIAN);case i16:return t.setInt16(n,r,LITTLE_ENDIAN);case u16:return t.setUint16(n,r,LITTLE_ENDIAN);case u32:return t.setUint32(n,r,LITTLE_ENDIAN);case u64:return t.setUint64(n,r,LITTLE_ENDIAN);default:return t.setUint8(n,r,LITTLE_ENDIAN)}};var index={i32:i32$1,i64:i64$1,f32:f32$1,f64:f64$1,anyfunc:anyfunc,func:func,block_type:block_type,i8:i8,u8:u8,i16:i16,u16:u16,u32:u32,u64:u64,set:set$1,get:get$1,sizeof:sizeof},index_1=index.i32,index_2=index.i64,index_3=index.f32,index_4=index.f64,index_9=index.u8,index_12=index.u32,index_14=index.set,index_16=index.sizeof;const encodeSigned=(e,n=32)=>{const t=[];for(;;){const n=127&e,r=64&n;if(0===(e>>=7)&&!r||-1===e&&r){t.push(n);break}t.push(128|n)}return t},encodeUnsigned=e=>{const n=[];for(;;){const t=127&e;if(0==(e>>>=7)){n.push(t);break}n.push(128|t)}return n};class OutputStream{constructor(){this.data=[],this.size=0}push(e,n,t){let r=0;switch(e){case"varuint7":case"varuint32":case"varint7":case"varint1":r=(n=encodeUnsigned(n)).length,invariant_1(r,`Cannot write a value of size ${r}`);break;case"varint32":r=(n=encodeSigned(n)).length,invariant_1(r,`Cannot write a value of size ${r}`);break;case"varint64":r=(n=encodeSigned(n,64)).length,invariant_1(r,`Cannot write a value of size ${r}`);break;default:r=index_16[e],invariant_1(r,`Cannot write a value of size ${r}, type ${e}`)}return this.data.push({type:e,value:n,debug:t}),this.size+=r,this}buffer(){const e=new ArrayBuffer(this.size),n=new DataView(e);let t=0;return this.data.forEach(({type:e,value:r})=>{Array.isArray(r)?r.forEach(e=>index_14(index_9,t++,n,e)):(index_14(e,t,n,r),t+=index_16[e])}),e}write(e){return e&&(this.data=this.data.concat(e.data),this.size+=e.size),this}}const VERSION_1=1,MAGIC=1836278016,varuint7="varuint7",varuint32="varuint32",varint7="varint7",varint1="varint1",varint32="varint32",varint64="varint64",I32=127,I64=126,F32=125,F64=124,ANYFUNC=112,FUNC=96,stringToType={i32:I32,i64:I64,f32:F32,f64:F64},getTypeString=e=>{switch(e){case I32:return"i32";case I64:return"i64";case F32:return"f32";case F64:return"f64";case FUNC:return"func";case ANYFUNC:return"anyfunc";default:return"?"}},EXTERN_FUNCTION=0,EXTERN_TABLE=1,EXTERN_MEMORY=2,EXTERN_GLOBAL=3,emit$1=e=>{const n=(new OutputStream).push(varuint32,e.length,"entry count");e.forEach(e=>{emitString(n,e.module,"module");emitString(n,e.field,"field");switch(e.kind){case EXTERN_GLOBAL:n.push(index_9,EXTERN_GLOBAL,"Global"),n.push(index_9,e.type,getTypeString(e.type)),n.push(index_9,0,"immutable");break;case EXTERN_FUNCTION:n.push(index_9,e.kind,"Function"),n.push(varuint32,e.typeIndex,"type index");break;case EXTERN_TABLE:n.push(index_9,e.kind,"Table"),n.push(index_9,ANYFUNC,"function table types"),n.push(varint1,0,"has max value"),n.push(varuint32,0,"iniital table size");break;case EXTERN_MEMORY:n.push(index_9,e.kind,"Memory"),n.push(varint1,!!e.max,"has no max"),n.push(varuint32,e.initial,"initial memory size(PAGES)"),e.max&&n.push(varuint32,e.max,"max memory size(PAGES)")}});return n},emit$2=e=>{const n=new OutputStream;n.push(varuint32,e.length,"count");e.forEach(({field:e,kind:t,index:r})=>{emitString(n,e,"field");n.push(index_9,t,"Global");n.push(varuint32,r,"index")});return n},def={},opcodeMap=[],___=null,opcode=(e,n,t,r,a,i,o)=>{const s={result:e,first:n,second:t,size:r,code:a,name:i,text:o};def[i]=s;opcodeMap[a]=s;return s};opcode(___,___,___,0,0,"Unreachable","unreachable"),opcode(___,___,___,0,1,"Nop","nop"),opcode(___,___,___,0,2,"Block","block"),opcode(___,___,___,0,3,"Loop","loop"),opcode(___,___,___,0,4,"If","if"),opcode(___,___,___,0,5,"Else","else"),opcode(___,___,___,0,6,"Try","try"),opcode(___,___,___,0,7,"Catch","catch"),opcode(___,___,___,0,8,"Throw","throw"),opcode(___,___,___,0,9,"Rethrow","rethrow"),opcode(___,___,___,0,10,"CatchAll","catch_all"),opcode(___,___,___,0,11,"End","end"),opcode(___,___,___,0,12,"Br","br"),opcode(___,___,___,0,13,"BrIf","br_if"),opcode(___,___,___,0,14,"BrTable","br_table"),opcode(___,___,___,0,15,"Return","return"),opcode(___,___,___,0,16,"Call","call"),opcode(___,___,___,0,17,"CallIndirect","call_indirect"),opcode(___,___,___,0,26,"Drop","drop"),opcode(___,___,___,0,27,"Select","select"),opcode(___,___,___,0,32,"GetLocal","get_local"),opcode(___,___,___,0,33,"SetLocal","set_local"),opcode(___,___,___,0,34,"TeeLocal","tee_local"),opcode(___,___,___,0,35,"GetGlobal","get_global"),opcode(___,___,___,0,36,"SetGlobal","set_global"),opcode(index_1,index_1,___,4,40,"i32Load","i32.load"),opcode(index_2,index_1,___,8,41,"i64Load","i64.load"),opcode(index_3,index_1,___,4,42,"f32Load","f32.load"),opcode(index_4,index_1,___,8,43,"f64Load","f64.load"),opcode(index_1,index_1,___,1,44,"i32Load8S","i32.load8_s"),opcode(index_1,index_1,___,1,45,"i32Load8U","i32.load8_u"),opcode(index_1,index_1,___,2,46,"i32Load16S","i32.load16_s"),opcode(index_1,index_1,___,2,47,"i32Load16U","i32.load16_u"),opcode(index_2,index_1,___,1,48,"i64Load8S","i64.load8_s"),opcode(index_2,index_1,___,1,49,"i64Load8U","i64.load8_u"),opcode(index_2,index_1,___,2,50,"i64Load16S","i64.load16_s"),opcode(index_2,index_1,___,2,51,"i64Load16U","i64.load16_u"),opcode(index_2,index_1,___,4,52,"i64Load32S","i64.load32_s"),opcode(index_2,index_1,___,4,53,"i64Load32U","i64.load32_u"),opcode(___,index_1,index_1,4,54,"i32Store","i32.store"),opcode(___,index_1,index_2,8,55,"i64Store","i64.store"),opcode(___,index_1,index_3,4,56,"f32Store","f32.store"),opcode(___,index_1,index_3,8,57,"f64Store","f64.store"),opcode(___,index_1,index_1,1,58,"i32Store8","i32.store8"),opcode(___,index_1,index_1,2,59,"i32Store16","i32.store16"),opcode(___,index_1,index_2,1,60,"i64Store8","i64.store8"),opcode(___,index_1,index_2,2,61,"i64Store16","i64.store16"),opcode(___,index_1,index_2,4,62,"i64Store32","i64.store32"),opcode(index_1,___,___,0,63,"CurrentMemory","current_memory"),opcode(index_1,index_1,___,0,64,"GrowMemory","grow_memory"),opcode(index_1,___,___,0,65,"i32Const","i32.const"),opcode(index_2,___,___,0,66,"i64Const","i64.const"),opcode(index_3,___,___,0,67,"f32Const","f32.const"),opcode(index_4,___,___,0,68,"f64Const","f64.const"),opcode(index_1,index_1,___,0,69,"i32Eqz","i32.eqz"),opcode(index_1,index_1,index_1,0,70,"i32Eq","i32.eq"),opcode(index_1,index_1,index_1,0,71,"i32Ne","i32.ne"),opcode(index_1,index_1,index_1,0,72,"i32LtS","i32.lt_s"),opcode(index_1,index_1,index_1,0,73,"i32LtU","i32.lt_u"),opcode(index_1,index_1,index_1,0,74,"i32GtS","i32.gt_s"),opcode(index_1,index_1,index_1,0,75,"i32GtU","i32.gt_u"),opcode(index_1,index_1,index_1,0,76,"i32LeS","i32.le_s"),opcode(index_1,index_1,index_1,0,77,"i32LeU","i32.le_u"),opcode(index_1,index_1,index_1,0,78,"i32GeS","i32.ge_s"),opcode(index_1,index_1,index_1,0,79,"i32GeU","i32.ge_u"),opcode(index_1,index_2,___,0,80,"i64Eqz","i64.eqz"),opcode(index_1,index_2,index_2,0,81,"i64Eq","i64.eq"),opcode(index_1,index_2,index_2,0,82,"i64Ne","i64.ne"),opcode(index_1,index_2,index_2,0,83,"i64LtS","i64.lt_s"),opcode(index_1,index_2,index_2,0,84,"i64LtU","i64.lt_u"),opcode(index_1,index_2,index_2,0,85,"i64GtS","i64.gt_s"),opcode(index_1,index_2,index_2,0,86,"i64GtU","i64.gt_u"),opcode(index_1,index_2,index_2,0,87,"i64LeS","i64.le_s"),opcode(index_1,index_2,index_2,0,88,"i64LeU","i64.le_u"),opcode(index_1,index_2,index_2,0,89,"i64GeS","i64.ge_s"),opcode(index_1,index_2,index_2,0,90,"i64GeU","i64.ge_u"),opcode(index_1,index_3,index_3,0,91,"f32Eq","f32.eq"),opcode(index_1,index_3,index_3,0,92,"f32Ne","f32.ne"),opcode(index_1,index_3,index_3,0,93,"f32Lt","f32.lt"),opcode(index_1,index_3,index_3,0,94,"f32Gt","f32.gt"),opcode(index_1,index_3,index_3,0,95,"f32Le","f32.le"),opcode(index_1,index_3,index_3,0,96,"f32Ge","f32.ge"),opcode(index_1,index_3,index_3,0,97,"f64Eq","f64.eq"),opcode(index_1,index_3,index_3,0,98,"f64Ne","f64.ne"),opcode(index_1,index_3,index_3,0,99,"f64Lt","f64.lt"),opcode(index_1,index_3,index_3,0,100,"f64Gt","f64.gt"),opcode(index_1,index_3,index_3,0,101,"f64Le","f64.le"),opcode(index_1,index_3,index_3,0,102,"f64Ge","f64.ge"),opcode(index_1,index_1,___,0,103,"i32Clz","i32.clz"),opcode(index_1,index_1,___,0,104,"i32Ctz","i32.ctz"),opcode(index_1,index_1,___,0,105,"i32Popcnt","i32.popcnt"),opcode(index_1,index_1,index_1,0,106,"i32Add","i32.add"),opcode(index_1,index_1,index_1,0,107,"i32Sub","i32.sub"),opcode(index_1,index_1,index_1,0,108,"i32Mul","i32.mul"),opcode(index_1,index_1,index_1,0,109,"i32DivS","i32.div_s"),opcode(index_1,index_1,index_1,0,110,"i32DivU","i32.div_u"),opcode(index_1,index_1,index_1,0,111,"i32RemS","i32.rem_s"),opcode(index_1,index_1,index_1,0,112,"i32RemU","i32.rem_u"),opcode(index_1,index_1,index_1,0,113,"i32And","i32.and"),opcode(index_1,index_1,index_1,0,114,"i32Or","i32.or"),opcode(index_1,index_1,index_1,0,115,"i32Xor","i32.xor"),opcode(index_1,index_1,index_1,0,116,"i32Shl","i32.shl"),opcode(index_1,index_1,index_1,0,117,"i32ShrS","i32.shr_s"),opcode(index_1,index_1,index_1,0,118,"i32ShrU","i32.shr_u"),opcode(index_1,index_1,index_1,0,119,"i32Rotl","i32.rotl"),opcode(index_1,index_1,index_1,0,120,"i32Rotr","i32.rotr"),opcode(index_2,index_2,___,0,121,"i64Clz","i64.clz"),opcode(index_2,index_2,___,0,122,"i64Ctz","i64.ctz"),opcode(index_2,index_2,___,0,123,"i64Popcnt","i64.popcnt"),opcode(index_2,index_2,index_2,0,124,"i64Add","i64.add"),opcode(index_2,index_2,index_2,0,125,"i64Sub","i64.sub"),opcode(index_2,index_2,index_2,0,126,"i64Mul","i64.mul"),opcode(index_2,index_2,index_2,0,127,"i64DivS","i64.div_s"),opcode(index_2,index_2,index_2,0,128,"i64DivU","i64.div_u"),opcode(index_2,index_2,index_2,0,129,"i64RemS","i64.rem_s"),opcode(index_2,index_2,index_2,0,130,"i64RemU","i64.rem_u"),opcode(index_2,index_2,index_2,0,131,"i64And","i64.and"),opcode(index_2,index_2,index_2,0,132,"i64Or","i64.or"),opcode(index_2,index_2,index_2,0,133,"i64Xor","i64.xor"),opcode(index_2,index_2,index_2,0,134,"i64Shl","i64.shl"),opcode(index_2,index_2,index_2,0,135,"i64ShrS","i64.shr_s"),opcode(index_2,index_2,index_2,0,136,"i64ShrU","i64.shr_u"),opcode(index_2,index_2,index_2,0,137,"i64Rotl","i64.rotl"),opcode(index_2,index_2,index_2,0,138,"i64Rotr","i64.rotr"),opcode(index_3,index_3,index_3,0,139,"f32Abs","f32.abs"),opcode(index_3,index_3,index_3,0,140,"f32Neg","f32.neg"),opcode(index_3,index_3,index_3,0,141,"f32Ceil","f32.ceil"),opcode(index_3,index_3,index_3,0,142,"f32Floor","f32.floor"),opcode(index_3,index_3,index_3,0,143,"f32Trunc","f32.trunc"),opcode(index_3,index_3,index_3,0,144,"f32Nearest","f32.nearest"),opcode(index_3,index_3,index_3,0,145,"f32Sqrt","f32.sqrt"),opcode(index_3,index_3,index_3,0,146,"f32Add","f32.add"),opcode(index_3,index_3,index_3,0,147,"f32Sub","f32.sub"),opcode(index_3,index_3,index_3,0,148,"f32Mul","f32.mul"),opcode(index_3,index_3,index_3,0,149,"f32Div","f32.div"),opcode(index_3,index_3,index_3,0,150,"f32Min","f32.min"),opcode(index_3,index_3,index_3,0,151,"f32Max","f32.max"),opcode(index_3,index_3,index_3,0,152,"f32Copysign","f32.copysign"),opcode(index_3,index_3,index_3,0,153,"f32Abs","f64.abs"),opcode(index_3,index_3,index_3,0,154,"f32Neg","f64.neg"),opcode(index_3,index_3,index_3,0,155,"f32Ceil","f64.ceil"),opcode(index_3,index_3,index_3,0,156,"f32Floor","f64.floor"),opcode(index_3,index_3,index_3,0,157,"f32Trunc","f64.trunc"),opcode(index_3,index_3,index_3,0,158,"f32Nearest","f64.nearest"),opcode(index_3,index_3,index_3,0,159,"f32Sqrt","f64.sqrt"),opcode(index_4,index_4,index_4,0,160,"f64Add","f64.add"),opcode(index_4,index_4,index_4,0,161,"f64Sub","f64.sub"),opcode(index_4,index_4,index_4,0,162,"f64Mul","f64.mul"),opcode(index_4,index_4,index_4,0,163,"f64Div","f64.div"),opcode(index_4,index_4,index_4,0,164,"f64Min","f64.min"),opcode(index_4,index_4,index_4,0,165,"f64Max","f64.max"),opcode(index_4,index_4,index_4,0,166,"f64Copysign","f64.copysign"),opcode(index_1,index_2,___,0,167,"i32Wrapi64","i32.wrap/i64"),opcode(index_1,index_3,___,0,168,"i32TruncSf32","i32.trunc_s/f32"),opcode(index_1,index_3,___,0,169,"i32TruncUf32","i32.trunc_u/f32"),opcode(index_1,index_3,___,0,170,"i32TruncSf64","i32.trunc_s/f64"),opcode(index_1,index_3,___,0,171,"i32TruncUf64","i32.trunc_u/f64"),opcode(index_2,index_1,___,0,172,"i64ExtendSi32","i64.extend_s/i32"),opcode(index_2,index_1,___,0,173,"i64ExtendUi32","i64.extend_u/i32"),opcode(index_2,index_3,___,0,174,"i64TruncSf32","i64.trunc_s/f32"),opcode(index_2,index_3,___,0,175,"i64TruncUf32","i64.trunc_u/f32"),opcode(index_2,index_3,___,0,176,"i64TruncSf64","i64.trunc_s/f64"),opcode(index_2,index_3,___,0,177,"i64TruncUf64","i64.trunc_u/f64"),opcode(index_3,index_1,___,0,178,"f32ConvertSi32","f32.convert_s/i32"),opcode(index_3,index_1,___,0,179,"f32ConvertUi32","f32.convert_u/i32"),opcode(index_3,index_2,___,0,180,"f32ConvertSi64","f32.convert_s/i64"),opcode(index_3,index_2,___,0,181,"f32ConvertUi64","f32.convert_u/i64"),opcode(index_3,index_3,___,0,182,"f32Demotef64","f32.demote/f64"),opcode(index_3,index_1,___,0,183,"f64ConvertSi32","f64.convert_s/i32"),opcode(index_3,index_1,___,0,184,"f64ConvertUi32","f64.convert_u/i32"),opcode(index_3,index_2,___,0,185,"f64ConvertSi64","f64.convert_s/i64"),opcode(index_3,index_2,___,0,186,"f64ConvertUi64","f64.convert_u/i64"),opcode(index_3,index_3,___,0,187,"f64Promotef32","f64.promote/f32"),opcode(index_1,index_3,___,0,188,"i32Reinterpretf32","i32.reinterpret/f32"),opcode(index_2,index_3,___,0,189,"i64Reinterpretf64","i64.reinterpret/f64"),opcode(index_3,index_1,___,0,190,"f32Reinterpreti32","f32.reinterpret/i32"),opcode(index_3,index_2,___,0,191,"f32Reinterpreti64","f64.reinterpret/i64");const getTypecastOpcode=(e,n)=>{const t=e[0];if("i32"===e&&"i64"===n)return def.i32Wrapi64;if("i64"===e&&"i32"===n)return def.i64ExtendSi32;if("f32"===e&&"f64"===n)return def.f32Demotef64;if("f64"===e&&"f32"===n)return def.f64Promotef32;const r="f"===t?"ConvertS":"TruncS";return def[e+r+n]},opcodeFromOperator=({type:e,value:n})=>{const t={"+":def[String(e)+"Add"],"-":def[String(e)+"Sub"],"*":def[String(e)+"Mul"],"/":def[String(e)+"DivS"]||def[String(e)+"Div"],"%":def[String(e)+"RemS"]||def[String(e)+"RemU"],"==":def[String(e)+"Eq"],"!=":def[String(e)+"Ne"],">":def[String(e)+"Gt"]||def[String(e)+"GtS"],"<":def[String(e)+"Lt"]||def[String(e)+"LtS"],"<=":def[String(e)+"Le"]||def[String(e)+"LeS"],">=":def[String(e)+"Ge"]||def[String(e)+"GeS"],"?":def.If,":":def.Else,"&":def[String(e)+"And"],"|":def[String(e)+"Or"],"^":def[String(e)+"Xor"],">>":def[String(e)+"ShrS"],">>>":def[String(e)+"ShrU"],"<<":def[String(e)+"Shl"]};return t[n]},encode=(e,{type:n,init:t,mutable:r})=>{e.push(index_9,n,getTypeString(n));e.push(index_9,r,"mutable");switch(n){case I32:e.push(index_9,def.i32Const.code,def.i32Const.text),e.push(varint32,t,`value (${t})`);break;case F32:e.push(index_9,def.f32Const.code,def.f32Const.text),e.push(index_3,t,`value (${t})`);break;case F64:e.push(index_9,def.f64Const.code,def.f64Const.text),e.push(index_4,t,`value (${t})`)}e.push(index_9,def.End.code,"end")},emit$3=e=>{const n=new OutputStream;n.push(varuint32,e.length,"count");e.forEach(e=>encode(n,e));return n},emit$4=e=>{e=e.filter(e=>null!==e);const n=new OutputStream;n.push(varuint32,e.length,"count");e.forEach(e=>n.push(varuint32,e,"type index"));return n},emitElement=e=>({functionIndex:n},t)=>{e.push(varuint32,0,"table index");e.push(index_9,def.i32Const.code,"offset");e.push(varuint32,t,t.toString());e.push(index_9,def.End.code,"end");e.push(varuint32,1,"number of elements");e.push(varuint32,n,"function index")},emit$5=e=>{const n=new OutputStream;n.push(varuint32,e.length,"count");e.forEach(emitElement(n));return n},emitType=(e,{params:n,result:t},r)=>{e.push(varint7,FUNC,`func type (${r})`);e.push(varuint32,n.length,"parameter count");n.forEach(n=>e.push(varint7,n,"param"));t?(e.push(varint1,1,"result count"),e.push(varint7,t,`result type ${getTypeString(t)}`)):e.push(varint1,0,"result count")},emit$6=e=>{const n=new OutputStream;n.push(varuint32,e.length,"count");e.forEach((e,t)=>emitType(n,e,t));return n},emitLocal=(e,n)=>{null==n.isParam&&(e.push(varuint32,1,"number of locals of following type"),e.push(varint7,n.type,`${getTypeString(n.type)}`))},emitFunctionBody=(e,{locals:n,code:t,debug:r})=>{const a=new OutputStream;t.forEach(({kind:e,params:n,valueType:t,debug:r})=>{a.push(index_9,e.code,`${e.text}  ${r||""}`);t&&(a.push(index_9,t.type,"result type"),a.push(index_9,t.mutable,"mutable"));(n||[]).forEach(n=>{let t=varuint32;let r="i32.literal";if(e.code>=40&&e.code<=62)t=varuint32,r="memory_immediate";else switch(e.result){case index_9:t=index_9;break;case index_4:t=index_4,r="f64.literal";break;case index_3:t=index_3,r="f32.literal";break;case index_1:t=varint32,r="i32.literal";break;case index_2:t=varint64,r="i64.literal";break;default:t=varuint32}a.push(t,n,`${r}`)})});const i=new OutputStream;n.forEach(e=>emitLocal(i,e));e.push(varuint32,a.size+i.size+2,r);e.push(varuint32,n.length,"locals count");e.write(i);e.write(a);e.push(index_9,def.End.code,"end")},emit$7=e=>{const n=new OutputStream;n.push(varuint32,e.length,"function count");e.forEach(e=>emitFunctionBody(n,e));return n},emitEntry=(e,n)=>{e.push(varint1,n.max?1:0,"has no max");e.push(varuint32,n.initial,"initial memory size(PAGES)");n.max&&e.push(varuint32,n.max,"max memory size(PAGES)")},emit$8=e=>{const n=new OutputStream;n.push(varuint32,e.length,"count");e.forEach(e=>emitEntry(n,e));return n},typeBytecodes={anyfunc:112},emitEntry$1=(e,n)=>{e.push(varint7,typeBytecodes[n.type],n.type);e.push(varint1,n.max?1:0,"has max");e.push(varuint32,n.initial,"initial table size");n.max&&e.push(varuint32,n.max,"max table size")},emitModuleName=e=>{const n=new OutputStream;emitString(n,e,`name_len: ${e}`);return n},emitFunctionNames=e=>{const n=new OutputStream;n.push(varuint32,e.length,`count: ${String(e.length)}`);e.forEach(({index:e,name:t})=>{n.push(varuint32,e,`index: ${String(e)}`);emitString(n,t,`name_len: ${t}`)});return n},emitLocals=e=>{const n=new OutputStream;n.push(varuint32,e.length,`count: ${String(e.length)}`);e.forEach(({index:e,locals:t})=>{n.push(varuint32,e,`function index: ${String(e)}`);n.push(varuint32,t.length,`number of params and locals ${t.length}`);t.forEach(({index:e,name:t})=>{n.push(varuint32,e,`index: ${String(e)}`);emitString(n,t,`name_len: ${t}`)})});return n},emit$9=e=>{const n=new OutputStream;emitString(n,"name","name_len: name");const t=emitModuleName(e.module);n.push(varuint7,0,"name_type: Module");n.push(varuint32,t.size,"name_payload_len");n.write(t);const r=emitFunctionNames(e.functions);n.push(varuint7,1,"name_type: Function");n.push(varuint32,r.size,"name_payload_len");n.write(r);const a=emitLocals(e.locals);n.push(varuint7,2,"name_type: Locals");n.push(varuint32,a.size,"name_payload_len");n.write(a);return n},SECTION_TYPE=1,SECTION_IMPORT=2,SECTION_FUNCTION=3,SECTION_TABLE=4,SECTION_MEMORY=5,SECTION_GLOBAL=6,SECTION_EXPORT=7,SECTION_ELEMENT=9,SECTION_CODE=10,SECTION_NAME=0,writer=({type:e,label:n,emitter:t})=>r=>{const a=r[n];if(!a||Array.isArray(a)&&!a.length)return null;const i=(new OutputStream).push(index_9,e,n+" section");const o=t(a);i.push(varuint32,o.size,"size");i.write(o);return i};var section={type:writer({type:SECTION_TYPE,label:"Types",emitter:emit$6}),imports:writer({type:SECTION_IMPORT,label:"Imports",emitter:emit$1}),function:writer({type:SECTION_FUNCTION,label:"Functions",emitter:emit$4}),table:writer({type:SECTION_TABLE,label:"Table",emitter:emitTables}),memory:writer({type:SECTION_MEMORY,label:"Memory",emitter:emit$8}),exports:writer({type:SECTION_EXPORT,label:"Exports",emitter:emit$2}),globals:writer({type:SECTION_GLOBAL,label:"Globals",emitter:emit$3}),element:writer({type:SECTION_ELEMENT,label:"Element",emitter:emit$5}),code:writer({type:SECTION_CODE,label:"Code",emitter:emit$7}),name:writer({type:SECTION_NAME,label:"Name",emitter:emit$9})};const mergeBlock=(e,n)=>{Array.isArray(n)?e=[...e,...n]:e.push(n);return e},FUNCTION_INDEX="function/index",LOCAL_INDEX="local/index",GLOBAL_INDEX="global/index",TYPE_CONST="type/const",TYPE_ARRAY="type/array",TYPE_OBJECT="type/object",TYPE_INDEX="type/index",OBJECT_SIZE="object/size",TYPE_CAST="type/cast",OBJECT_KEY_TYPES="object/key-types",CLOSURE_TYPE="closure/type",AST_METADATA="@@global/ast",FUNCTION_METADATA="@@function/meta",ALIAS="alias",generateFunctionCall=(e,n)=>{const t=e.params.map(mapSyntax(n)).reduce(mergeBlock,[]);const r=e.meta[FUNCTION_INDEX];t.push({kind:def.Call,params:[r],debug:`${e.value}<${e.type?e.type:"void"}>`});return t},generateIndirectFunctionCall=(e,n)=>{const t=e.params.map(mapSyntax(n)).reduce(mergeBlock,[]);const r=e.meta[LOCAL_INDEX];const a=e.meta[TYPE_INDEX];invariant_1(null!=r,"Undefined local index, not a valid function pointer");invariant_1(null!=a,"Variable is not of a valid function pointer type");return[...t,{kind:def.CallIndirect,params:[a,0]}]},generateBinaryExpression=(e,n)=>{const t=e.params.map(mapSyntax(n)).reduce(mergeBlock,[]);t.push({kind:opcodeFromOperator(_extends({},e,{type:e.type})),params:[]});return t};var slice=Array.prototype.slice,toArray$1=function(e){return slice.call(e)},tail=function(e){return slice.call(e,1)},createFn=function(e,n,t){var r=t-n.length;switch(r){case 0:return function(){return processInvocation(e,concatArgs(n,arguments),t)};case 1:return function(r){return processInvocation(e,concatArgs(n,arguments),t)};case 2:return function(r,a){return processInvocation(e,concatArgs(n,arguments),t)};case 3:return function(r,a,i){return processInvocation(e,concatArgs(n,arguments),t)};case 4:return function(r,a,i,o){return processInvocation(e,concatArgs(n,arguments),t)};case 5:return function(r,a,i,o,s){return processInvocation(e,concatArgs(n,arguments),t)};case 6:return function(r,a,i,o,s,u){return processInvocation(e,concatArgs(n,arguments),t)};case 7:return function(r,a,i,o,s,u,c){return processInvocation(e,concatArgs(n,arguments),t)};case 8:return function(r,a,i,o,s,u,c,p){return processInvocation(e,concatArgs(n,arguments),t)};case 9:return function(r,a,i,o,s,u,c,p,l){return processInvocation(e,concatArgs(n,arguments),t)};case 10:return function(r,a,i,o,s,u,c,p,l,d){return processInvocation(e,concatArgs(n,arguments),t)};default:return createEvalFn(e,n,r)}},concatArgs=function(e,n){return e.concat(toArray$1(n))},createEvalFn=function(fn,args,arity){var argList=makeArgList(arity),fnStr="false||function("+argList+"){ return processInvocation(fn, concatArgs(args, arguments)); }";return eval(fnStr)},makeArgList=function(e){for(var n=[],t=0;t<e;t+=1)n.push("a"+t.toString());return n.join(",")},trimArrLength=function(e,n){return e.length>n?e.slice(0,n):e},processInvocation=function(e,n,t){return n=trimArrLength(n,t),n.length===t?e.apply(null,n):createFn(e,n,t)},curry=function(e){return createFn(e,[],e.length)};curry.to=curry(function(e,n){return createFn(n,[],e)}),curry.adaptTo=curry(function(e,n){return curry.to(e,function(e){var t=tail(arguments).concat(e);return n.apply(this,t)})}),curry.adapt=function(e){return curry.adaptTo(e.length,e)};var curry_1=curry;const scopeOperation=curry_1((e,n)=>{const t=n.meta[LOCAL_INDEX];const r=n.meta[GLOBAL_INDEX];const a=null!=t?t:r;invariant_1(null!=a,`Unefined index for scope Operation. Possibly missing metadata. op: ${JSON.stringify(e)} node: ${JSON.stringify(n,null,2)}`);const i=null!=t?e+"Local":e+"Global";const o=[Number(a)];return{kind:def[i],params:o,debug:`${n.value}<${n.type?n.type:"?"}>`}}),getConstOpcode=e=>{const n=e.type||builtinTypes.i32;const t=def[n+"Const"]||def.i32Const;const r=[Number(e.value)];return[{kind:t,params:r}]},getType=e=>{switch(e){case builtinTypes.f32:return F32;case builtinTypes.f64:return F64;case builtinTypes.i64:return I64;case builtinTypes.i32:default:return I32}},isBuiltinType=e=>"string"==typeof e&&null!=builtinTypes[e],generateValueType=e=>({mutable:e.meta[TYPE_CONST]?0:1,type:getType(e.type)}),setInScope=scopeOperation("Set"),getInScope=scopeOperation("Get"),generateTernary=(e,n)=>{const t=mapSyntax(n);const r=e.params[1];const a=e.params.slice(0,1).map(t).reduce(mergeBlock,[]);a.push({kind:opcodeFromOperator(e),valueType:generateValueType(e),params:[]});a.push.apply(a,r.params.slice(0,1).map(t).reduce(mergeBlock,[]));a.push({kind:opcodeFromOperator({value:":",type:"i32"}),params:[]});a.push.apply(a,r.params.slice(-1).map(t).reduce(mergeBlock,[]));a.push({kind:def.End,params:[]});return a},generateIf=(e,n)=>{const t=mapSyntax(n);const[r,a,...i]=e.params;return[...[r].map(t).reduce(mergeBlock,[]),{kind:def.If,params:[64]},...[a].map(t).reduce(mergeBlock,[]),...i.map(t).reduce(mergeBlock,[]),{kind:def.End,params:[]}]},generateFunctionPointer=e=>[{kind:def.i32Const,params:[Number(e.value)]}],generateReturn=e=>{const n=e.params.map(mapSyntax(null)).reduce(mergeBlock,[]);n.push({kind:def.Return,params:[]});return n},generateExpression=(e,n)=>[e].map(mapSyntax(n)).reduce(mergeBlock,[]),generateDeclaration=(e,n={code:[],locals:[]})=>{const t=e.params[0];if(t){const r=e.meta[LOCAL_INDEX],a=isBuiltinType(e.type)?e.type:i32;return[...generateExpression(_extends({},t,{type:a}),n),{kind:def.SetLocal,params:[r],debug:`${e.value}<${String(e.type)}>`}]}return[]},generateArraySubscript=(e,n)=>{const t=e.params[0];const r=t.meta[TYPE_ARRAY];const a=e.params.map(mapSyntax(n)).reduce(mergeBlock,[]);let i=e.type;null!=r&&(a.push.apply(a,[{kind:def.i32Const,params:[2]},{kind:def.i32Shl,params:[]}]),i=r);a.push({kind:def.i32Add,params:[]});a.push({kind:def[(i||"i32")+"Load"],params:[2,0]});return a},generateAssignment=e=>{const[n,t]=e.params;const r=[t].map(mapSyntax(null)).reduce(mergeBlock,[]);r.push(setInScope(n));return r},generateMemoryAssignment=(e,n)=>{const t=e.params[0];const r=t.params[0].meta[TYPE_ARRAY];let a=e.type;const i=e.params[0].params.map(mapSyntax(n)).reduce(mergeBlock,[]);null!=r&&(i.push.apply(i,[{kind:def.i32Const,params:[2]},{kind:def.i32Shl,params:[]}]),a=r);i.push({kind:def.i32Add,params:[]});i.push.apply(i,e.params.slice(1).map(mapSyntax(n)).reduce(mergeBlock,[]));i.push({kind:def[(a||"i32")+"Store"],params:[2,0]});return i},generateLoop=(e,n)=>{const t=[];const r=mapSyntax(n);const[a,i,...o]=e.params;t.push.apply(t,[a].map(r).reduce(mergeBlock,[]));t.push({kind:def.Block,params:[64]});t.push({kind:def.Loop,params:[64]});t.push.apply(t,[i].map(r).reduce(mergeBlock,[]));t.push({kind:def.BrIf,params:[1]});t.push.apply(t,o.map(r).reduce(mergeBlock,[]));t.push({kind:def.Br,params:[0]});t.push({kind:def.End,params:[]});t.push({kind:def.End,params:[]});return t},generateSequence=(e,n)=>e.params.map(mapSyntax(n)).reduce(mergeBlock,[]),generateTypecast=(e,n)=>{const t=e.meta[TYPE_CAST];invariant_1(t,`Cannot generate typecast for node: ${JSON.stringify(e)}`);const{to:r,from:a}=t;const i=e.params.map(mapSyntax(n)).reduce(mergeBlock,[]);return[...i,{kind:getTypecastOpcode(r,a),params:[]}]},generateTypecast$2=()=>[{kind:def.Br,params:[2]}],generateBlock=(e,n)=>e.params.map(mapSyntax(n)).reduce(mergeBlock,[]),generateElse=(e,n)=>[{kind:def.Else,params:[]},...e.params.map(mapSyntax(n)).reduce(mergeBlock,[])],generateSelect=(e,n)=>{const[t,r]=e.params;const a={kind:def.Select,params:[]};const i=[t].map(mapSyntax(n)).reduce(mergeBlock,[]);if("&&"===e.value)return[...[r].map(mapSyntax(n)).reduce(mergeBlock,[]),{kind:def.i32Const,params:[0]},...i,a];return[...i,...[r].map(mapSyntax(n)).reduce(mergeBlock,[]),...i,a]},parseBounds=e=>{const n={};walker({[Syntax.Pair]:({params:e})=>{const[{value:t},{value:r}]=e;n[t]=parseInt(r)}})(e);return n},getText=e=>{const n=e.value||"??";const t=e.type;const r=t||"i32";const a=opcodeFromOperator({value:n,type:r});if(!t)return a.text.replace("i32","??");return a.text},parseParams=e=>{const n=[];walker({[Syntax.Pair]:(e,t)=>{n.push(`${e.params[0].value} ${e.params[1].value}`)},[Syntax.Type]:e=>{n.push(e.value)}})(e);return n.length?" param("+n.join(" ")+")":""},parseResult=e=>{if(null==e)return"";return" (result "+(e.type||"??")+")"},typedefString=e=>{const[n,t]=e.params;return"(type "+e.value+` (func${parseParams(n)}${parseResult(t)}))`},getPrinters=e=>({[Syntax.Import]:(n,t)=>{const[r,a]=n.params;walker({[Syntax.Pair]:({params:n},t)=>{const{value:r}=n[0];const i=n[1];if("Memory"===i.value){const n=parseBounds(i);e(`(import "${a.value}" "${r}" (memory ${n.initial}${n.max?n.max:""}))`)}else e(`(import "${a.value}" "${r}" ${typedefString(i)})`)}})(r)},[Syntax.Export]:(n,t)=>{e("(export",2);n.params.forEach(t);e(")",0,-2)},[Syntax.GenericType]:(n,t)=>{e("(type-generic "+n.value+")",0,0," pseudo type")},[Syntax.FunctionCall]:(n,t)=>{n.params.length>0?(e(`(call ${n.value}`,2),n.params.forEach(t),e(")",0,-2)):e(`(call ${n.value})`)},[Syntax.BinaryExpression]:(n,t)=>{const r=getText(n);e("("+r,2);n.params.forEach(t);e(")",0,-2)},[Syntax.ArraySubscript]:(n,t)=>{e("(i32.add",2);n.params.forEach(t);e(")",0,-2)},[Syntax.Typedef]:(n,t)=>{e(typedefString(n))},[Syntax.Identifier]:n=>{const t=null!=n.meta[GLOBAL_INDEX]?"global":"local";e(`(get_${t} ${n.value})`)},[Syntax.Constant]:n=>{e(`(${String(n.type)}.const ${n.value})`)},[Syntax.FunctionDeclaration]:(n,t)=>{const[r,a,...i]=n.params;e(`(func ${n.value}${parseParams(r)}${parseResult(a)}`,2);i.forEach(t);e(")",0,-2)},[Syntax.ReturnStatement]:(n,t)=>{e("(return",2);n.params.forEach(t);e(")",0,-2)},[Syntax.Declaration]:(n,t)=>{const r=null!=n.meta[TYPE_CONST]?"immutable":"mutable";e("(local "+n.value+" "+String(n.type),2,0,` ${r}`);n.params.forEach(t);e(")",0,-2)},[Syntax.ImmutableDeclaration]:(n,t)=>{const r=null!=n.meta[GLOBAL_INDEX]?"global":"local";if("Memory"===n.type){const t=parseBounds(n);e(`(memory ${t.initial}${t.max?` ${t.max}`:""})`)}else e(`(${r} `+n.value+" "+String(n.type),2,0," immutable"),n.params.forEach(t),e(")",0,-2)},[Syntax.Type]:n=>{e(n.value)},[Syntax.TypeCast]:(n,t)=>{const r=n.params[0];const a=getTypecastOpcode(String(n.type),r.type);e("("+a.text,2);n.params.forEach(t);e(")",0,-2)},[Syntax.ArraySubscript]:(n,t)=>{e("("+String(n.type)+".load",2,0);n.params.forEach(t);e(")",0,-2)},[Syntax.MemoryAssignment]:(n,t)=>{e("("+String(n.type)+".store",2,0);n.params.forEach(t);e(")",0,-2)},[Syntax.Assignment]:(n,t)=>{const[r,...a]=n.params;const i=null!=r.meta[GLOBAL_INDEX]?"global":"local";e(`(set_${i} ${r.value}`,2);a.forEach(t);e(")",0,-2)},[Syntax.TernaryExpression]:(n,t)=>{const[r,a]=n.params;e("(select",2);t(a);t(r);e(")",0,-2)},[Syntax.IfThenElse]:(n,t)=>{const[r,a,...i]=n.params;e("(if",2);t(r);e("(then",2);t(a);e(")",0,-2);i.length>0&&(e("(else",2),i.forEach(t),e(")",0,-2));e(")",0,-2)},[Syntax.ObjectLiteral]:(e,n)=>{}}),printNode=e=>{if(null==e)return"";let n=0;const t=[];const r=[];const a=[];const i=(e,i=0,o=0,s="")=>{n+=o;a.push(s);r.push(e);t.push(n+e.length);n+=i};walker(getPrinters(i))(e);const o=Math.max(...t);const s=o+4;const u=r.reduce((e,n,r)=>{e+=n.padStart(t[r]," ").padEnd(s," ")+";"+a[r]+"\n";return e},"");return u},syntaxMap={[Syntax.FunctionCall]:generateFunctionCall,[Syntax.IndirectFunctionCall]:generateIndirectFunctionCall,[Syntax.Constant]:getConstOpcode,[Syntax.BinaryExpression]:generateBinaryExpression,[Syntax.TernaryExpression]:generateTernary,[Syntax.IfThenElse]:generateIf,[Syntax.Else]:generateElse,[Syntax.Select]:generateSelect,[Syntax.Block]:generateBlock,[Syntax.Identifier]:getInScope,[Syntax.FunctionIdentifier]:getInScope,[Syntax.FunctionPointer]:generateFunctionPointer,[Syntax.ReturnStatement]:generateReturn,[Syntax.Declaration]:generateDeclaration,[Syntax.ArraySubscript]:generateArraySubscript,[Syntax.Assignment]:generateAssignment,[Syntax.MemoryAssignment]:generateMemoryAssignment,[Syntax.Loop]:generateLoop,[Syntax.Break]:generateTypecast$2,[Syntax.Sequence]:generateSequence,[Syntax.TypeCast]:generateTypecast,[Syntax.Noop]:generateNoop},mapSyntax=curry_1((e,n)=>{const t=syntaxMap[n.Type];if(!t){const e=n.id||n.value||n.operator&&n.operator.value;throw new Error(`Unexpected Syntax Token ${n.Type} : ${e}`)}const r=(e,t)=>invariant_1(e.kind,"Unknown opcode generated in block index %s %s. \nOperand: \n%s",t,JSON.stringify(e),printNode(n));const a=t(n,e);Array.isArray(a)&&a.forEach(r);return a}),generateElement=e=>({functionIndex:e}),generateMemory=e=>{const n={max:0,initial:0};walker({[Syntax.Pair]:({params:e})=>{const[{value:t},{value:r}]=e;n[t]=parseInt(r)}})(e);return n},generateInit=e=>{const n=generateValueType(e);const[t]=e.params;if(null!=t){const{value:e}=t;switch(n.type){case F32:case F64:n.init=parseFloat(e);break;case I32:case I64:default:n.init=parseInt(e)}}return n},getKindConstant=e=>{switch(e){case"Memory":return EXTERN_MEMORY;case"Table":return EXTERN_TABLE;case"i32":case"f32":case"i64":case"f64":return EXTERN_GLOBAL;default:return EXTERN_FUNCTION}},getType$1=e=>{switch(e){case"f32":return F32;case"f64":return F64;case"i64":return I64;case"i32":case"Function":default:return I32}},generateImplicitFunctionType=e=>{const[n]=e.params;const t=e.type?getType$1(e.type):null;const r=[];walker({[Syntax.Pair]:e=>{const n=e.params[1];invariant_1(n,"Undefined type in a argument expression");r.push(getType$1(n.value))}})(n);return{params:r,result:t,id:e.value}},generateCode=e=>{const[n,t,...r]=e.params;const a=e.meta[FUNCTION_METADATA];invariant_1(r,"Cannot generate code for function without body");invariant_1(a,"Cannot generate code for function without metadata");const{locals:i,argumentsCount:o}=a;const s={code:[],locals:Object.keys(i).slice(o).map(e=>generateValueType(i[e])),debug:`Function ${e.value}`};const u=r.map(mapSyntax(s));u&&(s.code=u.reduce(mergeBlock,[]));return s},mapImport=curry_1((e,n,t)=>mapNode({[Syntax.Pair]:(n,t)=>{const{types:r,functions:a,globals:i}=e;const[o,s]=n.params;if(null!=r[s.value]){const e=Object.keys(a).length,t=Object.keys(r).indexOf(s.value),i=_extends({},o,{id:o.value,type:r[s.value].type,meta:{[FUNCTION_INDEX]:e,[TYPE_INDEX]:t}});return a[o.value]=i,_extends({},n,{params:[i,r[s.value]]})}if("Table"!==s.type&&"Memory"!==s.type){const e=Object.keys(i).length;i[o.value]=_extends({},o,{meta:{[GLOBAL_INDEX]:e,[TYPE_CONST]:!0},type:s.type})}return n}})(n)),getTypeSize=e=>{switch(e){case"i64":case"f64":return 8;case"i32":case"f32":default:return 4}},isClosureType=(e,n)=>null!=e[n]&&!!e[n].meta[CLOSURE_TYPE],parse$2=(e,{types:n,scope:t},r)=>{const a=Object.keys(t).length;const i=r.type;const o=r.type.slice(-2);const s="[]"===o;const u=isClosureType(n,i);const c=(()=>{if(s)return"i32";if(u)return"i64";return r.type})();const p={[TYPE_ARRAY]:s?i.slice(0,-2):null,[CLOSURE_TYPE]:u||null,[TYPE_CONST]:e||null,[TYPE_INDEX]:u?Object.keys(n).indexOf(i):null};return[c,p,a]},parseDeclaration=curry_1((e,n,t)=>{const{locals:r,closures:a}=n;if(null==r[t.value]){const[i,o,s]=parse$2(e,_extends({},n,{scope:r}),t);r[t.value]=_extends({},t,{type:i,meta:_extends({},o,{[LOCAL_INDEX]:s}),Type:Syntax.Declaration});const{variables:u}=a;if(null!=u[t.value]&&t.params[0]){const{offsets:e}=a;e[t.value]=a.envSize,a.envSize+=getTypeSize(t.type)}}}),parseGlobalDeclaration=curry_1((e,n,t)=>{const{globals:r}=n;if("Table"!==t.type&&"Memory"!==t.type){const[a,i,o]=parse$2(e,_extends({},n,{scope:r}),t);return r[t.value]=_extends({},t,{meta:_extends({},i,{[GLOBAL_INDEX]:o}),type:a,Type:Syntax.Declaration}),r[t.value]}return _extends({},t,{meta:{[GLOBAL_INDEX]:-1}})}),patchStringSubscript=(e,n)=>{const t=n[1];const r=e[t.value];return[n[0],_extends({},t,{meta:{[ALIAS]:t.value},value:r,type:"i32",Type:Syntax.Constant})]},mapArraySubscript=curry_1(({userTypes:e},n,t)=>{const r=n.params.map(t);const[a,i]=r;const o=e[a.type];if(null!=o){const e=o.meta[TYPE_OBJECT],t=o.meta[OBJECT_KEY_TYPES];return _extends({},n,{type:t?t[i.value]:"i32",params:patchStringSubscript(e,r)})}const s=a.type;return _extends({},n,{type:s,params:r})}),mapIdentifier=curry_1(({locals:e,globals:n,functions:t,table:r,userTypes:a},i)=>{const o=e[i.value];const s=n[i.value];if(null!=o){const e=(()=>{const e=o.meta[TYPE_ARRAY];return e||o.type})();return _extends({},i,{type:e,meta:_extends({},o.meta)})}if(null!=s)return _extends({},i,{type:n[i.value].type,meta:_extends({},s.meta)});if(null!=a[i.value])return _extends({},i,{type:"i32",Type:Syntax.UserType});if(null!=t[i.value])return null==r[i.value]&&(r[i.value]=t[i.value]),_extends({},i,{type:"i32",meta:{[FUNCTION_INDEX]:Object.keys(t).indexOf(i.value)},value:Object.keys(r).indexOf(i.value),Type:Syntax.FunctionPointer});return i}),variableSize=e=>{switch(e){case"i64":case"f64":return"8";case"i32":case"f32":default:return"4"}},mapSizeof=curry_1(({locals:e,globals:n,functions:t,userTypes:r},a)=>{const[i]=a.params;const o=e[i.value];const s=n[i.value];const u=r[i.value]||(o?r[o.type]:null);const c=t[i.value];if(null!=u){const e=u.meta[OBJECT_SIZE];return invariant_1(e,"Object size information is missing"),_extends({},a,{value:e,params:[],type:"i32",Type:Syntax.Constant})}const p=o||s||u||c;return _extends({},a,{value:variableSize(p?p.type:i.value),type:"i32",params:[],Type:Syntax.Constant})});var makeAssignment=curry_1(function(e,n,t){const[r,a]=n.params;if(a&&a.Type===Syntax.ObjectLiteral){const n={},i={};walker({[Syntax.Identifier]:(e,t)=>{n[e.value]=_extends({},r,{Type:Syntax.MemoryAssignment,params:[_extends({},r,{Type:Syntax.ArraySubscript,params:[r,e]}),e]})},[Syntax.Pair]:(e,t)=>{const[a,i]=e.params;n[a.value]=_extends({},r,{Type:Syntax.MemoryAssignment,params:[_extends({},r,{Type:Syntax.ArraySubscript,params:[r,a]}),i]})},[Syntax.Spread]:(n,t)=>{const{locals:a,userTypes:o}=e;const[s]=n.params;const u=o[a[s.value].type];const c=u.meta[TYPE_OBJECT];null!=c&&Object.keys(c).forEach(e=>{const n=_extends({},s,{Type:Syntax.Identifier,value:e,params:[]});i[e]=_extends({},r,{Type:Syntax.MemoryAssignment,params:[_extends({},r,{Type:Syntax.ArraySubscript,params:[r,_extends({},n)]}),_extends({},s,{Type:Syntax.ArraySubscript,params:[s,_extends({},n)]})]})})}})(a);const o=Object.values(_extends({},i,n));return _extends({},r,{Type:Syntax.Block,params:o.map(t)})}return _extends({},n,{params:n.params.map(t)})});const CLOSURE_FREE="closure-free",CLOSURE_MALLOC="closure-malloc",CLOSURE_BASE="closure-base",CLOSURE_INNER="closure-inner",CLOSURE_GET="closure--get",CLOSURE_SET="closure--set",expandClosureIdentifier=e=>{const n=()=>_extends({},e,{params:[]});return[_extends({},e,{value:":",meta:{},Type:Syntax.Pair,params:[n(),_extends({},e,{value:"i32",type:"i32",meta:{},params:[],Type:Syntax.Type})]}),...e.params,_extends({},e,{value:":",Type:Syntax.Pair,meta:{},params:[_extends({},e,{value:">>",meta:{},Type:Syntax.BinaryExpression,params:[n(),_extends({},e,{value:"32",type:"i32",meta:{},params:[],Type:Syntax.Constant})]}),_extends({},e,{meta:{},value:"i32",type:"i32",params:[],Type:Syntax.Type})]})]},collapseClosureIdentifier=(e,n)=>_extends({},e,{value:"+",Type:Syntax.BinaryExpression,params:[_extends({},e,{value:":",meta:{},Type:Syntax.Pair,params:[_extends({},e,{Type:Syntax.Identifier,params:[]}),_extends({},e,{value:"i64",type:"i64",Type:Syntax.Type,params:[]})]}),_extends({},n,{value:"<<",Type:Syntax.BinaryExpression,params:[n,_extends({},n,{value:"32",type:"i64",meta:{},params:[],Type:Syntax.Constant})]})]}),mapIdentifierToOffset=(e,n)=>_extends({},e,{value:"+",params:[_extends({},e,{value:String(n),Type:Syntax.Constant,type:"i32"}),_extends({},e,{Type:Syntax.Identifier,params:[]})],Type:Syntax.BinaryExpression}),getEnclosedVariables=e=>{const n={};const t=curry_1((e,t,r)=>{null==e[t.value]&&(n[t.value]=t)});const r=curry_1((e,n,t)=>{e[n.value]=n});walker({[Syntax.Closure]:(e,n)=>{const a={};const i=r(a);walker({[Syntax.FunctionArguments]:(e,n)=>{walker({[Syntax.Pair]:e=>{const[n]=e.params;i(n,null)}})(e)},[Syntax.Declaration]:i,[Syntax.ImmutableDeclaration]:i,[Syntax.Identifier]:t(a)})(e)}})(e);return n},injectEnvironmentMaybe=({mapFunctionCall:e,variables:n},t)=>{if(Object.keys(n).length>0){const n=t[2];return[...t.slice(0,2),_extends({},n,{value:CLOSURE_BASE,type:"i32",Type:Syntax.Declaration,params:[e(_extends({},n,{type:"i32",meta:{},value:CLOSURE_MALLOC,Type:Syntax.FunctionCall,params:[_extends({},n,{params:[],type:"i32",value:"0",Type:Syntax.Constant})]}))]}),...t.slice(2)]}return t},transformClosedDeclaration=curry_1((e,n,t)=>{const{closures:r,locals:a}=e;const[i]=n.params;if(n.value===CLOSURE_BASE)return _extends({},a[n.value],{params:[_extends({},i,{params:[_extends({},i.params[0],{value:r.envSize})]})].map(t)});if(i&&null!=r.variables[n.value]){const{offsets:e}=r;return t(_extends({},i,{value:`${CLOSURE_SET}-${n.type}`,params:[_extends({},mapIdentifierToOffset(_extends({},i,{value:CLOSURE_BASE}),e[n.value])),i],meta:{},Type:Syntax.FunctionCall}))}return _extends({},a[n.value],{params:a[n.value].params.map(t)})});var makeClosure=curry_1(function(e,n,t){const{locals:r,closures:a,fun:i}=e,{variables:o,offsets:s}=a;return t(mapNode({[Syntax.FunctionDeclaration]:e=>_extends({},e,{value:`internalClosure--${i.value}`}),[Syntax.FunctionArguments]:(e,n)=>_extends({},e,{params:[_extends({},e,{value:":",params:[_extends({},e,{value:CLOSURE_INNER,params:[],Type:Syntax.Identifier}),_extends({},e,{value:"i32",type:"i32",params:[],Type:Syntax.Type})],Type:Syntax.Pair}),...e.params]}),[Syntax.Assignment]:e=>{const[n,t]=e.params;if(null!=o[n.value]){const a=r[n.value];return _extends({},e,{value:`closure--set-${a.type}`,params:[mapIdentifierToOffset(_extends({},n,{value:String(CLOSURE_INNER)}),s[a.value]),t],meta:{},Type:Syntax.FunctionCall})}return e},[Syntax.Identifier]:(e,n)=>{if(null!=o[e.value]){const n=r[e.value];return _extends({},e,{value:`closure--get-${n.type}`,params:[mapIdentifierToOffset(_extends({},e,{value:CLOSURE_INNER}),s[n.value])],Type:Syntax.FunctionCall})}return e}})(n))}),makeFunctionCall=curry_1(function(e,n){const{functions:t,types:r,locals:a,mapIdentifier:i,mapSizeof:o}=e;if("sizeof"===n.value)return o(n);if(null!=a[n.value]){const e=_extends({},i(n),{Type:Syntax.Identifier}),t=_extends({},e.meta),a=(()=>{const t=r[e.type];return null!=t?t.type:n.type})();if(null!=e.meta[CLOSURE_TYPE])return _extends({},n,{meta:t,type:a,Type:Syntax.IndirectFunctionCall,params:[...expandClosureIdentifier(e)]});const o=Object.keys(r).indexOf(e.type);return _extends({},n,{meta:_extends({},t,{[TYPE_INDEX]:o}),type:a,params:[...n.params,e],Type:Syntax.IndirectFunctionCall})}const s=Object.keys(t).indexOf(n.value);return _extends({},n,{type:null!=t[n.value]?t[n.value].type:null,meta:{[FUNCTION_INDEX]:s}})}),makePair=curry_1((e,n,t)=>{const[r,a]=n.params.map(t);const{type:i}=r;const{value:o}=a;if(a.Type===Syntax.Type&&i&&o)return _extends({},n,{type:o,value:r.value,Type:Syntax.TypeCast,meta:_extends({},n.meta,{[TYPE_CAST]:{to:o,from:i}}),params:[r]});return _extends({},n,{params:n.params.map(t)})});const typeWeight=e=>{switch(e){case"i32":return 0;case"i64":return 1;case"f32":return 2;case"f64":return 3;default:return-1}},balanceTypesInMathExpression=e=>{const n=e.params.reduce((e,{type:n})=>{if(typeWeight(e)<typeWeight(n))return n;return e},null);const t=e.params.map(e=>{if(null!=e.type&&e.type!==n)return _extends({},e,{type:n,value:e.value,Type:Syntax.TypeCast,meta:_extends({},e.meta,{[TYPE_CAST]:{to:n,from:e.type}}),params:[e]});return e});return _extends({},e,{params:t,type:n})},initialize=(e,n)=>{const{functions:t,types:r}=e;const a={};let i=0;const o={variables:getEnclosedVariables(n),offsets:{},envSize:0};const s=walker({[Syntax.FunctionArguments]:(n,t)=>{walker({[Syntax.Pair]:n=>{i+=1;const[r,s]=n.params;const u=_extends({},r,{type:s.value});parseDeclaration(!1,_extends({},e,{locals:a,closures:o}),u,t)}})(n)},[Syntax.Declaration]:parseDeclaration(!1,_extends({},e,{locals:a,closures:o})),[Syntax.ImmutableDeclaration]:parseDeclaration(!0,_extends({},e,{locals:a,closures:o}))})(_extends({},n,{type:(()=>{const e=n.params[1];if(null!=r[e.value]&&r[e.value].meta[CLOSURE_TYPE])return"i64";return e.type})(),meta:_extends({},n.meta,{[FUNCTION_INDEX]:Object.keys(t).length,[FUNCTION_METADATA]:{locals:a,get argumentsCount(){return i}}}),params:injectEnvironmentMaybe(_extends({mapFunctionCall:makeFunctionCall(_extends({},e,{locals:a,mapIdentifier:mapIdentifier(_extends({locals:a},e)),mapSizeof:mapSizeof(_extends({locals:a},e))}))},o),n.params)}));t[n.value]=s;return[s,a,o]},mapFunctionNode=(e,n,t)=>{const[r,a,i]=initialize(e,n);const o=mapIdentifier(_extends({},e,{locals:a}));const s=mapArraySubscript(_extends({},e,{locals:a}));const u=mapSizeof(_extends({},e,{locals:a}));const c=makeAssignment(_extends({},e,{locals:a}));const p=makeClosure(_extends({},e,{fun:r,locals:a,closures:i}));const l=makePair(_extends({},e,{locals:a,mapIdentifier:o,mapClosure:p,topLevelTransform:t}));const d=makeFunctionCall(_extends({},e,{locals:a,mapIdentifier:o,mapSizeof:u}));return mapNode({[Syntax.FunctionArguments]:(e,n)=>mapNode({[Syntax.Pair]:e=>{const[n,t]=e.params;return _extends({},e,{params:[a[n.value],t]})}})(e),[Syntax.Declaration]:transformClosedDeclaration(_extends({},e,{locals:a,closures:i})),[Syntax.ImmutableDeclaration]:transformClosedDeclaration(_extends({},e,{locals:a,closures:i})),[Syntax.Identifier]:o,[Syntax.FunctionCall]:d,[Syntax.Pair]:l,[Syntax.UnaryExpression]:(e,n)=>{const t=e.params[0];const r=n(e.params[1]);return _extends({},e,{type:r.type,params:[_extends({},t,{type:r.type}),r],Type:Syntax.BinaryExpression})},[Syntax.BinaryExpression]:(e,n)=>balanceTypesInMathExpression(_extends({},e,{params:e.params.map(n)})),[Syntax.TernaryExpression]:(e,n)=>{const t=e.params.map(n);return _extends({},e,{type:t[0].type,params:t})},[Syntax.Select]:(e,n)=>balanceTypesInMathExpression(_extends({},e,{params:e.params.map(n)})),[Syntax.Assignment]:c,[Syntax.MemoryAssignment]:(e,n)=>{const t=e.params.map(n);const{type:r}=t[0];return _extends({},e,{params:t,type:r})},[Syntax.ReturnStatement]:e=>{const[n]=e.params;if(null!=n&&n.Type===Syntax.Constant&&n.type!==r.type)return _extends({},e,{params:[_extends({},n,{value:":",Type:Syntax.Pair,params:[n,_extends({},n,{value:String(r.type),type:r.type,Type:Syntax.Type,params:[]})]})]});return e},[Syntax.ArraySubscript]:s,[Syntax.Sizeof]:u,[Syntax.Closure]:(n,r)=>{const i=p(n,t);const[s]=i.params;e.hoist.push(s);return r(collapseClosureIdentifier(_extends({},a[CLOSURE_BASE],{meta:[]}),o(_extends({},s,{params:[],type:"i32",Type:Syntax.Identifier,meta:[]}))))}})(r)};var mapFunctionNode$1=curry_1(mapFunctionNode);const getByteOffsetsAndSize=e=>{const n={};const t={};let r=0;walker({[Syntax.Pair]:e=>{const{value:a}=e.params[0];const{value:i}=e.params[1];invariant_1(null==n[a],`Duplicate key ${a} not allowed in object type`);t[a]=i;n[a]=r;switch(i){case"i64":case"f64":r+=8;break;case"i32":case"f32":default:r+=4}}})(e);return[n,r,t]},mapStruct=curry_1(({userTypes:e},n,t)=>{const[r,a,i]=getByteOffsetsAndSize(n.params[0]);const o=_extends({},n,{meta:{[TYPE_OBJECT]:r,[OBJECT_SIZE]:a,[OBJECT_KEY_TYPES]:i}});e[o.value]=o;return o}),mapGeneric=curry_1((e,n,t)=>{const{types:r}=e;const[a,i]=n.params;const o=r[i.value];const[s,u]=o.params;const c=_extends({},o,{range:a.range,value:n.value,meta:_extends({},o.meta,{[CLOSURE_TYPE]:"Lambda"===a.value}),params:[_extends({},s,{params:[_extends({},s,{params:[],type:"i32",value:"i32",Type:Syntax.Type}),...s.params]}),u]});r[c.value]=c;return c}),GLOBAL_LABEL="global",_debug=(e,n=0,t)=>{let r=0;return e.data.slice(n,t).map(({type:n,value:t,debug:a})=>{const i=r.toString(16).padStart(8,"0").padEnd(e.data.length.toString().length+1);let o;o=Array.isArray(t)?t.map(e=>e.toString(16)).join().padStart(16):t.toString(16).padStart(16);const s=`${i}: ${o} ; ${a}`;r+=index_16[n]||t.length;return s}).join("\n")+"\n ============ fin ============="},source=`\n  const memory: Memory = { initial: 1 };\n  let heapPointer: i32 = 0;\n  export function malloc(size: i32): i32 {\n    const ptr: i32 = heapPointer;\n    heapPointer += size;\n    return ptr;\n  }\n\n  export function free(ptr: i32) {\n  }\n\n  // Getters\n  export function geti32(ptr: i32): i32 {\n    const view: i32[] = ptr;\n    return view[0];\n  }\n\n  export function getf32(ptr: i32): f32 {\n    const view: f32[] = ptr;\n    return view[0];\n  }\n\n  export function geti64(ptr: i32): i64 {\n    const view: i64[] = ptr;\n    return view[0];\n  }\n\n  export function getf64(ptr: i32): f64 {\n    const view: f64[] = ptr;\n    return view[0];\n  }\n\n  // Setters\n  export function seti32(ptr: i32, value: i32) {\n    const view: i32[] = ptr;\n    view[0] = value;\n  }\n\n  export function setf32(ptr: i32, value: f32) {\n    const view: f32[] = ptr;\n    view[0] = value;\n  }\n\n  export function seti64(ptr: i32, value: i64) {\n    const view: i64[] = ptr;\n    view[0] = value;\n  }\n\n  export function setf64(ptr: i32, value: f64) {\n    const view: f64[] = ptr;\n    view[0] = value;\n  }\n`,mapToImports=e=>{const{malloc:n,free:t,geti32:r,getf32:a,geti64:i,getf64:o,seti32:s,setf32:u,seti64:c,setf64:p}=e.instance.exports;return{[CLOSURE_MALLOC]:n,[CLOSURE_FREE]:t,[`${CLOSURE_GET}-i32`]:r,[`${CLOSURE_GET}-f32`]:a,[`${CLOSURE_GET}-i64`]:i,[`${CLOSURE_GET}-f64`]:o,[`${CLOSURE_SET}-i32`]:s,[`${CLOSURE_SET}-f32`]:u,[`${CLOSURE_SET}-i64`]:c,[`${CLOSURE_SET}-f64`]:p}},debug=_debug,prettyPrintNode=printNode,semantics=semantics$1,generator=generator$1,validate=validate$1,emitter=emit,getIR=(e,{version:n=VERSION_1,encodeNames:t=!1,lines:r=(e?e.split("\n"):[]),filename:a="unknown"}={})=>{const i=parse(e);const o=semantics(i);validate(o,{lines:r,filename:a});const s=generator(o,{version:n,encodeNames:t,lines:r,filename:a});const u=emitter(s,{version:n,encodeNames:t,filename:a,lines:r});return u},withPlugins=(e,n)=>{const{closure:t}=e;const r={};null!=t&&(r["walt-plugin-closure"]=mapToImports(t));return _extends({},r,n)};exports.debug=debug,exports.prettyPrintNode=prettyPrintNode,exports.semantics=semantics,exports.generator=generator,exports.validate=validate,exports.emitter=emitter,exports.parser=parse,exports.printNode=printNode,exports.closurePlugin=closurePlugin$$1,exports.getIR=getIR,exports.withPlugins=withPlugins,exports.default=compileWalt,Object.defineProperty(exports,"__esModule",{value:!0})});
